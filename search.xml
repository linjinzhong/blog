<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排序算法</title>
    <url>/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>十大经典排序算法介绍和实现</p>
<span id="more"></span>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="排序算法介绍"><a href="#排序算法介绍" class="headerlink" title="排序算法介绍"></a>排序算法介绍</h2><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">最坏时间复杂度</th>
<th align="center">最好时间复杂度</th>
<th align="center">平均时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(logn)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">O(n+m)</td>
<td align="center">O(n+m)</td>
<td align="center">O(n+m)</td>
<td align="center">O(m)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n+m)</td>
<td align="center">O(n+m)</td>
<td align="center">O(n+m)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(n x m)</td>
<td align="center">O(n x m)</td>
<td align="center">O(n x m)</td>
<td align="center">O(n+m)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ol>
<li>介绍  <ol>
<li>比较相邻元素，交换；</li>
<li>第一轮将第n大（最大）元素逐个交换冒泡到位置n（最后）；</li>
<li>第x轮将第x大元素逐个交换冒泡到位置x；</li>
<li>第n轮将最1大（最小）元素逐个交换冒泡到位置1；</li>
<li>*<em>（无序区，有序区），从无序区通过相邻交换将最大元素冒泡到有序区前端</em>。*</li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n^2) ~ O(n)<br> 空间复杂度：O(1)<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = bubble_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">BubbleSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ol>
<li>介绍  <ol>
<li>在未排序的序列里寻找最小元素索引，交换到起始位置；</li>
<li>再从剩余未排序元素中寻找最小元素，放到已排序序列的末尾；</li>
<li>重复2直到最后一个元素；</li>
<li><strong>（有序区，无序区），从无序区找一个最小的放在有序区的后面，比较多，换得少。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n^2) ~ O(n^2)<br> 空间复杂度：O(1)<br> 稳定性：不稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        <span class="keyword">if</span> i != min_idx:</span><br><span class="line">            arr[i], arr[min_idx] = arr[min_idx], arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = select_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx])</span><br><span class="line">                min_idx = j;</span><br><span class="line">        <span class="keyword">if</span> (i != min_idx)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[min_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">SelectSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ol>
<li>介绍  <ol>
<li>先用第一个元素做已排序序列，其余为未排序序列；</li>
<li>遍历未排序序列，将每个元素插入到之前已排序序列的合适位置；</li>
<li>插入过程将已排序序列元素逐个后移；</li>
<li><strong>（有序区，无序区），把无序区的第一个元素插入到有序区的合适位置。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n^2) ~ O(n)<br> 空间复杂度：O(1)<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        pre_idx = i - <span class="number">1</span></span><br><span class="line">        cur = arr[i]</span><br><span class="line">        <span class="keyword">while</span> pre_idx &gt;= <span class="number">0</span> <span class="keyword">and</span> cur &lt; arr[pre_idx]:</span><br><span class="line">            arr[pre_idx+<span class="number">1</span>] = arr[pre_idx]</span><br><span class="line">            pre_idx -= <span class="number">1</span></span><br><span class="line">        arr[pre_idx+<span class="number">1</span>] = cur</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = insert_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> pre_idx = i - <span class="number">1</span>;</span><br><span class="line">        T cur = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (pre_idx &gt;= <span class="number">0</span> &amp;&amp; cur &lt; arr[pre_idx]) &#123;</span><br><span class="line">            arr[pre_idx+<span class="number">1</span>] = arr[pre_idx];</span><br><span class="line">            pre_idx--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[pre_idx+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">InsertSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ol>
<li>介绍  <ol>
<li>也称递减增量排序算法，是插入排序的一种更高效的改进版本；</li>
<li>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序；</li>
<li><strong>每一轮按照事先决定的间隔进行插入排序，间隔依次减少直到1。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(nlogn) ~ O(nlogn) ~ O(n)<br> 空间复杂度：O(1)<br> 稳定性：不稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    gap = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(arr)):</span><br><span class="line">            pre_idx = i - gap</span><br><span class="line">            cur = arr[i]</span><br><span class="line">            <span class="keyword">while</span> pre_idx &gt;= <span class="number">0</span> <span class="keyword">and</span> cur &lt; arr[pre_idx]:</span><br><span class="line">                arr[pre_idx + gap] = arr[pre_idx]</span><br><span class="line">                pre_idx -= gap</span><br><span class="line">            arr[pre_idx + gap] = cur</span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = shell_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = len / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> pre_idx = i - gap;</span><br><span class="line">            T cur = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (pre_idx &gt;= <span class="number">0</span> &amp;&amp; cur &lt; arr[pre_idx]) &#123;</span><br><span class="line">                arr[pre_idx + gap] = arr[pre_idx];</span><br><span class="line">                pre_idx -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[pre_idx + gap] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">ShellSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol>
<li>介绍  <ol>
<li>分治法，自上而下递归或者自下而上的迭代；</li>
<li><strong>把序列分为两段，递归保证两段有序后再合并有序的两段。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(nlogn) ~ O(nlogn) ~ O(nlogn)<br> 空间复杂度：O(n)<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr_left, arr_right</span>):</span><br><span class="line">    arr_res = []</span><br><span class="line">    <span class="keyword">while</span> arr_left <span class="keyword">and</span> arr_right:</span><br><span class="line">        <span class="keyword">if</span> arr_left[<span class="number">0</span>] &lt;= arr_right[<span class="number">0</span>]:</span><br><span class="line">            arr_res.append(arr_left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr_res.append(arr_right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> arr_left:</span><br><span class="line">        arr_res.extend(arr_left)</span><br><span class="line">    <span class="keyword">if</span> arr_right:</span><br><span class="line">        arr_res.extend(arr_right)</span><br><span class="line">    <span class="keyword">return</span> arr_res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    middle = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    arr_left, arr_right = arr[<span class="number">0</span>:middle], arr[middle:]</span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(arr_left), merge_sort(arr_right))</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = merge_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T *arr_ori = arr;</span><br><span class="line">    T *res = <span class="keyword">new</span> T[len];</span><br><span class="line">    <span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len) &#123;  <span class="comment">// 递归每轮</span></span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += gap * <span class="number">2</span>) &#123;  <span class="comment">// 每轮对比组</span></span><br><span class="line">            <span class="type">int</span> ll = j, lr = j + gap;</span><br><span class="line">            <span class="type">int</span> rl = lr, rr = lr + gap;</span><br><span class="line">            <span class="keyword">while</span> (rl &lt; len &amp;&amp; ll &lt; lr &amp;&amp; rl &lt; rr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[ll] &lt;= arr[rl]) &#123;</span><br><span class="line">                    res[p++] = arr[ll++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[p++] = arr[rl++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (ll &lt; lr &amp;&amp; ll &lt; len)</span><br><span class="line">                res[p++] = arr[ll++];</span><br><span class="line">            <span class="keyword">while</span> (rl &lt; rr &amp;&amp; rl &lt; len)</span><br><span class="line">                res[p++] = arr[rl++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *tmp = arr;</span><br><span class="line">        arr = res;</span><br><span class="line">        res = tmp;</span><br><span class="line">        gap *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr != arr_ori) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        res = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ol>
<li>介绍  <ol>
<li>冒泡排序基础上的递归分治法；</li>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面；</li>
<li>在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；    </li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
<li><strong>（小区间，基准元素吗，大区间）在区间中随机挑选一个元素作为基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数和大数区间进行排序。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n2) ~ O(nlogn) ~ O(nlogn)<br> 空间复杂度：O(logn)<br> 稳定性：不稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    middle_value = arr[left]  <span class="comment"># 取首元素为分割点</span></span><br><span class="line">    p = left</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left + <span class="number">1</span>, right):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= middle_value:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">            arr[p], arr[i] = arr[i], arr[p]</span><br><span class="line">    arr[left], arr[p] = arr[p], arr[left]</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition2</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    middle_value = arr[right - <span class="number">1</span>]  <span class="comment"># 取尾元素尾分割点</span></span><br><span class="line">    p = left</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= middle_value:</span><br><span class="line">            arr[p], arr[i] = arr[i], arr[p]</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">    arr[p], arr[right - <span class="number">1</span>] = arr[right - <span class="number">1</span>], arr[p]</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        middle = partition1(arr, left, right)</span><br><span class="line">        quick_sort(arr, left, middle)</span><br><span class="line">        quick_sort(arr, middle + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = quick_sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partion</span><span class="params">(T arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    T middle_value = arr[left];</span><br><span class="line">    <span class="type">int</span> p = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; middle_value) &#123;</span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(arr[p], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[p], arr[left]);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(T arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> middle = <span class="built_in">Partion</span>(arr, left, right);</span><br><span class="line">        <span class="built_in">QuickSort</span>(arr, left, middle);</span><br><span class="line">        <span class="built_in">QuickSort</span>(arr, middle + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol>
<li>介绍  <ol>
<li>创建一个最大堆 H[0……n-1]；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>除去堆尾后调整堆；</li>
<li>重复2，3；</li>
<li><strong>（最大堆，有序区）交换堆顶元素与有序区前一个元素，再调整堆。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(nlogn) ~ O(nlogn) ~ O(nlogn)<br> 空间复杂度：O(1)<br> 稳定性：不稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adjust_heap</span>(<span class="params">arr, head, tail</span>):</span><br><span class="line">    left = head * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    right = left + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; tail <span class="keyword">and</span> arr[right] &gt; arr[left]:</span><br><span class="line">        left = right</span><br><span class="line">    <span class="keyword">if</span> left &lt; tail <span class="keyword">and</span> arr[head] &lt; arr[left]:</span><br><span class="line">        arr[head], arr[left] = arr[left], arr[head]</span><br><span class="line">        adjust_heap(arr, left, tail)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_max_heap</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        adjust_heap(arr, i, <span class="built_in">len</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    build_max_heap(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(arr, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = heap_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AdjustHeap</span><span class="params">(T arr[], <span class="type">int</span> head, <span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = head * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; tail &amp;&amp; arr[right] &gt; arr[left])</span><br><span class="line">        left = right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; tail &amp;&amp; arr[head] &lt; arr[left]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[head], arr[left]);</span><br><span class="line">        <span class="built_in">AdjustHeap</span>(arr, left, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BuildMaxHeap</span><span class="params">(T arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i--) &#123;  <span class="comment">// 首元素也要调整</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">// 最多交换到第1元素</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">AdjustHeap</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">HeapSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><ol>
<li>介绍  <ol>
<li>计数排序不是比较排序，排序的速度快于任何比较排序算法；</li>
<li>线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数；</li>
<li><strong>新建数组统计等于该元素值索引的元素个数i，再反向写回数组。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n + m) ~ O(n + m) ~ O(n + m)<br> 空间复杂度：O(m)，m是元素最大值<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    len_bucket = <span class="built_in">max</span>(arr) + <span class="number">1</span></span><br><span class="line">    bucket = [<span class="number">0</span>] * len_bucket</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        bucket[i] += <span class="number">1</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len_bucket):</span><br><span class="line">        <span class="keyword">while</span> bucket[j]:</span><br><span class="line">            arr[idx] = j</span><br><span class="line">            bucket[j] -= <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = count_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len_bucket = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (len_bucket &lt; arr[i])</span><br><span class="line">            len_bucket = arr[i];</span><br><span class="line">    <span class="type">int</span> *bucket = <span class="keyword">new</span> <span class="type">int</span>[len_bucket + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len_bucket + <span class="number">1</span>; j++)</span><br><span class="line">        <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[idx++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] bucket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">CountSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ol>
<li>介绍  <ol>
<li>根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；</li>
<li>遍历排序序列，将每个元素放到对应的桶里去；</li>
<li>对不是空的桶进行排序；</li>
<li>按顺序访问桶，将桶中的元素依次放回到原序列中对应的位置，完成排序。</li>
<li><strong>新建数组统计等于该元素值索引的元素个数i，再反向写回数组。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n+m) ~ O(n+m)<br> 空间复杂度：O(n+m)，m个桶<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;桶排序&quot;&quot;&quot;</span></span><br><span class="line">    min_num, max_num = <span class="built_in">min</span>(arr), <span class="built_in">max</span>(arr)</span><br><span class="line">    <span class="comment"># 桶大小</span></span><br><span class="line">    bucket_range = (max_num - min_num) / <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 桶数组</span></span><br><span class="line">    bucket_list = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 向桶填数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        bucket_list[<span class="built_in">int</span>((i - min_num) / bucket_range)].append(i)</span><br><span class="line">    <span class="comment"># 回填</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bucket_list:</span><br><span class="line">        left, right = right, right + <span class="built_in">len</span>(i)</span><br><span class="line">        arr[left:right] = <span class="built_in">sorted</span>(i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = bucket_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T min_num = arr[<span class="number">0</span>];</span><br><span class="line">    T max_num = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min_num)</span><br><span class="line">            min_num = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max_num)</span><br><span class="line">            max_num = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> bucket_range = <span class="built_in">double</span>(max_num - min_num) / len;</span><br><span class="line">    std::vector&lt;std::vector&lt;T&gt; &gt; <span class="built_in">bucket_list</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        bucket_list[(arr[i] - min_num) / bucket_range].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(bucket_list[i].<span class="built_in">begin</span>(), bucket_list[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket_list[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            arr[left++] = bucket_list[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">BucketSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ol>
<li>介绍  <ol>
<li>非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较；</li>
<li>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>对数位较短的数前面补零；</li>
<li>分配，先从个位开始，根据位值(0-9)分别放到0~9号桶中;</li>
<li>收集，再将放置在0~9号桶中的数据按顺序放到数组中;</li>
<li>重复3~4过程，直到最高位，即可完成排序;</li>
<li>** 按位迭代排序 **</li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n+m) ~ O(n+m)<br> 空间复杂度：O(n+m)，m个桶<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基数排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 记录最大值的位数</span></span><br><span class="line">    m = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(arr)))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):  <span class="comment"># m轮排序</span></span><br><span class="line">        <span class="comment"># 如果是数字，建立0-9折十个桶</span></span><br><span class="line">        bucket_list = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="comment"># 如果是26个英文字母字符串，建立26个桶</span></span><br><span class="line">        <span class="comment"># bucket_list = [[] for i in range(26)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            bucket_list[(a // <span class="number">10</span>**k) % <span class="number">10</span>].append(a)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从桶中拿出</span></span><br><span class="line">        arr = [a <span class="keyword">for</span> bucket <span class="keyword">in</span> bucket_list <span class="keyword">for</span> a <span class="keyword">in</span> bucket]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = radix_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录最大位数</span></span><br><span class="line">    T max_num = *<span class="built_in">max_element</span>(arr, arr + len);</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        max_num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;  <span class="comment">// m轮排序</span></span><br><span class="line">        std::vector&lt;std::vector&lt;T&gt; &gt; <span class="built_in">bucket_list</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            bucket_list[<span class="built_in">int</span>(arr[i] / (<span class="built_in">pow</span>(<span class="number">10</span>, k))) % <span class="number">10</span>].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket_list[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                arr[p++] = bucket_list[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">20</span>, <span class="number">111</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">RadixSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>桶的概念<br> 计数排序：每个桶只存储单一键值；<br> 桶排序：每个桶存储一定范围的数值；<br> 基数排序：根据键值的每位数字来分配桶；  </li>
<li>关于稳定性<br> 排序后 2 个相等键值的顺序和排序之前它们的顺序相同；<br> 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序；<br> 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序；</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法</a><br><a href="https://www.zhihu.com/column/Use-Python-to-Achieve">python实现·十大排序算法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>bash</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/bash/</url>
    <content><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。</p>
<span id="more"></span>


<h2 id="shell含义和种类"><a href="#shell含义和种类" class="headerlink" title="shell含义和种类"></a>shell含义和种类</h2><ol>
<li>Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</li>
<li>Shell 是指一种用 C 语言编写的应用程序，提供了一个界面，用户通过这个界面访问操作系统内核的服务。Shell 是一个命令解释器，解释用户输入的命令。</li>
<li>用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。</li>
<li>shell包含bash、sh、csh、tcsh、ksh、zsh、fish，其中bash是最常用的shell。</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p><code>date</code>命令  </p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取当前格式化日期</span><br><span class="line">date_time=`date +%Y/%m/%d-%H:%M:%S`</span><br><span class="line"># 获取前一天日期</span><br><span class="line">early_date=`date -d -1days +%Y/%m/%d`</span><br><span class="line"># 获取后一天日期</span><br><span class="line">early_date=`date -d +1days +%Y/%m/%d`</span><br><span class="line"># 获取当前时间戳</span><br><span class="line">cur_timestamp=`date +%s`</span><br><span class="line"># 获取前1天此时的时间戳</span><br><span class="line">cur_timestamp=e</span><br><span class="line"># 获取后一天此时的时间戳</span><br><span class="line">cur_timestamp=`date -d +1days +%s`</span><br></pre></td></tr></table></figure></li>
<li><p>操作mysql数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sql语句</span><br><span class="line">sql=&quot;update $&#123;mysql_table&#125; set status=-1 where status=1;&quot;</span><br><span class="line"># 执行sql语句</span><br><span class="line">op=`mysql --host=&quot;localhost&quot; --user=root --password=密码 -v -v -e &quot;$&#123;sql&#125;&quot;`</span><br><span class="line"># 参数-v -v 输出sql语句和结果</span><br><span class="line"># 参数-N输出结果不含列名，-s静默输出，每个结果一行</span><br></pre></td></tr></table></figure>
</li>
<li><p>脚本里生成配置文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">cat &gt; /root/a.sh &lt;&lt; EOF</span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">echo &quot;hello bash&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># 注释：说明当前脚本功能</span><br><span class="line"></span><br><span class="line"># 设置脚本错误停止、变量不存在停止、打印命令、管道命令错误一个也停止</span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line"># 脚本文件名和参数</span><br><span class="line">echo &#x27;脚本名称：$0=&#x27; $0</span><br><span class="line">echo &#x27;参数数量：$#=&#x27; $#</span><br><span class="line">echo &#x27;参数1：$1=&#x27; $1</span><br><span class="line">echo &#x27;参数2：$2=&#x27; $2</span><br><span class="line">echo &#x27;所有参数：$@=&#x27; $@</span><br><span class="line"></span><br><span class="line"># 遍历打印参数</span><br><span class="line">for i in &quot;$@&quot;;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 读取文件</span><br><span class="line">filename=&#x27;/etc/hosts&#x27;</span><br><span class="line">while read myline</span><br><span class="line">do</span><br><span class="line">    echo &quot;$myline&quot;</span><br><span class="line">done &lt; $filename</span><br><span class="line"></span><br><span class="line"># 函数定义</span><br><span class="line">#######################################</span><br><span class="line"># Cleanup files from the backup dir</span><br><span class="line"># Globals:</span><br><span class="line">#   BACKUP_DIR</span><br><span class="line">#   ORACLE_SID</span><br><span class="line"># Arguments:</span><br><span class="line">#   None</span><br><span class="line"># Returns:</span><br><span class="line">#   None</span><br><span class="line">#######################################</span><br><span class="line">cleanup() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 退出值为0（成功）</span><br><span class="line">exit 0</span><br><span class="line"># 退出值为1（失败）</span><br><span class="line"></span><br><span class="line">exit 1</span><br></pre></td></tr></table></figure>


<h2 id="实践2-删除数据库前N天创建的前缀为xxx的表"><a href="#实践2-删除数据库前N天创建的前缀为xxx的表" class="headerlink" title="实践2-删除数据库前N天创建的前缀为xxx的表"></a>实践2-删除数据库前N天创建的前缀为xxx的表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># 注释：删除数据库N天前创建的前缀为table_prefix的表</span><br><span class="line"></span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line">N=7</span><br><span class="line">table_prefix=&#x27;tb_xxx_&#x27;</span><br><span class="line"></span><br><span class="line">__str__=&quot;删除数据库$N天前创建的前缀为$&#123;table_prefix&#125;的表&quot;</span><br><span class="line">echo -e &quot;title: $__str__\n&quot;</span><br><span class="line"></span><br><span class="line">host=&#x27;&#x27;</span><br><span class="line">port=&#x27;&#x27;</span><br><span class="line">user=&#x27;&#x27;</span><br><span class="line">passwd=&#x27;&#x27;</span><br><span class="line">db=&quot;&quot;</span><br><span class="line">mysql_export=&quot;export MYSQL_PWD=$&#123;passwd&#125;&quot;</span><br><span class="line">mysql_login=&quot;mysql -h$host -P$port -u$user -D$db&quot;</span><br><span class="line">echo -e &quot;db: $mysql_login\n&quot;</span><br><span class="line"></span><br><span class="line">sql_select=&quot;select TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA=\&quot;$db\&quot; and TABLE_NAME like &#x27;$&#123;table_prefix&#125;%&#x27; and DATEDIFF(now(), CREATE_TIME)&gt;$N order by CREATE_TIME asc&quot;</span><br><span class="line"></span><br><span class="line">tables=`$mysql_export &amp;&amp; $mysql_login -N -e &quot;$sql_select&quot;`</span><br><span class="line">echo -e &quot;res_sql_select: $tables\n&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$tables&quot; = &quot;&quot; ]; then</span><br><span class="line">    echo &quot;NULL, exit&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">wait_del_tables=&#x27;&#x27;</span><br><span class="line">cnt=0</span><br><span class="line">for table in $tables; do</span><br><span class="line">    wait_del_tables=&quot;$wait_del_tables,$db.$table&quot;</span><br><span class="line">    ((cnt++))</span><br><span class="line">done</span><br><span class="line">wait_del_tables=$&#123;wait_del_tables:1&#125;</span><br><span class="line">echo -e &quot;wait_del_tables: $wait_del_tables\n&quot;</span><br><span class="line"></span><br><span class="line">sql_drop=&quot;drop table $wait_del_tables&quot;</span><br><span class="line">res=`$mysql_export &amp;&amp; $mysql_login -e &quot;$sql_drop&quot;`</span><br><span class="line">echo -e &quot;res_sql_drop: $res\n&quot;</span><br><span class="line"></span><br><span class="line">echo -e &quot;Successfully drop $cnt tables\n&quot;</span><br></pre></td></tr></table></figure>


<h2 id="实践3-进程监控和保活"><a href="#实践3-进程监控和保活" class="headerlink" title="实践3-进程监控和保活"></a>实践3-进程监控和保活</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># 注释：进程监控和保活</span><br><span class="line"></span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line"># 参数检查</span><br><span class="line">if [ $# -lt 2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;please input PROGRAM_DIR and PROGRAM_NAME&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 进入进程启动目录</span><br><span class="line">cd $&#123;PROGRAM_DIR&#125;</span><br><span class="line"></span><br><span class="line"># 检查和启动进程</span><br><span class="line">RUN_CHECK() &#123;</span><br><span class="line">    # 检查进程是否存活</span><br><span class="line">    RUN_CHECK=`ps -ef | grep $&#123;PROGRAM_NAME&#125; | grep -wv grep | grep -wv vi | grep -wv tail | grep -wv $&#123;PROGRAM_CURRENT&#125; | grep -v &quot;\.sh&quot; | grep -v &quot;/alarm &quot; | wc -l`    </span><br><span class="line">    echo &quot;check_result: $&#123;RUN_CHECK&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # 进程不存在，则启动</span><br><span class="line">    if [ $&#123;RUN_CHECK&#125; -lt 1 ]</span><br><span class="line">    then</span><br><span class="line">        NOW_TIME=`date +%Y/%m/%d-%H:%M:%S`</span><br><span class="line">        echo &quot;$&#123;NOW_TIME&#125;, restart the program: $?&quot;</span><br><span class="line">        echo &#x27;nohup hexo s &amp;&#x27; | bash</span><br><span class="line">        echo &quot;Fatal: $&#123;PROGRAM_NAME&#125; down $&#123;RUN_CHECK&#125; $&#123;NOW_TIME&#125;&quot; &gt;&gt; down.log</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 每5秒检查一次</span><br><span class="line">STEP=5</span><br><span class="line">for (( i=0; i&lt;60; i=(i+$&#123;STEP&#125;) )) do</span><br><span class="line">    RUN_CHECK</span><br><span class="line">    sleep $&#123;STEP&#125;</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>


<h2 id="shell配置"><a href="#shell配置" class="headerlink" title="shell配置"></a>shell配置</h2><ol>
<li>查看当前默认shell和已安装shell <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">$ cat /etc/shells</span><br></pre></td></tr></table></figure></li>
<li>查看bash版本 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bash --version</span><br><span class="line">$ echo $BASH_VERSION</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol>
<li>echo-原样输出参数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 原因输出包括换行格式</span><br><span class="line">$ echo &quot;&lt;HTML&gt;</span><br><span class="line">&lt;HEAD&gt;</span><br><span class="line">      &lt;TITLE&gt;Page Title&lt;/TITLE&gt;</span><br><span class="line">&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY&gt;</span><br><span class="line">      Page body.</span><br><span class="line">&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;&quot;</span><br><span class="line"></span><br><span class="line"># -n 去掉末尾默认的换行符</span><br><span class="line">$ echo -n a;echo b</span><br><span class="line">ab</span><br><span class="line"></span><br><span class="line"># -e 解释引号(单/双引号)参数里的特殊字符</span><br><span class="line">$ echo &quot;hello\nworld&quot;</span><br><span class="line">hello\nworld</span><br><span class="line"></span><br><span class="line">$ echo -e &#x27;hello\nworld&#x27;</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure></li>
<li>命令格式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 短形式</span><br><span class="line">$ ls -r</span><br><span class="line"></span><br><span class="line"># 长形式</span><br><span class="line">$ ls --reverse</span><br><span class="line"></span><br><span class="line"># 太长换行，末尾加&#x27;\&#x27;</span><br><span class="line">$ echo foo bar</span><br><span class="line"># 等同于</span><br><span class="line">$ echo foo \</span><br><span class="line">bar</span><br></pre></td></tr></table></figure></li>
<li>空格-区分不同参数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ &lt;command&gt; foo bar</span><br></pre></td></tr></table></figure></li>
<li>分号-命令结束符，后面命令不依赖前面命令执行成功与否 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ clear; ls</span><br></pre></td></tr></table></figure></li>
<li>命令组合符号-&amp;&amp; 和 || <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 依赖前面命令执行成功才能执行后面命令</span><br><span class="line">$ &lt;command_1&gt; &amp;&amp; &lt;command_2&gt;</span><br><span class="line"></span><br><span class="line"># 前面命令执行失败才执行后面命令</span><br><span class="line">$ &lt;command_1&gt; || &lt;command_2&gt;</span><br></pre></td></tr></table></figure></li>
<li>type-显示命令类型 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ type echo</span><br></pre></td></tr></table></figure></li>
<li>快捷键<ul>
<li><code>ctrl + L</code>：清除屏幕</li>
<li><code>ctrl + C</code>：终止当前正在执行的命令</li>
</ul>
</li>
</ol>
<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><ol>
<li><code>~</code>：自动扩展成当前用户的主目录；</li>
<li><code>?</code>：代表文件路径里面的任意单个字符，不包括空字符；</li>
<li><code>*</code>：代表文件路径里面的任意数量的任意个字符，包括零个字符； <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示所有隐藏文件</span><br><span class="line">$ echo .*</span><br><span class="line"></span><br><span class="line"># 显示隐藏文件排除.和..</span><br><span class="line">$ echo .[!.]*</span><br></pre></td></tr></table></figure></li>
<li><code>[]</code>：可以匹配方括号里的任意一个字符； <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件名扩展</span><br><span class="line">$ echo a[bc]d</span><br><span class="line"># 匹配文件存在，显示如下</span><br><span class="line">abd acd</span><br><span class="line"># 匹配文件不存在，显示如下</span><br><span class="line">a[bc]d</span><br><span class="line"></span><br><span class="line"># !表示匹配除了b以外</span><br><span class="line">$ echo a[!b]d</span><br></pre></td></tr></table></figure></li>
<li><code>[start-end]</code>：连续范围扩展， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a-c] 等同于[abc]</span><br><span class="line">[0-9] 等同于[0123456789]</span><br><span class="line">[!0-9] 表示除0-9外的任意字符</span><br></pre></td></tr></table></figure></li>
<li><code>&#123;&#125;</code>: 表示分别扩展大括号里的所有值，使用逗号分割，逗号前后不能有空格 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 非文件名扩展，总是扩展，不管文件是否存在</span><br><span class="line">$ echo d&#123;a,b,c,d&#125;g</span><br><span class="line">dag dbg dcg ddg</span><br><span class="line"></span><br><span class="line"># 与其他组合，优先于其他</span><br><span class="line">$ echo /bin/&#123;cat,b*&#125;</span><br><span class="line">/bin/cat /bin/bx /bin/bxx ...</span><br></pre></td></tr></table></figure></li>
<li><code>&#123;start..end&#125;</code>：扩展成一个连续序列 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 顺序扩展</span><br><span class="line">$ echo d&#123;a..c&#125;g</span><br><span class="line">dag dbg dcg ddg</span><br><span class="line"></span><br><span class="line"># 逆序扩展</span><br><span class="line">$ echo d&#123;c..a&#125;g</span><br><span class="line">dcg dbg dag</span><br><span class="line"></span><br><span class="line"># 创建系列目录</span><br><span class="line">$ mkdir fiel_&#123;a,b,c&#125;.txt</span><br><span class="line"></span><br><span class="line"># for循环</span><br><span class="line">for i in &#123;1..4&#125;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 整数前导0</span><br><span class="line">$ echo &#123;01..3&#125;</span><br><span class="line">01 02 03</span><br><span class="line"></span><br><span class="line"># 间隔步长</span><br><span class="line">$ echo &#123;1..10..2&#125;</span><br><span class="line">1 3 5 7 9</span><br><span class="line">$ echo &#123;a..g..2&#125;</span><br><span class="line">a c e g</span><br></pre></td></tr></table></figure></li>
<li><code>$&#123;&#125;</code>：变量扩展 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $&#123;SHELL&#125;</span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">&lt;!-- 所有以S开头的变量名 --&gt;</span><br><span class="line">$ echo  $&#123;!S*&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>$()</code>：子命令扩展 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $(date)</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">$ echo `date`</span><br><span class="line"></span><br><span class="line">&lt;!-- 可嵌套 --&gt;</span><br><span class="line">$ echo $(ls $(pwd))</span><br></pre></td></tr></table></figure></li>
<li><code>$(())</code>：算术扩展，扩展成整数运算结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $((2 + 2))</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li>
<li><code>[[:class:]]</code>：字符类，文件名扩展，class扩展成该类之中任意一个<ol>
<li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>：匹配任意英文字母</li>
<li><code>[[:digit:]]</code>：匹配任意数字0-9</li>
<li><code>[[:lower:]]</code>：匹配任意小写字母a-z</li>
<li><code>[[:upper:]]</code>：匹配任意大写字母A-Z</li>
<li><code>[[:blank:]]</code>：匹配空格和Tab健</li>
<li><code>[[:cntrl:]]</code>：匹配ASCII 码 0-31 的不可打印字符</li>
<li><code>[[:print:]]</code>：匹配ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:xdigit:]]</code>：匹配16进制字符（A-F、a-f、0-9）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打印数字开头的文件名</span><br><span class="line">$ echo [[:digit:]]*</span><br><span class="line"># 打印非数字开头的文件名</span><br><span class="line">$ echo [![:digit:]]*</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>注意项<ol>
<li>通配符是先解释再执行</li>
<li>文件名扩展在不匹配时，会解释成原样输出，再执行</li>
<li>只适用于单层路径，即不能匹配路径分隔符（<code>/</code>）。如果要匹配子目录里的文件，可以使用<code>ls */*.txt</code></li>
</ol>
</li>
<li>量词语法，也是文件名扩展<ol>
<li><code>?()</code>：模式匹配零次或1次</li>
<li><code>*()</code>：模式匹配0次或多次</li>
<li><code>+()</code>：模式匹配一次或多次</li>
<li><code>@()</code>：模式匹配仅一次</li>
<li><code>!()</code>：模式匹配给定模式之外的任何内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 匹配文件有且只有一个.txt或.php后缀</span><br><span class="line">$ ls abc@(.txt|.php)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="引号和转义-bash只有字符串一种数据类型"><a href="#引号和转义-bash只有字符串一种数据类型" class="headerlink" title="引号和转义-bash只有字符串一种数据类型"></a>引号和转义-bash只有字符串一种数据类型</h2><ol>
<li>转义-转义特殊字符 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 转义打印特殊字符比如 $、 &amp;、 *、\</span><br><span class="line">$ echo \$date</span><br><span class="line">$date</span><br><span class="line">$ echo \\</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line"># 转义打印不可打印字符，需要echo -e &#x27;&#x27;</span><br><span class="line">\a: 响铃</span><br><span class="line">\b: 退格</span><br><span class="line">\t: 制表符</span><br><span class="line">\r: 回车</span><br><span class="line">\n: 换行</span><br><span class="line"></span><br><span class="line"># 换行符加上\转换为普通空字符</span><br><span class="line">$ mv \</span><br><span class="line">/root/a/b \</span><br><span class="line">/root/b/b</span><br><span class="line"># 等同于</span><br><span class="line">$ mv /root/a/b /roott/b/b</span><br></pre></td></tr></table></figure></li>
<li>单引号-用于保留字符的字面含义<ol>
<li>单引号使得bash扩展、变量引用、算术运算、子命令失效。</li>
<li>反斜杠转义功能在单引号内失效，故在单引号内使用单引号，不能使用转义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $&#x27;it\&#x27;s&#x27;</span><br><span class="line">it&#x27;s</span><br><span class="line"></span><br><span class="line"># 等同于</span><br><span class="line">$ echo &quot;it&#x27;s&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>双引号-除了<code>&amp;</code>、<code>`</code>、<code>\</code>保留特殊含义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 换行符失效</span><br><span class="line">$ echo &quot;hello </span><br><span class="line">world&quot;</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"></span><br><span class="line"># 文件名空格情况</span><br><span class="line">$ ls &quot;one file.txt&quot;</span><br><span class="line"></span><br><span class="line"># 保留原始命令结果输出</span><br><span class="line">$ echo $(cal)</span><br><span class="line">March 2023 Su Mo Tu We Th Fr Sa 1 2 3 4 5 ... 31</span><br><span class="line">$ echo &quot;$(cal)&quot;</span><br><span class="line">     March 2023     </span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">          1  2  3  4</span><br><span class="line"> 5  6  7  8  9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29 30 31</span><br></pre></td></tr></table></figure></li>
<li>here 文档 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt; token</span><br><span class="line">text</span><br><span class="line">text</span><br><span class="line">token</span><br><span class="line"></span><br><span class="line"># 可发生变量替换，支持反斜杠转义，不支持通配符和引号</span><br><span class="line">$ foo=&#x27;hello world&#x27;</span><br><span class="line">$ cat &lt;&lt; _example_</span><br><span class="line">$foo</span><br><span class="line">&quot;$foo&quot;</span><br><span class="line">&#x27;$foo&#x27;</span><br><span class="line">_example_</span><br><span class="line">hello world</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">&#x27;hello world&#x27;</span><br><span class="line"></span><br><span class="line"># 如果不希望变量替换，则将here文档的开始标记放在单引号之中</span><br><span class="line"></span><br><span class="line"># here 字符串，将字符串通过标准输入，传递给命令</span><br><span class="line">$ md5sum &lt;&lt;&lt; &#x27;ddd&#x27;</span><br><span class="line"># 等同于</span><br><span class="line">$ echo &#x27;ddd&#x27;|md5sum</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="变量-环境变量和自定义变量"><a href="#变量-环境变量和自定义变量" class="headerlink" title="变量-环境变量和自定义变量"></a>变量-环境变量和自定义变量</h2><ol>
<li>显示所有变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure></li>
<li>创建&#x2F;赋值变量-只有字符串，无类型概念 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myvar=&#x27;hello world&#x27;</span><br><span class="line">myvar=hello</span><br><span class="line">myvar2=myvar</span><br></pre></td></tr></table></figure></li>
<li>删除变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset myvar</span><br><span class="line"># 因为不存在的变量一律等于空字符串</span><br><span class="line">myvar=&#x27;&#x27;</span><br></pre></td></tr></table></figure></li>
<li>输出变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export NAME=value</span><br></pre></td></tr></table></figure></li>
<li>特殊变量<ol>
<li><code>$?</code>：为上一个命令退出码，成功为0，失败为其他</li>
<li><code>$$</code>：当前shell的进程ID</li>
<li><code>$@</code>：脚本的参数值</li>
<li><code>$#</code>：脚本的参数数量</li>
</ol>
</li>
<li>变量默认值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 变量存在且不为空，返回其值，否则返回默认值xxx</span><br><span class="line">$&#123;varname:-xxx&#125;</span><br><span class="line"></span><br><span class="line"># 变量存在且不为空，返回其值，否则设置并返回默认值xxx</span><br><span class="line">$&#123;varname:=xxx&#125;</span><br><span class="line"></span><br><span class="line"># 变量存在且不为空，返回其值，否则打印xxx并中断脚本</span><br><span class="line">$&#123;varname:?xxx&#125;</span><br><span class="line"></span><br><span class="line"># 变量存在且不为空，返回xxx，否则返回空</span><br><span class="line">$&#123;varname:+xxx&#125;</span><br><span class="line"></span><br><span class="line"># 上述中varname可以用数字1到9表示脚本参数</span><br><span class="line">filename=$&#123;1:?&quot;filename missing.&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>readonly只读命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readonly foo=1</span><br></pre></td></tr></table></figure></li>
<li>let命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 直接执行算术表达式</span><br><span class="line">let foo=1+2</span><br><span class="line"></span><br><span class="line"># 同时多个</span><br><span class="line">$ let &quot;v1 = 1&quot; &quot;v2 = v1++&quot;</span><br><span class="line">$ echo $v1,$v2</span><br><span class="line">2,1</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ol>
<li>获取字符串长度 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;#varname&#125;</span><br></pre></td></tr></table></figure></li>
<li>子串-${varname:offset:length} <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从头部位置offset（&gt;=0开始），截取长度为length的子串</span><br><span class="line">$&#123;varname:offset:length&#125;</span><br><span class="line"></span><br><span class="line"># 从头部位置offset（&gt;=0开始），截取到尾部的子串</span><br><span class="line">$&#123;varname:offset&#125;</span><br><span class="line"></span><br><span class="line"># 从尾部未知offset（&lt;=-1开始），负数前面必须有个空格</span><br><span class="line">foo=&quot;abcd efg hijkm&quot;</span><br><span class="line">$&#123;varname: -5&#125;</span><br><span class="line">hijkm</span><br><span class="line"># length为正数表示长度</span><br><span class="line">$&#123;varname: -5:2&#125;</span><br><span class="line"># length为负数排除尾部负数个字符</span><br><span class="line">$&#123;varname: -5:-2&#125;</span><br><span class="line">hij</span><br></pre></td></tr></table></figure></li>
<li>搜索和替换-#&#x2F;%<ol>
<li>头部尾部匹配替换 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 头部/尾部匹配删除，pattern可以使用*?[]等通配符</span><br><span class="line"># 删除最短头部匹配，返回剩余</span><br><span class="line">$&#123;variable#pattern&#125;</span><br><span class="line"># 删除最长头部匹配，返回剩余</span><br><span class="line">$&#123;variable##pattern&#125;</span><br><span class="line"># 删除最短尾部匹配，返回剩余</span><br><span class="line">$&#123;variable%pattern&#125;</span><br><span class="line"># 删除最长尾部匹配，返回剩余</span><br><span class="line">$&#123;variable%%pattern&#125;    </span><br><span class="line"></span><br><span class="line"># e.g.删除文件路径，只返回文件名</span><br><span class="line">$ path=/home/cam/book/long.file.name</span><br><span class="line">$&#123;path##*/&#125;</span><br><span class="line">long.file.name</span><br><span class="line"># e.g.删除文件名，只返回文件路径</span><br><span class="line">$&#123;path%/*&#125;</span><br><span class="line">/home/cam/book</span><br><span class="line"></span><br><span class="line"># 头部匹配替换，只有#，最长匹配替换</span><br><span class="line">$&#123;variable/#pattern/string&#125;</span><br><span class="line"># e.g.</span><br><span class="line">$ foo=XXX.jpg</span><br><span class="line">$ echo $&#123;foo/#XXX/xxx&#125;</span><br><span class="line">xxx.jpg</span><br><span class="line"># 尾部匹配替换，只有%，最长匹配替换</span><br><span class="line">$&#123;variable/%pattern/string&#125;</span><br><span class="line"># e.g.</span><br><span class="line">$ foo=XXX.jpg</span><br><span class="line">$ echo $&#123;foo/%jpg/JPG&#125;</span><br><span class="line">XXX.JPG</span><br><span class="line"></span><br><span class="line"># e.g.</span><br><span class="line">$ path=/home/cam/book/long.file.name</span><br><span class="line">$ echo $&#123;path%.*&#125;</span><br><span class="line">/home/cam/book/long.file</span><br><span class="line">$ echo $&#123;path%%.*&#125;</span><br><span class="line">/home/cam/book/long</span><br></pre></td></tr></table></figure></li>
<li>任意位置的模式匹配 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 任意位置最长匹配，仅替换第一个</span><br><span class="line">$&#123;variable/pattern/string&#125;</span><br><span class="line"># 任意位置最长匹配，替换所有</span><br><span class="line">$&#123;variable//pattern/string&#125;</span><br><span class="line"># 省略string表示替换为空字符串即删除</span><br><span class="line"></span><br><span class="line"># e.g.</span><br><span class="line">$ path=/home/cam/foo/foo.name</span><br><span class="line">$ echo $&#123;path/foo/bar&#125;</span><br><span class="line">/home/cam/bar/foo.name</span><br><span class="line">$ echo $&#123;path//foo/bar&#125;</span><br><span class="line">/home/cam/bar/bar.name</span><br><span class="line"></span><br><span class="line"># e.g.将所有:改为换行符</span><br><span class="line"># 使用-e表示将替换后的\n字符，解释为换行</span><br><span class="line">$ echo -e $&#123;PATH//:/&#x27;\n&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># e.g.通配符替换</span><br><span class="line">$ phone=&quot;555-456-1414&quot;</span><br><span class="line">$ echo $&#123;phone/5?4/-&#125;</span><br><span class="line">55-56-1414</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>改变大小写 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 转为大写</span><br><span class="line">$&#123;variable^^&#125;</span><br><span class="line"></span><br><span class="line"># 转为小写</span><br><span class="line">$&#123;variable,,&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><ol>
<li>算术运算-只能整数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自动忽略空格，不返回值，结果不为0则$?为0成功，否则为1失败</span><br><span class="line">((...))</span><br><span class="line"></span><br><span class="line"># 返回值</span><br><span class="line">$ echo $((2 + 2))</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"># 可以嵌套</span><br><span class="line">$ echo $(((2**3) * 2))</span><br><span class="line">16</span><br><span class="line">$ echo $((2**(3 * 2)))</span><br><span class="line">64</span><br><span class="line">$ echo $((2**$((3 * 2))))</span><br><span class="line">64</span><br><span class="line"></span><br><span class="line"># 内部字符串被当做变量名，可不加$</span><br><span class="line">number=2</span><br><span class="line">$ echo $((number + 1))</span><br><span class="line"></span><br><span class="line"># 内部变量不存在或变量值为字符串，默认当做0做运算</span><br></pre></td></tr></table></figure></li>
<li>支持的符号<ul>
<li><code>+</code>：加法</li>
<li><code>-</code>：减法</li>
<li><code>*</code>：乘法</li>
<li><code>/</code>：除法（整除）</li>
<li><code>%</code>：余数</li>
<li><code>**</code>：指数</li>
<li><code>++</code>：自增运算（变量前缀或后缀）</li>
<li><code>--</code>：自减运算（变量前缀或后缀）</li>
</ul>
</li>
<li>数值进制<ul>
<li><code>number</code>：没有任何特殊表示法的数字是十进制数（以10为底）。</li>
<li><code>0number</code>：八进制数。</li>
<li><code>0xnumber</code>：十六进制数。</li>
<li><code>base#number</code>：base进制的数。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $((0xff))</span><br><span class="line">255</span><br><span class="line">$ echo $((2#11111111))</span><br><span class="line">255</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>位运算<ul>
<li><code>&lt;&lt;</code>：位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>：位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>：位的“与”运算，对两个数字的所有位执行一个AND操作。</li>
<li><code>|</code>：位的“或”运算，对两个数字的所有位执行一个OR操作。</li>
<li><code>~</code>：位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。</li>
</ul>
</li>
<li>逻辑运算-逻辑表达式为真，返回1，否则返回0。<ul>
<li><code>&lt;</code>：小于</li>
<li><code>&gt;</code>：大于</li>
<li><code>&lt;=</code>：小于或相等</li>
<li><code>&gt;=</code>：大于或相等</li>
<li><code>==</code>：相等</li>
<li><code>!=</code>：不相等</li>
<li><code>&amp;&amp;</code>：逻辑与</li>
<li><code>||</code>：逻辑或</li>
<li><code>!</code>：逻辑否<br> expr1?expr2:expr3<code>：三元条件运算符。若表达式expr1的计算结果为非零值（算术真）- </code>，则执行表达式expr2，否则执行表达式expr3。</li>
</ul>
</li>
<li>赋值运算 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $((a=1))</span><br><span class="line">1</span><br><span class="line">还有+=、-=、*=、&lt;&lt;=、|=等</span><br></pre></td></tr></table></figure></li>
<li>求值运算-<code>,</code>在<code>$((...))</code>执行前后连个表达式，并返回后一个表达式的值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $((foo = 1 + 2, 3 * 4))</span><br><span class="line">12</span><br><span class="line">$ echo $foo</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li>
<li>expr <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ foo=3</span><br><span class="line">$ expr $foo + 2</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li>
<li>let命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 命令用于将算术运算的结果，赋予一个变量。不能有空格</span><br><span class="line">$ let x=2+3</span><br><span class="line">$ echo $x</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="bash脚本"><a href="#bash脚本" class="headerlink" title="bash脚本"></a>bash脚本</h2><ol start="0">
<li>运行方式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首行的#!/bin/sh是注释不起作用，新开子进程执行</span><br><span class="line">bash x.sh</span><br><span class="line"></span><br><span class="line"># 可执行文件执行脚本，先加权限，再按首行执行解释器执行，新开子进程执行</span><br><span class="line">chmod u+rx</span><br><span class="line">./x.sh`  </span><br><span class="line">    </span><br><span class="line"># 当前进程执行，主要为了脚本内部加载外部库</span><br><span class="line">source ./x.sh == . ./x.sh</span><br></pre></td></tr></table></figure></li>
<li>读取输入&#x2F;文件-read <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 读取输入</span><br><span class="line">echo -n &quot;输入一些文本 &gt; &quot;</span><br><span class="line">read text</span><br><span class="line">echo &quot;你的输入：$text&quot;</span><br><span class="line"></span><br><span class="line"># 超时3秒和提示</span><br><span class="line">read -t 3 -p &quot;Enter one or more values &gt; &quot;</span><br><span class="line"># 没有指定变量返回到环境变量REPLY</span><br><span class="line">echo &quot;REPLY = &#x27;$REPLY&#x27;&quot;</span><br><span class="line"></span><br><span class="line"># 读取文件</span><br><span class="line">filename=&#x27;/etc/hosts&#x27;</span><br><span class="line">while read myline</span><br><span class="line">do</span><br><span class="line">    echo &quot;$myline&quot;</span><br><span class="line">done &lt; $filename</span><br></pre></td></tr></table></figure></li>
<li>条件判断 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本</span><br><span class="line">if test $1 = &#x27;root&#x27;</span><br><span class="line">then</span><br><span class="line">    echo &#x27;hello root&#x27;</span><br><span class="line">elif [ $1 = &#x27;jesonlin&#x27; ]; then</span><br><span class="line">    echo &#x27;hello jesonlin&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;you are not root&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># true/false 特殊命令</span><br><span class="line">if true</span><br><span class="line">then</span><br><span class="line">    echo &#x27;always true&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 条件三种样式</span><br><span class="line">test -e /tmp/file.txt</span><br><span class="line">[ -e /tmp/file.txt ]</span><br><span class="line">[[ -e /tmp/file.txt ]]  # 第三种还支持正则</span><br><span class="line"></span><br><span class="line"># 条件是一个命令，可以是test，也可以是其他命令，命令返回值为0表示判断成立</span><br><span class="line"># 文件是否存在</span><br><span class="line">[ -a file ]</span><br><span class="line">[ -e file ]</span><br><span class="line"># 文件是否是目录</span><br><span class="line">[ -d file ]</span><br><span class="line"></span><br><span class="line"># 字符串判断，变量放在双引号之中</span><br><span class="line">[ $str ]  # 是否不为空</span><br><span class="line">[ -n $str ]  # 长度是否大于0</span><br><span class="line">[ -z $str ]  # 长度是否为0</span><br><span class="line">[ &quot;$str1&quot; == &quot;$str2&quot; ]  # 是否相等</span><br><span class="line">[ &quot;$str1&quot; != &quot;$str2&quot; ]  # 是否不相等</span><br><span class="line">[ &quot;$str1&quot; &#x27;&gt;&#x27; &quot;$str2&quot; ]  # 字符串1是否大于2</span><br><span class="line"></span><br><span class="line"># 整数判断</span><br><span class="line">[ $num1 -eq $num2 ]  # 是否相等</span><br><span class="line">[ $num1 -ne $num2 ]  # 是否不相等</span><br><span class="line">[ $num1 -le $num2 ]  # 是否小于或等于</span><br><span class="line">[ $num1 -lt $num2 ]  # 是否小于</span><br><span class="line">[ $num1 -ge $num2 ]  # 是否大于或等于</span><br><span class="line">[ $num1 -gt $num2 ]  # 是否大于</span><br><span class="line"></span><br><span class="line"># 正则判断是否是整数</span><br><span class="line">if [[ &quot;$0&quot; =~ ^-?[0-9]+=$ ]]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;$0 is an integer&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;s0 is not an integer&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 逻辑运算</span><br><span class="line">&amp;&amp;(与) ||(或) !(非)</span><br><span class="line"></span><br><span class="line"># case结构</span><br><span class="line">case &quot;$OS&quot; in</span><br><span class="line">  FreeBSD) echo &quot;This is FreeBSD&quot; ;;</span><br><span class="line">  Darwin) echo &quot;This is Mac OSX&quot; ;;</span><br><span class="line">  AIX) echo &quot;This is AIX&quot; ;;</span><br><span class="line">  Minix) echo &quot;This is Minix&quot; ;;</span><br><span class="line">  Linux) echo &quot;This is Linux&quot; ;;</span><br><span class="line">  *) echo &quot;Failed to identify this OS&quot; ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
<li>循环 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># while 循环</span><br><span class="line">number=0</span><br><span class="line">while [ &quot;$number&quot; -lt 10 ]; do</span><br><span class="line">  echo &quot;Number = $number&quot;</span><br><span class="line">  number=$((number + 1))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># until 循环-不符合条件（判断条件失败）就不断循环</span><br><span class="line">until condition; do</span><br><span class="line">  commands</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># for...in 循环</span><br><span class="line"># 列表由通配符产生，遍历当前目录下所有png图片</span><br><span class="line">for i in *.png; do</span><br><span class="line">  ls -l $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># for 循环，类似C语言，变量不必加$</span><br><span class="line">for (( i=0; i&lt;5; i=i+1 )); do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># break, continue, 同C语言</span><br></pre></td></tr></table></figure></li>
<li>函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一种</span><br><span class="line">fn() &#123;</span><br><span class="line">  # codes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二种</span><br><span class="line">function fn() &#123;</span><br><span class="line">  # codes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 参数变量</span><br><span class="line"># 函数的参数变量，与脚本参数变量是一致的</span><br><span class="line">$1~$9：函数的第一个到第9个的参数。</span><br><span class="line">$0：函数所在的脚本名。</span><br><span class="line">$#：函数的参数总数。</span><br><span class="line">$@：函数的全部参数，参数之间使用空格分隔。</span><br><span class="line">$*：函数的全部参数，参数之间使用变量$IFS值的第一个字符分隔，</span><br><span class="line"></span><br><span class="line"># Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。</span><br><span class="line"># 函数体内不仅可以声明全局变量，还可以修改全局变量。</span><br><span class="line"># 函数里面可以用local命令声明局部变量，只在函数体内有效，函数体外没有定义。</span><br></pre></td></tr></table></figure></li>
<li>数组 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义数组</span><br><span class="line">ARRAY[INDEX]=value</span><br><span class="line">ARRAY=(value1 value2 value3)</span><br><span class="line">ARRAY=([2]value1 [0]value2 [1]value3)  # 指定每个元素位置</span><br><span class="line">$ mp3s=( *.mp3 )  # 通配符定位数组</span><br><span class="line">$ read -a dice  # 用户命令行输入传入数组</span><br><span class="line"></span><br><span class="line"># 读取数组</span><br><span class="line">$ echo $&#123;array[i]&#125;</span><br><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ echo $&#123;foo[@]&#125;</span><br><span class="line">a b c d e f</span><br><span class="line">for i in &quot;$&#123;names[@]&#125;&quot;; do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 数组长度</span><br><span class="line">$&#123;#array[*]&#125;</span><br><span class="line">$&#123;#array[@]&#125;</span><br><span class="line"></span><br><span class="line"># 数组序号</span><br><span class="line">$ arr=([5]=a [9]=b [23]=c)</span><br><span class="line">$ echo $&#123;!arr[@]&#125;</span><br><span class="line">5 9 23</span><br><span class="line">$ echo $&#123;!arr[*]&#125;</span><br><span class="line">5 9 23</span><br><span class="line"></span><br><span class="line"># 提取数组1号开始的3个成员</span><br><span class="line">$ echo $&#123;arr[@]:1:3&#125;</span><br><span class="line"># 提取数组所有个成员</span><br><span class="line">$ echo $&#123;arr[@]:0&#125;</span><br><span class="line"></span><br><span class="line"># 追加数组成员，不能有空格</span><br><span class="line">$ arr+=(d e f)</span><br><span class="line"></span><br><span class="line"># 删除数组某个成员，只是隐藏，而不是删除</span><br><span class="line">$ unset arr[0]</span><br><span class="line"># 清空数组</span><br><span class="line">$ use tarr</span><br><span class="line"></span><br><span class="line"># 关联数组，类似map</span><br><span class="line">$ declare -A colors  # 必须带-A选项</span><br><span class="line">$ colors[&quot;red&quot;]=&quot;#ff0000&quot;</span><br><span class="line">$ colors[&quot;green&quot;]=&quot;#00ff00&quot;</span><br><span class="line">$ colors[&quot;blue&quot;]=&quot;#0000ff&quot;</span><br><span class="line"># 索引</span><br><span class="line">$ echo $&#123;colors[&quot;blue&quot;]&#125;</span><br></pre></td></tr></table></figure></li>
<li>脚本命令<ol start="0">
<li>bash 执行脚本会创建一个子shell去执行，默认忽略不存在的变量</li>
<li>set 命令-修改子shell环境的运行参数，即定制环境 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line"># 不存在变量就会报错</span><br><span class="line">set -u</span><br><span class="line"></span><br><span class="line"># 执行命令前打印命令本身，行首以+表示</span><br><span class="line">set -x  # 命令打印</span><br><span class="line">set +x  # 取消命令打印</span><br><span class="line"></span><br><span class="line"># 脚本有错误就停止</span><br><span class="line">set -e  # 开启</span><br><span class="line">set +e  # 关闭-e选项</span><br><span class="line">command || &#123; echo &quot;command failed&quot;; exit 1; &#125;</span><br><span class="line"># 管道命令以最后一个命令成功与否代表整个命令的返回值</span><br><span class="line"># 管道命令中只要一个子命令失败就终止脚本</span><br><span class="line">set -eo pipefail</span><br><span class="line"></span><br><span class="line"># 不运行，只检查语法</span><br><span class="line">set -n</span><br><span class="line"></span><br><span class="line"># 总结-写法一</span><br><span class="line">set -euxo pipefail</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>常见错误<ol>
<li>命令失败情况 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果$dir_name不存在，会失败，会切换进用户主目录，执行接下来命令</span><br><span class="line">cd $dir_name</span><br><span class="line">rm *</span><br><span class="line"># 正确写法</span><br><span class="line">[[ -d $dir_name ]] &amp;&amp; cd $dir_name &amp;&amp; rm *</span><br><span class="line"># 不放心删除东西可以先打印看看</span><br><span class="line">[[ -d $dir_name ]] &amp;&amp; cd $dir_name &amp;&amp; echo rm *</span><br></pre></td></tr></table></figure></li>
<li>定位问题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打印行号</span><br><span class="line">echo &quot;This is line $LINENO&quot;</span><br><span class="line"></span><br><span class="line"># 打印函数堆栈上的函数名</span><br><span class="line">function func1()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;func1: FUNCNAME0 is $&#123;FUNCNAME[0]&#125;&quot;</span><br><span class="line">  echo &quot;func1: FUNCNAME1 is $&#123;FUNCNAME[1]&#125;&quot;</span><br><span class="line">  echo &quot;func1: FUNCNAME2 is $&#123;FUNCNAME[2]&#125;&quot;</span><br><span class="line">  func2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 脚本调用堆栈</span><br><span class="line">function func1()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;func1: BASH_SOURCE0 is $&#123;BASH_SOURCE[0]&#125;&quot;</span><br><span class="line">  echo &quot;func1: BASH_SOURCE1 is $&#123;BASH_SOURCE[1]&#125;&quot;</span><br><span class="line">  echo &quot;func1: BASH_SOURCE2 is $&#123;BASH_SOURCE[2]&#125;&quot;</span><br><span class="line">  func2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.runoob.com/linux/linux-shell.html">菜鸟教程</a><br><a href="https://wangdoc.com/bash/">Bash 脚本教程</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历、构建、展开</title>
    <url>/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E3%80%81%E6%9E%84%E5%BB%BA%E3%80%81%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>二叉树的遍历包括深度遍历和广度遍历。深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。</p>
<span id="more"></span>


<h2 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h2><ol start="0">
<li><p>基础</p>
 <img src="/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E3%80%81%E6%9E%84%E5%BB%BA%E3%80%81%E5%B1%95%E5%BC%80/%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="" title="二叉树">

<p> 已知中序遍历和另一种遍历顺序，则可把这棵树构造出来：由先序遍历或后序遍历知根节点，而中序遍历中根节点左端的为左子树，右端的右子树，再由先序遍历或后序遍历知子根节点，递归地构造子树。</p>
</li>
<li><p>前序遍历-[父-左-右]-[E, B, A, D, C, G, F, I, H]</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    res.append(root.val)  <span class="comment"># 将根节点加入结果</span></span><br><span class="line">    dfs(root.left, res)  <span class="comment"># 递归左节点</span></span><br><span class="line">    dfs(root.right, res)  <span class="comment"># 递归右节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur, stack = root, []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 根节点及其左孩子入栈</span></span><br><span class="line">            res.append(cur.val)  <span class="comment"># 加入结果</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        tmp = stack.pop()  <span class="comment"># 每弹出一个元素，就到该元素的右子节点处理</span></span><br><span class="line">        cur = tmp.right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化栈，并将根节点入栈；</span></span><br><span class="line"><span class="comment"># 当栈不为空时：</span></span><br><span class="line">    <span class="comment"># 弹出栈顶元素 node，并将值添加到结果中；</span></span><br><span class="line">    <span class="comment"># 如果 node 的右子树非空，将右子树入栈；</span></span><br><span class="line">    <span class="comment"># 如果 node 的左子树非空，将左子树入栈；</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative_2</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        res.append(cur.val)  <span class="comment"># 根节点加入结果</span></span><br><span class="line">        <span class="keyword">if</span> cur.right:  <span class="comment"># 右子节点入栈</span></span><br><span class="line">            stack.append(cur.right)</span><br><span class="line">        <span class="keyword">if</span> cur.left:   <span class="comment"># 左子节点入栈</span></span><br><span class="line">            stack.append(cur.left)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># dfs(root, res)</span></span><br><span class="line">    iterative(root, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历-[左-父-右]-[A, B, C, D, E, F, G, H, I]</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dfs(root.left, res)  <span class="comment"># 递归左节点</span></span><br><span class="line">    res.append(root.val)  <span class="comment"># 将根节点加入结果</span></span><br><span class="line">    dfs(root.right, res)  <span class="comment"># 递归右节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative</span>(<span class="params">root, res</span>):</span><br><span class="line">    cur, stack = root, []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 左子节点不停入栈，到达最左端的叶子节点</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        tmp = stack.pop  <span class="comment"># 出栈</span></span><br><span class="line">        res.append(tmp.val)  <span class="comment"># 加入结果</span></span><br><span class="line">        cur = tmp.right  <span class="comment"># 处理右子节点</span></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">in_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># dfs(root, res)</span></span><br><span class="line">    iterative(root, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历-[左-右-父]-[A, C, D, B, F, H, I, G, E]</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dfs(root.left, res)  <span class="comment"># 递归左节点</span></span><br><span class="line">    dfs(root.right, res)  <span class="comment"># 递归右节点</span></span><br><span class="line">    res.append(root.val)  <span class="comment"># 将根节点加入结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative</span>(<span class="params">root, res</span>):  <span class="comment"># 与前序遍历相反操作在结果取反</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur, stack = root, []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 根节点及其右孩子入栈</span></span><br><span class="line">            res.append(cur.val)  <span class="comment"># 加入结果</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        tmp = stack.pop()  <span class="comment"># 每弹出一个元素，就到该元素的左子节点处理</span></span><br><span class="line">        cur = tmp.left</span><br><span class="line">    res.reverse()  <span class="comment"># 原地反转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># dfs(root, res)</span></span><br><span class="line">    iterative(root, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="广度遍历"><a href="#广度遍历" class="headerlink" title="广度遍历"></a>广度遍历</h2><ol>
<li>层序遍历<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    que, res = [root], []</span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        n = <span class="built_in">len</span>(que)  <span class="comment"># 每层数量</span></span><br><span class="line">        level = []  <span class="comment"># 每层结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur = que.pop(<span class="number">0</span>)</span><br><span class="line">            level.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                que.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                que.append(cur.right)</span><br><span class="line">        res.append(level)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h2><ol>
<li><p>根据前序遍历和中序遍历构建<br> 对于任意一颗树而言，前序遍历的形式总是</p>
<pre><code> [ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
</code></pre>
<p> 即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p>
<pre><code> [ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]
</code></pre>
</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">preorder, inorder, map_v2i, p_l, p_r, i_l, i_r</span>):</span><br><span class="line">    <span class="keyword">if</span> p_l &gt; p_r:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    p_root = p_l  <span class="comment"># 根节点在前序遍历的索引</span></span><br><span class="line">    i_root = map_v2i[preorder[p_root]]  <span class="comment"># 根节点在在中序遍历的索引</span></span><br><span class="line">    num_l = i_root - i_l</span><br><span class="line">    </span><br><span class="line">    root = TreeNode(preorder[p_root])</span><br><span class="line"></span><br><span class="line">    root.left = dfs(preorder, inorder, map_v2i, p_l + <span class="number">1</span>, p_l + num_l, i_l, i_root - <span class="number">1</span>)</span><br><span class="line">    root.right = dfs(preorder, inorder, map_v2i, p_l + num_l + <span class="number">1</span>, p_r, i_root + <span class="number">1</span>, i_r)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 构建中序遍历hash映射</span></span><br><span class="line">    map_v2i = &#123;v:i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(preorder, inorder, map_v2i, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展开后的单链表应该与二叉树 先序遍历 顺序相同</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">root</span>):</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur.left:  <span class="comment"># 左子结点存在，找到其最右节点（即左子树先序遍历的最后一个元素）</span></span><br><span class="line">            pre = cur.left</span><br><span class="line">            <span class="keyword">while</span> pre.right:</span><br><span class="line">                pre = pre.right</span><br><span class="line">            pre.right = cur.right  <span class="comment"># 当前节点右子树作为左子树最右节点的右子树</span></span><br><span class="line">            cur.right = cur.left  <span class="comment"># 将当前节点左子树改为右子树，因为是【根左右】关系，左子树转到右子树一样顺序，右子树是左子树最右节点的右子树</span></span><br><span class="line">            cur.left = <span class="literal">None</span>  <span class="comment"># 当前节点左子树变为None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>


<h2 id="RERERENCE"><a href="#RERERENCE" class="headerlink" title="RERERENCE"></a>RERERENCE</h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/">图解 二叉树的四种遍历</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建-hexo+next+github</title>
    <url>/%E5%B7%A5%E5%85%B7/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-hexo+next+github/</url>
    <content><![CDATA[<p>记录下搭建个人博客流程，使用 hexo + next + github + 个人域名。</p>
<span id="more"></span>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol start="0">
<li>全局替换如下信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;USERNAME&gt;: github个人账号</span><br><span class="line">&lt;EMAIL&gt;: github个人邮箱</span><br><span class="line">&lt;CVM-IP&gt;: CVM的IP</span><br><span class="line">&lt;个人域名&gt;: 腾讯云上申请的域名，https:开头</span><br><span class="line">&lt;域名&gt;: 腾讯云上申请的域名，不带https:开头</span><br><span class="line">&lt;twitter账号&gt;: twitter个人账号</span><br><span class="line">&lt;facebook账号&gt;: facebook个人账号</span><br></pre></td></tr></table></figure></li>
<li>腾讯云 cvm-centos:7  <ol>
<li>购买初始化 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cloud.tencent.com/product/cvm?from=13950</span><br></pre></td></tr></table></figure></li>
<li>替换腾讯云源 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum update -y</span><br><span class="line">yum upgrade -y</span><br></pre></td></tr></table></figure></li>
<li>磁盘映射-samba<ol>
<li>安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install samba</span><br></pre></td></tr></table></figure></li>
<li>选择共享文件夹 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/service</span><br><span class="line">chmod 777 /data/service</span><br></pre></td></tr></table></figure></li>
<li>编辑samba配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br><span class="line">&lt;!-- global下新增一行，放开1315端口 --&gt;</span><br><span class="line">smb ports = 1315</span><br><span class="line"></span><br><span class="line">&lt;!-- 文件末尾添加如下共享文件夹 --&gt;</span><br><span class="line">[service]</span><br><span class="line">comment = service</span><br><span class="line">path = /data/service</span><br><span class="line">public = yes</span><br><span class="line">browseable = yes</span><br><span class="line">writable = yes</span><br><span class="line">create mask = 0777</span><br><span class="line">directory mask = 0777</span><br></pre></td></tr></table></figure></li>
<li>创建samba用户名和密码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smbpasswd -a root</span><br></pre></td></tr></table></figure></li>
<li>设置为开启启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig --level 3 smb on</span><br></pre></td></tr></table></figure></li>
<li>重启sambda <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service smb start</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>cvm -&gt; 安全组 -&gt; 自定义模板 -&gt; 按模板格式放开端口 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.0.0.0/0   TCP:1315</span><br><span class="line">0.0.0.0/0   TCP:4000</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>腾讯云域名<ol>
<li>注册 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://dnspod.cloud.tencent.com/</span><br></pre></td></tr></table></figure></li>
<li>添加A记录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 找到github账号所在ip --&gt;</span><br><span class="line">ping &lt;USERNAME&gt;.github.io</span><br><span class="line">@ A 默认 [IP]</span><br></pre></td></tr></table></figure></li>
<li>添加CNAME <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www CNAME 默认 &lt;USERNAME&gt;.github.io.</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>github<ol>
<li>注册和登录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/</span><br></pre></td></tr></table></figure></li>
<li>新建仓库blog <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 修改默认分支名为master --&gt;</span><br><span class="line">https://github.com/settings/repositories</span><br><span class="line">&lt;!-- 新建仓库 --&gt;</span><br><span class="line">https://github.com/&lt;USERNAME&gt;?tab=repositories</span><br><span class="line">&lt;!-- 仓库地址-SSH --&gt;</span><br><span class="line">git@github.com:&lt;USERNAME&gt;/blog.git</span><br><span class="line">&lt;!-- 默认创建master分支 --&gt;</span><br></pre></td></tr></table></figure></li>
<li>创建分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建source分支 --&gt;</span><br><span class="line">https://github.com/&lt;USERNAME&gt;/blog/branches</span><br><span class="line">&lt;!-- 修改默认分支为source分支 --&gt;</span><br><span class="line">Default branch -&gt; 最右边左右箭头 -&gt; master下拉选source -&gt; Update</span><br></pre></td></tr></table></figure></li>
<li>配置git <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;&lt;USERNAME&gt;&quot;</span><br><span class="line">git config --global user.email &quot;&lt;EMAIL&gt;&quot;</span><br></pre></td></tr></table></figure></li>
<li>新建ssh keys <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- cvm输入如下联系回车 --&gt;</span><br><span class="line">ssh-keygen -t rsa -C &quot;blog_&lt;CVM-IP&gt;&quot;</span><br><span class="line">&lt;!-- 查看公开密钥的方法 --&gt;</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">&lt;!-- 将公开秘钥填入github --&gt;</span><br><span class="line">https://github.com/settings/ssh/new</span><br></pre></td></tr></table></figure></li>
<li>配置host链接git更快 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 从该网址找到IP --&gt;</span><br><span class="line">https://www.ipaddress.com/site/github.com</span><br><span class="line">&lt;!-- 或者如下 --&gt;</span><br><span class="line">https://www.whatsmydns.net/#A/github.com</span><br><span class="line">&lt;!-- 填入到hosts --&gt;</span><br><span class="line">vim /etc/hosts</span><br><span class="line">[IP] https://github.com</span><br><span class="line">[IP] github.com</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h2><ol>
<li>安装Node.js <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y nodejs</span><br><span class="line">&lt;!-- 查询版本号 --&gt;</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li>
<li>安装git <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure></li>
<li>安装Hexo <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/service</span><br><span class="line">cd /data/service</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li>
<li>启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server</span><br></pre></td></tr></table></figure></li>
<li>本地调试-浏览器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://&lt;CVM-IP&gt;:4000/</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h2><ol>
<li>编辑_config.yml <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/service/blog</span><br><span class="line">vim _config.yml</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:&lt;USERNAME&gt;/blog.git</span><br><span class="line">  branch: master  # 这个根据github实际填master还是main，建议将github默认分支改为master</span><br><span class="line">url: https://&lt;USERNAME&gt;.github.io/blog/</span><br></pre></td></tr></table></figure></li>
<li>部署推送git的master分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/service/blog</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
<li>github配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 进入blog仓库的pages页面 --&gt;</span><br><span class="line">https://github.com/&lt;USERNAME&gt;/blog/settings/pages</span><br><span class="line">Branch -&gt; 选择master -&gt; Save</span><br><span class="line">&lt;!-- 等待几分钟，重新刷新页面，会出现如下 --&gt;</span><br><span class="line">Your site is live at https://&lt;USERNAME&gt;.github.io/blog/</span><br><span class="line">&lt;!-- 通过该网址可以访问hexo首页 --&gt;</span><br></pre></td></tr></table></figure></li>
<li>配置自定义域名<ol>
<li>编辑_config.yml <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: &lt;个人域名&gt;</span><br></pre></td></tr></table></figure></li>
<li>github配置腾讯云域名 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/&lt;USERNAME&gt;/blog/settings/pages</span><br><span class="line">Pages -&gt; Custom domain -&gt; &lt;域名&gt; -&gt; Save</span><br><span class="line">&lt;!-- 会在master分支下生成CNAME文件 --&gt;</span><br></pre></td></tr></table></figure></li>
<li>重新部署推送 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
<li>问题<ol>
<li>发现master分支下的CNAME文件不见了</li>
<li>同时Pages -&gt; Custom domain下自定义的域名也被重置为一开始默认的</li>
</ol>
</li>
<li>解决方法<ol>
<li>将生成的CNAME文件放在&#x2F;data&#x2F;service&#x2F;blog&#x2F;source下</li>
<li>再次部署推送发现本地.deploy_git目录下就有CNAME文件</li>
<li>同时master分支上的内容就是该.deploy_git目录下内容</li>
</ol>
</li>
<li>最终可以通过个人域名访问hexo博客</li>
</ol>
</li>
<li>源代码保存在默认的source分支<ol>
<li>目的是可以再任意地方重新部署写文章</li>
<li>关联远程的默认source分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:&lt;USERNAME&gt;/blog.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;初始化blog&quot;</span><br><span class="line">git branch -M source</span><br><span class="line">git pull</span><br><span class="line">git branch --set-upstream-to=origin/source  source</span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>迁移到其他CVM <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/service/</span><br><span class="line">cd /data/service</span><br><span class="line">yum install -y nodejs</span><br><span class="line">yum install -y git</span><br><span class="line">git clone git@github.com:&lt;USERNAME&gt;/blog.git</span><br><span class="line">cd blog</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init .</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><ol>
<li>下载next主题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/service/blog</span><br><span class="line">&lt;!-- v8.13.2 --&gt;</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li>
<li>配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 站点配置文件 --&gt;</span><br><span class="line">/data/service/blog/_config.yml</span><br><span class="line">&lt;!-- 主题配置文件 --&gt;</span><br><span class="line">/data/service/blog/themes/next/_config.yml</span><br></pre></td></tr></table></figure></li>
<li>修改站点配置文件_config.yml <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: jesonlin</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description: &#x27;choice is better than effort&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: jesonlin</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br><span class="line"></span><br><span class="line">permalink: :category/:urlname/  # 永久链接</span><br><span class="line">permalink_defaults: </span><br><span class="line">  urlname: undefined  # 永久链接中变量默认值</span><br><span class="line"></span><br><span class="line">default_layout: draft  # 使用hexo new [layout] &lt;title&gt; 默认布局改为草稿</span><br><span class="line"></span><br><span class="line">post_asset_folder: true # 将每篇博客对应生成一个文件夹目录（方便插入图片等附件）</span><br><span class="line"># 插入图片相对路径{% asset_img "xx.jpg" "" %}需要安装包</span><br><span class="line"># npm install hexo-image-link --save</span><br><span class="line"></span><br><span class="line">default_category: uncategory</span><br><span class="line"></span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></li>
<li>隐藏网页底部的由 Hexo &amp; NexT.Gemini 强力驱动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /data/service/blog/themes/next/layout/_partials/footer.swig</span><br><span class="line">&lt;!-- 搜索powered所在几行，前后分别加上 --&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    包含powered的行</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li>
<li>修改主题配置文件<ol>
<li>主题-Scheme Settings <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: source/_data/styles.styl  # 在对应位置创建文件</span><br><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini  # 使用这个</span><br><span class="line"></span><br><span class="line"># Dark Mode</span><br><span class="line">darkmode: true  # 主题暗黑模式</span><br></pre></td></tr></table></figure></li>
<li>暗黑模式切换开关 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 依赖 --&gt;</span><br><span class="line">npm install hexo-next-darkmode --save</span><br><span class="line"># Dark Mode</span><br><span class="line">darkmode: false  # 主题暗黑模式</span><br><span class="line"># Darkmode JS</span><br><span class="line"># For more information: https://github.com/rqh656418510/hexo-next-darkmode, https://github.com/sandoche/Darkmode.js</span><br><span class="line">darkmode_js:  # 黑白模式开关，npm install hexo-next-darkmode --save</span><br><span class="line">  enable: true</span><br><span class="line">  bottom: &#x27;64px&#x27; # default: &#x27;32px&#x27;</span><br><span class="line">  right: &#x27;unset&#x27; # default: &#x27;32px&#x27;</span><br><span class="line">  left: &#x27;32px&#x27; # default: &#x27;unset&#x27;</span><br><span class="line">  time: &#x27;0.5s&#x27; # default: &#x27;0.3s&#x27;</span><br><span class="line">  mixColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  backgroundColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  buttonColorDark: &#x27;#100f2c&#x27; # default: &#x27;#100f2c&#x27;</span><br><span class="line">  buttonColorLight: &#x27;#fff&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  isActivated: false # default false</span><br><span class="line">  saveInCookies: true # default: true</span><br><span class="line">  label: &#x27;🌓&#x27; # default: &#x27;&#x27;</span><br><span class="line">  autoMatchOsTheme: true # default: true</span><br><span class="line">  libUrl: # Set custom library cdn url for Darkmode.js</span><br></pre></td></tr></table></figure></li>
<li>站点信息-定制logo-custom_logo <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_logo: /images/qq-image.jpeg  # 定制logo</span><br><span class="line">creative_commons:</span><br><span class="line">  post: true  # 文末版权声明</span><br></pre></td></tr></table></figure></li>
<li>站点信息-文末版权声明-creative_commons <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post: true</span><br><span class="line">&lt;!-- 额外增加一行本文结束*感谢您的阅读 --&gt;</span><br><span class="line">vim themes/next/layout/_macro/passage-end-tag.njk</span><br><span class="line">&lt;!-- 粘贴如下内容 --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:24px;&quot;&gt;-------------&gt;本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- 在post.njk加上刚才新建的文件 --&gt;</span><br><span class="line">vim themes/next/layout/_macro/post.njk </span><br><span class="line">&lt;!-- 在END POST BODY后加上如下 --&gt;</span><br><span class="line">&#123;% if not is_index and theme.passage_end_tag.enabled %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &#x27;passage-end-tag.njk&#x27; %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;!-- 打开主题配置文件 --&gt;</span><br><span class="line">vim themes/next/_config.yml</span><br><span class="line">&lt;!-- 在末尾加上 --&gt;</span><br><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure></li>
<li>菜单-菜单项-menu <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: / || fa fa-home</span><br><span class="line">about: /about/ || fa fa-user</span><br><span class="line">tags: /tags/ || fa fa-tags</span><br><span class="line">categories: /categories/ || fa fa-th</span><br><span class="line">archives: /archives/ || fa fa-archive</span><br><span class="line">resources: /resources/ || fa fa-download</span><br><span class="line">#schedule: /schedule/ || fa fa-calendar</span><br><span class="line">#sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">#commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure></li>
<li>侧边栏-sidebar <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 头像-avatar --&gt;</span><br><span class="line">url: /images/handsome.jpg  # 侧边栏头像</span><br><span class="line">rounded: true  # 侧边栏头像圆形包围</span><br><span class="line">rotated: true  # 侧边栏头像旋转动画</span><br><span class="line">&lt;!-- 社交链接-social --&gt;</span><br><span class="line">GitHub: https://github.com/&lt;USERNAME&gt; || fab fa-github</span><br><span class="line">E-Mail: mailto:&lt;EMAIL&gt; || fa fa-envelope</span><br><span class="line">Twitter: https://twitter.com/&lt;twitter账号&gt; || fab fa-twitter</span><br><span class="line">FB Page: https://www.facebook.com/&lt;facebook账号&gt; || fab fa-facebook</span><br></pre></td></tr></table></figure></li>
<li>页脚和爱心动画-footer <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">since: 2022  # 建站时间</span><br><span class="line">animated: true  # 爱心动画</span><br><span class="line">powered: false  # 关掉powered</span><br></pre></td></tr></table></figure></li>
<li>博客设置-字数统计 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 依赖包 --&gt;</span><br><span class="line">cd /data/service/blog</span><br><span class="line">npm install hexo-symbols-count-time</span><br><span class="line">&lt;!-- 主题配置文件 --&gt;</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true  # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  item_text_post: true  # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_total: true  # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  awl: 4  # 平均字长</span><br><span class="line">  wpm: 275  # 每分钟阅读字数</span><br><span class="line">  suffix: &quot;mins.&quot;  # 单位后缀</span><br><span class="line">&lt;!-- 需要重新部署 --&gt;</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li>
<li>博客设置-打赏奖励 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true  # 打赏开关</span><br><span class="line">  animation: false</span><br><span class="line">  # 没有comment选项，修改其他 # 提示修改</span><br><span class="line">  # vim themes/next/languages/en.yml</span><br><span class="line">  # Buy me a coffee -&gt; 原创技术分享，您的支持将鼓励我继续创作</span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png  # 微信收款码</span><br><span class="line">  alipay: /images/alipay.png  # 支付宝收款码</span><br></pre></td></tr></table></figure></li>
<li>进度条-pace<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></li>
<li>评论-comments<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  active: gitalk  # 评论</span><br><span class="line">gitalk:  #注册应用: https://github.com/settings/applications/new &quot;Homepage URL&quot;和&quot;Authorization callback URL&quot;填个人域名</span><br><span class="line">  enable: true  # 开启评论</span><br><span class="line">  github_id: &lt;USERNAME&gt;  # github账号</span><br><span class="line">  repo: blog  # github上博客仓库</span><br><span class="line">  client_id: [CLIENT_ID]</span><br><span class="line">  client_secret: [CLIENT_SECRET]</span><br><span class="line">  admin_user: &lt;USERNAME&gt;</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  language: zh-CN</span><br><span class="line">&lt;!-- 由于gitalk被墙没法获取token，需要代理 --&gt;</span><br><span class="line">proxy: https://strong-caramel-969805.netlify.app/github_access_token  # 替换网上找的代理</span><br></pre></td></tr></table></figure></li>
<li>人数浏览数统计-busuanzi_count<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true  # 启用不蒜子</span><br><span class="line">  total_visitors: true  # 网站总访客数</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true  # 网站总浏览数</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true # 文章浏览数</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure></li>
<li>本地搜索-local_search<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">   enable: true  # 激活</span><br><span class="line"> &lt;!-- 依赖包 --&gt;</span><br><span class="line"> cd /data/service/blog</span><br><span class="line"> npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure></li>
<li>github贡献日历-只在关于页面出现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim themes/next/layout/_layout.njk</span><br><span class="line">&#123;%- if page.type == &#x27;about&#x27; %&#125;</span><br><span class="line">&lt;div class=&quot;post-block animated fadeIn&quot;&gt;</span><br><span class="line">    &lt;h5 class=&quot;post-title&quot; itemprop=&quot;name headline&quot;&gt;</span><br><span class="line">        &lt;a href=&quot;https://github.com/&lt;USERNAME&gt;&quot; class=&quot;post-title-link&quot; itemprop=&quot;url&quot;&gt;Github Contribution Calendar&lt;/a&gt;</span><br><span class="line">    &lt;/h5&gt;</span><br><span class="line">    &lt;div class=&quot;post-body animated fadeInDown&quot; itemprop=&quot;articleBody&quot;&gt;</span><br><span class="line">        &lt;img style=&quot;width: 100%; margin-top: 30px;&quot; src=&quot;https://ghchart.rshah.org/00ff00/&lt;USERNAME&gt;&quot; alt=&quot;jesonlin&#x27;s Blue Github Chart&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li>代码块拷贝<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  copy_button:  # 代码块拷贝</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li>布局文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布局名   存放位置</span><br><span class="line">post    source/_posts   # 文章</span><br><span class="line">page    source          # 页面</span><br><span class="line">draft   source/_drafts  # 草稿</span><br></pre></td></tr></table></figure></li>
<li>草稿布局文件设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim scaffolds/draft.md</span><br><span class="line">&lt;!-- 填入如下内容 --&gt;</span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">urlname: &#123;&#123;title&#125;&#125;</span><br><span class="line">top: false</span><br><span class="line">categories:</span><br><span class="line">- uncategory</span><br><span class="line">tags:</span><br><span class="line">- untag</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">author: &#123;&#123; author &#125;&#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这里是摘要</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line"># 内容</span><br><span class="line"></span><br><span class="line">这里是内容</span><br></pre></td></tr></table></figure></li>
<li>文章布局文件设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim scaffolds/post.md</span><br><span class="line">&lt;!-- 填入如下内容 --&gt;</span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">urlname: &#123;&#123;title&#125;&#125;</span><br><span class="line">top:</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">author: &#123;&#123; author &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li>菜单栏页面创建 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建关于页面 --&gt;</span><br><span class="line">hexo new page about</span><br><span class="line">&lt;!-- 创建分类页面 --&gt;</span><br><span class="line">hexo new page categories</span><br><span class="line">&lt;!-- 创建标签页面 --&gt;</span><br><span class="line">hexo new page tags</span><br><span class="line">&lt;!-- 创建资源页面 --&gt;</span><br><span class="line">hexo new page resources</span><br></pre></td></tr></table></figure></li>
<li>创建草稿 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexp new [layout] &lt;title&gt;</span><br><span class="line">hexo new draft xxx</span><br><span class="line">&lt;!-- 草稿默认不显示，通过参数--draft强制显示 --&gt;</span><br><span class="line">hexo clean &amp;&amp; hexo s --draft</span><br><span class="line">&lt;!-- 发布草稿到文章 --&gt;</span><br><span class="line">hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure></li>
<li>创建文章 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post xxx</span><br></pre></td></tr></table></figure></li>
<li>本地调试 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li>
<li>推送到github部署 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://hexo.io/zh-cn/">官方文档</a><br><a href="https://blog.csdn.net/as480133937/article/details/100138838">hexo-next主题配置</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>c++</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cplusplus/</url>
    <content><![CDATA[<p>C++是C语言的继承，是静态类型的、编译式的、通用的、大小写敏感的、不规则的面向对象的高级程序设计语言。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>C++ 完全支持面向对象的程序设计</p>
<ol>
<li>封装<br> 封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。</li>
<li>继承<br> 继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。</li>
<li>多态<br> 多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。</li>
<li>抽象<br> 抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。</li>
</ol>
</li>
<li><p>标准的 C++ 由三个重要部分组成</p>
<ol>
<li>核心语言，提供了所有构件块，包括变量、数据类型和常量等等。</li>
<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>
<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>
</ol>
</li>
<li><p>重要版本迭代<br> c++98 -&gt; c++03 -&gt; c++11 -&gt; c++14 -&gt; c++17</p>
</li>
</ol>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos7 自带 gcc 是4.8.5 不支持c++14、17</span></span><br><span class="line">yum install gcc gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级 gcc 为5.4.0</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src</span><br><span class="line">wget https://ftp.gnu.org/gnu/gcc/gcc-5.4.0/gcc-5.4.0.tar.bz2</span><br><span class="line">yum install biz2</span><br><span class="line">tar -jxvf gcc-5.4.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> gcc-5.4.0</span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure -prefix=/usr/local --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">gcc -v</span><br><span class="line"><span class="built_in">cd</span> /usr/bin/</span><br><span class="line"><span class="built_in">mv</span> gcc gcc_back</span><br><span class="line"><span class="built_in">mv</span> g++ g++_back</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/gcc gcc</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/g++ g++</span><br><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line">find / -name libstdc++.so.6*</span><br><span class="line"><span class="comment"># 结果中找最高版本，查看GLIBCXX是否满足要求</span></span><br><span class="line">strings /usr/local/lib64/libstdc++.so.6.0.21 | grep GLIBCXX</span><br><span class="line"><span class="built_in">cp</span> /usr/local/lib64/libstdc++.so.6.0.21 /usr/lib64/libstdc++.so.6.0.21</span><br><span class="line"><span class="built_in">rm</span> -f /usr/lib64/lib</span><br><span class="line"><span class="built_in">ln</span> -s /usr/lib64/libstdc++.so.6.0.21 /usr/lib64/libstdc++.so.6</span><br></pre></td></tr></table></figure>

<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  // 头文件</span><br><span class="line">using namespace std;  // 命名空间</span><br><span class="line"></span><br><span class="line">// main()是程序入口</span><br><span class="line">int main() &#123;</span><br><span class="line">    /* 程序入口 </span><br><span class="line">    * 跨行</span><br><span class="line">    */</span><br><span class="line">    cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认生成可执行文件 a.out</span></span><br><span class="line">g++ helloworld.cpp</span><br><span class="line">./a.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的文件名</span></span><br><span class="line">g++ helloworld.cpp -o helloworld</span><br><span class="line">./helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译器版本</span></span><br><span class="line"><span class="comment"># -g 生成调试信息。GNU 调试器可利用该信息。</span></span><br><span class="line"><span class="comment"># -Wall 生成所有警告信息。</span></span><br><span class="line">g++ -g -Wall -std=c++11 helloworld.cpp -o helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本</span></span><br><span class="line">gcc helloworld.cpp -lstdc++ -o helloworld</span><br></pre></td></tr></table></figure>


<h2 id="核心语言-amp-基本语法"><a href="#核心语言-amp-基本语法" class="headerlink" title="核心语言 &amp; 基本语法"></a>核心语言 &amp; 基本语法</h2><ol>
<li><p>常量</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 枚举名week，枚举变量wk，标识符monday，</span><br><span class="line">// 变量只能是枚举标识符</span><br><span class="line">enum week</span><br><span class="line">&#123;</span><br><span class="line">    MONDAY,     // 首个值为0</span><br><span class="line">    TUESDAY=5,  // 标识符对应值</span><br><span class="line">    WEDNESDAY,   // 默认为上一个值+1</span><br><span class="line"></span><br><span class="line">&#125; wk;  // 直接声明枚举变量</span><br><span class="line">// 也可以后声明</span><br><span class="line">// week wk2;</span><br><span class="line">// 声明加定义</span><br><span class="line">// week wk2=MONDAY;</span><br></pre></td></tr></table></figure></li>
<li><p>类型转换</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态类型转换</span></span><br><span class="line"><span class="comment">// 静态将float类型转换为int类型，不进行运行时类型检查</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态转换-基类指针或引用转换为派生类，运行时检查</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base * ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* prt_derived = <span class="built_in">dynamic_case</span>&lt;Derived*&gt;(ptr_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量转换</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_case</span>&lt;<span class="type">int</span>&amp;&gt;(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新解释转换</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="keyword">reinterpret_cast</span>&lt;&gt;<span class="type">float</span>&amp;(i)</span><br></pre></td></tr></table></figure></li>
<li><p>变量</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量种类</span></span><br><span class="line"><span class="type">bool</span> <span class="type">char</span> <span class="type">int</span> <span class="type">float</span> doble <span class="type">void</span> <span class="type">wchar_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量声明-在任何地方声明一个变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;</span><br><span class="line"><span class="comment">// 变量定义</span></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="comment">// 变量初始化</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b= <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值：指向内存位置的表达式，可以出现在赋值号的左边或右边</span></span><br><span class="line"><span class="comment">// 右值：存储在内存中某些地址的数值，无法赋值，只能出现在赋值号的右边</span></span><br><span class="line"><span class="comment">// 变量是左值，数值型的字面值是右值</span></span><br></pre></td></tr></table></figure></li>
<li><p>常量</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数常量</span></span><br><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点常量</span></span><br><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的 </span></span><br><span class="line"><span class="number">314159E-5</span>L    <span class="comment">// 合法的 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔常量</span></span><br><span class="line"><span class="literal">true</span> / <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符常量</span></span><br><span class="line"><span class="string">L&#x27;x&#x27;</span>  <span class="comment">// 宽字符常量，存储在wchar_t类型</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>  <span class="comment">// 窄字符常量，存储在char类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串常量</span></span><br><span class="line">string aa = <span class="string">&quot;hello, \</span></span><br><span class="line"><span class="string">world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰符</span></span><br><span class="line"><span class="comment">// 数据类型修饰符</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> num1 = <span class="number">-10</span>; <span class="comment">// 定义有符号整型变量 num1，初始值为 -10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">20</span>; <span class="comment">// 定义无符号整型变量 num2，初始值为 20</span></span><br><span class="line"><span class="type">short</span> <span class="type">int</span> num1 = <span class="number">10</span>; <span class="comment">// 定义短整型变量 num1，初始值为 10</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num2 = <span class="number">100000</span>; <span class="comment">// 定义长整型变量 num2，初始值为 100000</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> num1 = <span class="number">10000000000</span>; <span class="comment">// 定义长长整型变量 num1，初始值为 10000000000</span></span><br><span class="line"><span class="type">float</span> num1 = <span class="number">3.14f</span>; <span class="comment">// 定义单精度浮点数变量 num1，初始值为 3.14</span></span><br><span class="line"><span class="type">double</span> num2 = <span class="number">2.71828</span>; <span class="comment">// 定义双精度浮点数变量 num2，初始值为 2.71828</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 定义布尔类型变量 flag，初始值为 true</span></span><br><span class="line"><span class="type">char</span> ch1 = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 定义字符类型变量 ch1，初始值为 &#x27;a&#x27;</span></span><br><span class="line"><span class="type">wchar_t</span> ch2 = <span class="string">L&#x27;你&#x27;</span>; <span class="comment">// 定义宽字符类型变量 ch2，初始值为 &#x27;你&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储类</span></span><br><span class="line"><span class="comment">// static </span></span><br><span class="line"><span class="comment">// 指示编译器在程序的生命周期内保持局部变量的存在</span></span><br><span class="line"><span class="comment">// 当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</span></span><br><span class="line"><span class="comment">// static只是表示修饰的值是静态的，更多是限制作用域，而值本身可修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extern 用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 &#x27;extern&#x27; 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</span></span><br></pre></td></tr></table></figure></li>
<li><p>运算符-优先级从高到底</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">运算符</th>
<th align="center">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">后缀</td>
<td align="center">() [] -&gt; . ++ - -</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">一元</td>
<td align="center">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">乘除</td>
<td align="center">* &#x2F; %</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">加减</td>
<td align="center">+ -</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">移位</td>
<td align="center">&lt;&lt; &gt;&gt;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">关系</td>
<td align="center">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">相等</td>
<td align="center">&#x3D;&#x3D; !&#x3D;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">位与</td>
<td align="center">AND  &amp;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">位异或</td>
<td align="center">XOR     ^</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">位或</td>
<td align="center">OR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">逻辑与</td>
<td align="center">AND     &amp;&amp;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">逻辑或</td>
<td align="center">OR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">条件</td>
<td align="center">?:</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">赋值</td>
<td align="center">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D;</td>
<td align="center">&#x3D;</td>
</tr>
<tr>
<td align="center">逗号</td>
<td align="center">,</td>
<td align="center">从左到右</td>
</tr>
</tbody></table>
</li>
<li><p>函数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名表达式</span></span><br><span class="line">[capture](参数) -&gt; return_type &#123;函数体&#125;</span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) &#123;<span class="keyword">return</span> x &lt; y;&#125;</span><br><span class="line">[]&#123;++global_x;&#125;</span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;<span class="type">int</span> z = x + y; <span class="keyword">return</span> z;&#125;</span><br><span class="line"><span class="comment">// capture可以为如下</span></span><br><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</span></span><br><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abssort</span><span class="params">(<span class="type">float</span>* x, <span class="type">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(x, x + n,</span><br><span class="line">        <span class="comment">// Lambda expression begins</span></span><br><span class="line">        [](<span class="type">float</span> a, <span class="type">float</span> b) &#123;</span><br><span class="line">            <span class="built_in">return</span> (std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b));</span><br><span class="line">        &#125; <span class="comment">// end of lambda expression</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> x[] = &#123;<span class="number">1.1</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line"><span class="built_in">abssort</span>(x, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>字符串</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c风格字符串实际上是使用 null 字符 \0 终止的一维字符数组。</span></span><br><span class="line"><span class="comment">// 一个以 null 结尾的字符串，包含了组成字符串的字符。</span></span><br><span class="line"><span class="comment">// 由于在数组的末尾存储了空字符，所以字符数组的大小比字符串本身字符数多一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include&lt;cstring&gt; 大量的函数用来操作以 null 结尾的字符串:</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1, s2);  <span class="comment">// 复制字符串 s2 到字符串 s1。</span></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);  <span class="comment">// 连接字符串 s2 到字符串 s1 的末尾。</span></span><br><span class="line"><span class="built_in">strlen</span>(s1);  <span class="comment">// 返回字符串 s1 的长度。</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2);  <span class="comment">// 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</span></span><br><span class="line"><span class="built_in">strchr</span>(s1, ch);  <span class="comment">// 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置</span></span><br><span class="line"><span class="built_in">strstr</span>(s1, s2);  <span class="comment">// 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;string&gt;</span></span><br><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str += <span class="string">&quot;, world&quot;</span>;</span><br><span class="line">str.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure></li>
<li><p>时间</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 10位时间戳</span><br><span class="line">time_t now = time(0);</span><br><span class="line">cout &lt;&lt; &quot;1970 到目前经过秒数:&quot; &lt;&lt; now &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">// tm结构</span><br><span class="line">tm *ltm = localtime(&amp;now);</span><br><span class="line"> </span><br><span class="line">// 输出 tm 结构的各个组成部分</span><br><span class="line">cout &lt;&lt; &quot;年: &quot;&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;月: &quot;&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;日: &quot;&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;时间: &quot;&lt;&lt; ltm-&gt;tm_hour &lt;&lt; &quot;:&quot;;</span><br><span class="line">cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; &quot;:&quot;;</span><br><span class="line">cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li><p>结构体</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; book;</span><br><span class="line"><span class="built_in">strcpy</span>(book.title, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">cout &lt;&lt; book.title &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="类-amp-对象"><a href="#类-amp-对象" class="headerlink" title="类 &amp; 对象"></a>类 &amp; 对象</h2><ol>
<li>类成员函数<br> 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</li>
<li>类访问修饰符<br> 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private，类继承也有该修饰符，默认也是private。<ol>
<li>public<br> 公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值</li>
<li>private<br> 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。派生类也不能。默认情况下，类的所有成员都是私有的。</li>
<li>protect<br> protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。</li>
<li>在继承中的特点（分别以继承修饰符和基类各个修复符中的最严为准）<ol>
<li>public:<br> 基类：public&#x2F;protect&#x2F;private<br> 子类：public&#x2F;protect&#x2F;private</li>
<li>protect:<br> 基类：public&#x2F;protect&#x2F;private<br> 子类：protect&#x2F;protect&#x2F;protect            </li>
<li>private:<br> 基类：public&#x2F;protect&#x2F;private<br> 子类：private&#x2F;private&#x2F;private</li>
</ol>
</li>
</ol>
</li>
<li>构造函数 &amp; 析构函数<br> 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</li>
<li>拷贝构造函数<br> 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。<ol>
<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>
<li>复制对象把它作为参数传递给函数。</li>
<li>复制对象，并从函数返回这个对象。</li>
</ol>
</li>
<li>友元函数<br> 友元函数可以访问类的 private 和 protected 成员。<ol>
<li>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元类整个类及其所有成员都是友元。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> length;</span><br><span class="line">        <span class="comment">// 友元函数</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>;</span><br><span class="line">        <span class="comment">// 友元类</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BigBox</span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">( <span class="type">double</span> wid )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>内联函数<ol>
<li>通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</li>
<li>一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。</li>
<li>如果已定义的函数多于一行，编译器会忽略 inline 限定符。</li>
</ol>
</li>
<li>C++ 中的 this 指针<ol>
<li>每个对象都有一个特殊的指针 this，它指向对象本身。</li>
<li>this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</li>
<li>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</li>
</ol>
</li>
<li>C++ 中指向类的指针<br> 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</li>
<li>C++ 类的静态成员<ol>
<li>类的数据成员和函数成员都可以被声明为静态的。</li>
<li>我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</li>
<li>静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。</li>
<li>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。</li>
<li>静态成员函数与普通成员函数的区别<ol>
<li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>
<li>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="类特点"><a href="#类特点" class="headerlink" title="类特点"></a>类特点</h2><ol>
<li>封装-把数据和操作数据的函数捆绑在一起的机制<br> 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。</li>
<li>抽象-仅向用户暴露接口而把具体的实现细节隐藏起来的机制。<br> 好处  <ol>
<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>
<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>
</ol>
</li>
<li>继承<ol>
<li>继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</li>
<li>一个派生类继承了所有的基类方法，但下列情况除外：<ol>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数</li>
</ol>
</li>
<li>派生类在继承基类的成员变量时，会单独开辟一块内存保存基类的成员变量，因此派生类自己的成员变量即使和基类的成员变量重名，但是也不会引起冲突。</li>
</ol>
</li>
<li>重载<ol>
<li>在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</li>
<li>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</li>
<li>选择最合适的重载函数或重载运算符的过程，称为重载决策。</li>
<li>重载运算符 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一元重载 !obj、-obj、--obj、++obj、obj++</span></span><br><span class="line">CLASS_NAME <span class="keyword">operator</span>- () </span><br><span class="line"><span class="comment">// 二元重载 +、-、x、/</span></span><br><span class="line">CLASS_NAME <span class="keyword">operator</span>+(<span class="type">const</span> CLASS_NAME&amp; b)</span><br><span class="line"><span class="comment">// 关系运算符  &lt; 、 &gt; 、 &lt;= 、 &gt;= 、 ==</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> CLASS_NAME&amp; b)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>多态<ol>
<li>当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</li>
<li>基类指针执行派生类对象时，<ol>
<li>静态链接：基类指针调用基类方法获取基类数据。</li>
<li>动态链接：基类函数使用virtual声明，编译器根据指针指向的对象动态绑定到对象方法，获取对象数据。</li>
</ol>
</li>
<li>可以发现派生类的函数和数据与基类是不同空间。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> aa)</span> </span>&#123;a = aa;&#125;;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// void set(int aa) &#123;a = aa;&#125;;</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B bb;</span><br><span class="line">    bb.<span class="built_in">set</span>(<span class="number">1</span>);  <span class="comment">// 基类A的a=1</span></span><br><span class="line">    <span class="comment">// 派生类B的get方法覆盖了基类同名方法，返回派生类B的a初始化默认值0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bb.get()&quot;</span> &lt;&lt; bb.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>虚函数<br> 派生类中如果与基类同名，则放在不同空间，派生类中如果没有，则拷贝一份基类放在不同空间。理论上，基类和派生类只能调用各自的方法，但是基类指针指向派生类对象时，要想让基类指针调用派生类方法，需要在基类该方法前加virtual。</li>
<li>纯虚函数<ol>
<li>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。</li>
<li>抽象类不能被用于实例化对象，它只能作为接口使用。</li>
<li>子类需要被实例化，则必须实现每个纯虚函数。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><ol>
<li>动态内存 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line">*pvalue = <span class="number">29494.99</span>;     <span class="comment">// 在分配的地址存储值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of pvalue : &quot;</span> &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> pvalue;         <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>]; <span class="comment">// 为变量请求内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维数组，动态分配,数组长度为 m</span></span><br><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> **array = <span class="keyword">new</span> <span class="type">int</span> *[m];</span><br><span class="line"><span class="comment">// 动态分配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    array[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] array[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] array;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>模版<ol>
<li>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</li>
<li>可以使用模板来定义函数和类。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数模版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">Max</span><span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;T&gt; elems;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elems.<span class="built_in">empty</span>()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>();         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt;         intStack;  <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;string&gt; stringStack;    <span class="comment">// string 类型的栈 </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line">        cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">        cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (exception <span class="type">const</span>&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>预处理器<ol>
<li>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</li>
<li>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</li>
<li>define预处理器 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (a&lt;b ? a : b)     </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line">   i = <span class="number">100</span>;</span><br><span class="line">   j = <span class="number">30</span>;</span><br><span class="line">   cout &lt;&lt;<span class="string">&quot;较小的值为：&quot;</span> &lt;&lt; <span class="built_in">MIN</span>(i, j) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>条件编译 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">   不进行编译的代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Inside main function&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// # 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;  <span class="comment">// 返回字符串 HELLO C++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"><span class="type">int</span> xy = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">concat</span>(x, y);  <span class="comment">// 等价于cout &lt;&lt; xy;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>多线程 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// 必须的头文件</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS 5</span><br><span class="line"> </span><br><span class="line">// 线程的运行函数</span><br><span class="line">void* say_hello(void* args)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello Runoob！&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 定义线程的 id 变量，多个变量使用数组</span><br><span class="line">    pthread_t tids[NUM_THREADS];</span><br><span class="line">    for(int i = 0; i &lt; NUM_THREADS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span><br><span class="line">        int ret = pthread_create(&amp;tids[i], NULL, say_hello, NULL);</span><br><span class="line">        if (ret != 0)</span><br><span class="line">        &#123;</span><br><span class="line">           cout &lt;&lt; &quot;pthread_create error: error_code=&quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ 标准库</h2><h2 id="C-标准模版库"><a href="#C-标准模版库" class="headerlink" title="C++ 标准模版库"></a>C++ 标准模版库</h2><ol>
<li>C++ 标准模板库的核心包括以下三个组件：<ol>
<li>容器<br> 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</li>
<li>算法<br> 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</li>
<li>迭代器<br> 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</li>
</ol>
</li>
<li>容器<ol>
<li>vector-数组，又称变长数组， <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// 在GCC的实现中，vector扩容是2倍扩容的</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 定义一个vector，其中的元素为int类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];  <span class="comment">// 定义一个vector数组，其中有N个vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(len)</span></span>;  <span class="comment">// 定义一个长度为len的vector，初始化每个元素为0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(len, x)</span></span>;  <span class="comment">// 定义一个长度为len的vector，初始化每个元素为x</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;  <span class="comment">// 用v1给v2赋值，v1的类型为vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.begin() + <span class="number">3</span>)</span></span>;  <span class="comment">// 将v1中第0~2三个元素赋值给v2</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 初始化vector，v:&#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();  <span class="comment">// 定义vector的迭代器，指向begin()</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);  <span class="comment">// 在vector的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;</span></span><br><span class="line">v.<span class="built_in">pop_back</span>();  <span class="comment">// 删除vector的最后一个元素，v:&#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);  <span class="comment">// 返回第一个大于等于4的元素的迭代器</span></span><br><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);  <span class="comment">// 返回第一个大于4的元素的迭代器</span></span><br><span class="line">v.<span class="built_in">front</span>();  <span class="comment">// 返回vector中的第一个元素</span></span><br><span class="line">v.<span class="built_in">back</span>();  <span class="comment">// 返回vector中的最后一个元素</span></span><br><span class="line">v.<span class="built_in">begin</span>();  <span class="comment">// 返回vector第一个元素的迭代器</span></span><br><span class="line">v.<span class="built_in">end</span>();  <span class="comment">// 返回vector最后一个元素后一个位置的迭代器</span></span><br><span class="line">v.<span class="built_in">size</span>();  <span class="comment">// 返回vector中元素的个数</span></span><br><span class="line">v.<span class="built_in">empty</span>();  <span class="comment">// 返回vector是否为空，若为空则返回true否则返回false</span></span><br><span class="line">v.<span class="built_in">clear</span>();  <span class="comment">// 清空vector</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());  <span class="comment">// 删除迭代器it所指向的元素，即删除第一个元素</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除区间[v.begin(), v.begin() + 2)的所有元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">1</span>);  <span class="comment">// 在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据下标进行遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// for_each遍历(C++11)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>stack-栈，后进先出 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">// 除了最顶端以外，没有任何方法可以存取，stack不允许有遍历行为</span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;  <span class="comment">// 定义一个stack，其中元素的类型为int</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk[N];  <span class="comment">// 定义一个stack数组，其中有N个stack</span></span><br><span class="line"></span><br><span class="line">stk.<span class="built_in">push</span>(x);  <span class="comment">// 在stack中插入元素x</span></span><br><span class="line">stk.<span class="built_in">pop</span>();  <span class="comment">// 弹出stack的栈顶元素</span></span><br><span class="line">stk.<span class="built_in">top</span>();  <span class="comment">// 返回stack的栈顶元素</span></span><br><span class="line">stk.<span class="built_in">size</span>();  <span class="comment">// 返回stack中元素的个数</span></span><br><span class="line">stk.<span class="built_in">empty</span>();  <span class="comment">// 返回stack是否为空，若为空则返回true否则返回false</span></span><br></pre></td></tr></table></figure></li>
<li>string-字符串 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// string和vector&lt;char&gt;在数据结构、内存管理等方面都是相同的</span></span><br><span class="line"><span class="comment">// string可以使用c_str()函数转换为C风格的字符串</span></span><br><span class="line"></span><br><span class="line">string str;  <span class="comment">// 定义一个空的字符串</span></span><br><span class="line">string str[N];  <span class="comment">// 定义一个string数组，其中有N个string</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">// 使用5个字符&#x27;a&#x27;初始化</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;  <span class="comment">// 使用字符串初始化</span></span><br><span class="line">string str = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;  <span class="comment">// 字符常量初始化，str=&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;d&#x27;</span>);  <span class="comment">// 在string尾部插入字符，&quot;abcabcd&quot;</span></span><br><span class="line">str.<span class="built_in">pop_back</span>();  <span class="comment">// 删除string尾部的字符，&quot;abcabc&quot;</span></span><br><span class="line">str.<span class="built_in">length</span>();  <span class="comment">// 返回string中字符的个数</span></span><br><span class="line">str.<span class="built_in">size</span>();  <span class="comment">// 作用与length()相同</span></span><br><span class="line">str.<span class="built_in">empty</span>();  <span class="comment">// 返回string是否为空，若为空返回true否则返回false</span></span><br><span class="line">str.<span class="built_in">substr</span>(<span class="number">1</span>);  <span class="comment">// 返回string中从下标为1开始至末尾的子串，&quot;bcabc&quot;</span></span><br><span class="line">str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>);  <span class="comment">// 返回string中从下标为0开始长度为2的子串，&quot;ab&quot;</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>);  <span class="comment">// 在下标为1的字符前插入2个字符&#x27;x&#x27;，&quot;axxbcabc&quot;</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;yy&quot;</span>);  <span class="comment">// 在下标为1的字符前插入字符串&quot;yy&quot;，&quot;ayyxxbcabc&quot;</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">4</span>);  <span class="comment">// 删除从位置1开始的4个字符，&quot;abcabc&quot;</span></span><br><span class="line">str.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// 返回字符&#x27;b&#x27;在string中第一次出现的位置，返回1，若不存在则返回-1</span></span><br><span class="line">str.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);  <span class="comment">// 返回从位置2开始字符&#x27;b&#x27;在string中第一次出现的位置，返回4</span></span><br><span class="line">str.<span class="built_in">find</span>(<span class="string">&quot;bc&quot;</span>);  <span class="comment">// 同上，返回字符串第一次出现的位置，返回1，若不存在则返回-1</span></span><br><span class="line">str.<span class="built_in">find</span>(<span class="string">&quot;bc&quot;</span>, <span class="number">2</span>);  <span class="comment">// 返回4</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// 反向查找，原理同上，返回4，若不存在则返回-1</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>);  <span class="comment">// 返回1</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&quot;bc&quot;</span>);  <span class="comment">// 返回4，若不存在则返回-1</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&quot;bc&quot;</span>, <span class="number">3</span>);  <span class="comment">// 返回1</span></span><br><span class="line"><span class="built_in">stoi</span>(str);  <span class="comment">// 返回str的整数形式</span></span><br><span class="line"><span class="built_in">to_string</span>(value);  <span class="comment">// 返回value的字符串形式，value为整型、浮点型等</span></span><br><span class="line">str[<span class="number">0</span>];  <span class="comment">// 用下标访问string中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string中erase()与remove()的用法</span></span><br><span class="line">string str1, str2, str3, str4, str5;</span><br><span class="line">str1 = str2 = str3 = str4 = str5 = <span class="string">&quot;I love AcWing! It&#x27;s very funny!&quot;</span>;</span><br><span class="line">str1.<span class="built_in">erase</span>(<span class="number">15</span>);  <span class="comment">// 删除[15,end())的所有元素，&quot;I love AcWing!&quot;</span></span><br><span class="line">str2.<span class="built_in">erase</span>(<span class="number">6</span>, <span class="number">11</span>);  <span class="comment">// 从第6个元素(包括)开始往后删除11个元素，&quot;I love&#x27;s very funny!&quot;</span></span><br><span class="line">str3.<span class="built_in">erase</span>(str3.<span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除迭代器所指的元素，&quot;I ove AcWing! It&#x27;s very funny!&quot;</span></span><br><span class="line">str4.<span class="built_in">erase</span>(str4.<span class="built_in">begin</span>() + <span class="number">7</span>, str4.<span class="built_in">end</span>() - <span class="number">11</span>);  <span class="comment">// 删除[str4.begin()+7,str4.end()-11)的所有元素，&quot;I love very funny!&quot;</span></span><br><span class="line">str5.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str5.<span class="built_in">begin</span>(), str5.<span class="built_in">end</span>(), <span class="string">&#x27;n&#x27;</span>), str5.<span class="built_in">end</span>());  <span class="comment">// 删除[str5.begin(),str5.end())中所有字符&#x27;n&#x27;，&quot;I love AcWig! It&#x27;s very fuy!&quot;</span></span><br><span class="line"><span class="comment">// remove是algorithm里的</span></span><br></pre></td></tr></table></figure></li>
<li>queue&#x2F;priirity_queue-队列&#x2F;优先队列 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// queue 又称队列，是一种先进先出（First In First Out，FIFO）的数据结构</span></span><br><span class="line"><span class="comment">// priority_queue又称优先队列，同样定义在&lt;queue&gt;头文件中，与queue不同的地方在于我们可以自定义其中数据的优先级，优先级高的排在队列前面，优先出队。</span></span><br><span class="line"><span class="comment">// priority_queue的本质是用堆实现的，默认是大根堆。</span></span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;  <span class="comment">// 定义一个queue，其中元素的类型为int</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que[N];  <span class="comment">// 定义一个queue数组，其中有N个queue</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; bigHeap;  <span class="comment">// 定义一个大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; bigHeap;  <span class="comment">// 定义一个大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; smallHeap;  <span class="comment">// 定义一个小根堆</span></span><br><span class="line"></span><br><span class="line">que.<span class="built_in">push</span>(x);  <span class="comment">// 在queue的队尾插入元素x</span></span><br><span class="line">que.<span class="built_in">pop</span>();  <span class="comment">// 出队queue的队头元素</span></span><br><span class="line">que.<span class="built_in">front</span>();  <span class="comment">// 返回queue的队头元素</span></span><br><span class="line">que.<span class="built_in">back</span>();  <span class="comment">// 返回queue的队尾元素</span></span><br><span class="line">que.<span class="built_in">size</span>();  <span class="comment">// 返回queue中元素的个数</span></span><br><span class="line">que.<span class="built_in">empty</span>();  <span class="comment">// 返回queue是否为空，若为空则返回true否则返回false</span></span><br><span class="line">bigHeap.<span class="built_in">top</span>();  <span class="comment">// 返回priority_queue的队头元素</span></span><br></pre></td></tr></table></figure></li>
<li>deque-双端队列 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">// vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。</span></span><br><span class="line"><span class="comment">// vector也可以在头尾两端插入元素，但是在其头部进行插入操作效率很低。</span></span><br><span class="line"><span class="comment">// vector最大的差异一是在于deque允许使用常数项时间在头部进行元素的插入和删除操作，二是在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq;  <span class="comment">// 定义一个deque，其中的元素为int类型</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq[N];  <span class="comment">// 定义一个deque数组，其中有N个deque</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq</span><span class="params">(len)</span></span>;  <span class="comment">// 定义一个长度为len的deque</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq</span><span class="params">(len, x)</span></span>;  <span class="comment">// 定义一个长度为len的deque，初始化每个元素为x</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq2</span><span class="params">(deq1)</span></span>;  <span class="comment">// 用deq1给v2赋值，deq2的类型为deque</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq2</span><span class="params">(deq1.begin(), deq1.begin() + <span class="number">3</span>)</span></span>;  <span class="comment">// 将deq1中第0~2三个元素赋值给deq2</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 初始化vector，v:&#123;1, 2, 3&#125;</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;::iterator it = deq.<span class="built_in">begin</span>();  <span class="comment">// 定义vector的迭代器，指向begin()</span></span><br><span class="line">deq.<span class="built_in">push_back</span>(<span class="number">4</span>);  <span class="comment">// 在deque的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;</span></span><br><span class="line">deq.<span class="built_in">pop_back</span>();  <span class="comment">// 删除deque的尾部元素，v:&#123;1, 2, 3&#125;</span></span><br><span class="line">deq.<span class="built_in">push_front</span>(<span class="number">4</span>);  <span class="comment">// 在deque的头部插入元素4，v:&#123;4, 1, 2, 3&#125;</span></span><br><span class="line">deq.<span class="built_in">pop_front</span>();  <span class="comment">// 删除deque的头部元素，v:&#123;1, 2, 3&#125;</span></span><br><span class="line">deq.<span class="built_in">size</span>();  <span class="comment">// 返回deque中元素的个数</span></span><br><span class="line">deq.<span class="built_in">empty</span>();  <span class="comment">// 返回deque是否为空，若为空则返回true否则返回false</span></span><br><span class="line">deq.<span class="built_in">front</span>();  <span class="comment">// 返回deque中的第一个元素</span></span><br><span class="line">deq.<span class="built_in">back</span>();  <span class="comment">// 返回deque中的最后一个元素</span></span><br><span class="line">deq.<span class="built_in">begin</span>();  <span class="comment">// 返回deque第一个元素的迭代器</span></span><br><span class="line">deq.<span class="built_in">end</span>();  <span class="comment">// 返回deque最后一个元素后一个位置的迭代器</span></span><br><span class="line">deq.<span class="built_in">clear</span>();  <span class="comment">// 清空deque</span></span><br><span class="line">deq.<span class="built_in">erase</span>(deq.<span class="built_in">begin</span>());  <span class="comment">// 删除迭代器it所指向的元素，即删除第一个元素</span></span><br><span class="line">deq.<span class="built_in">erase</span>(deq.<span class="built_in">begin</span>(), deq.<span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除区间[v.begin(), v.begin() + 2)的所有元素</span></span><br><span class="line">deq.<span class="built_in">insert</span>(deq.<span class="built_in">begin</span>(), <span class="number">1</span>);  <span class="comment">// 在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器</span></span><br></pre></td></tr></table></figure></li>
<li>map&#x2F;multimap <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>      <span class="comment">// std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">// map和multimap的底层实现机制都是红黑树。</span></span><br><span class="line"><span class="comment">// map所有的元素都是pair，同时拥有键值和实值（即(key, value)对），</span></span><br><span class="line"><span class="comment">// 所有的元素都会根据元素的键值自动排序。</span></span><br><span class="line"><span class="comment">// map不允许两个元素有相同的键值。multimap和map的操作类似，唯一区别是multimap的键值允许重复。</span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;  <span class="comment">// 定义一个将string映射成int的map</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp[N];  <span class="comment">// 定义一个map数组，其中有N个map</span></span><br><span class="line">multimap&lt;string, <span class="type">int</span>&gt; mulmp;  <span class="comment">// 定义一个将string映射成int的multimap</span></span><br><span class="line">multimap&lt;string, <span class="type">int</span>&gt; mulmp[N];  <span class="comment">// 定义一个multimap数组，其中有N个multimap</span></span><br><span class="line"><span class="comment">// multimap由于可以存在相同key，所有没有[]取key对应value值的方法</span></span><br><span class="line"></span><br><span class="line">mp[<span class="string">&quot;abc&quot;</span>] = <span class="number">3</span>;  <span class="comment">// 将&quot;abc&quot;映射到3</span></span><br><span class="line">mp[<span class="string">&quot;ab&quot;</span>]++;  <span class="comment">// 将&quot;ab&quot;所映射的整数++</span></span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;cd&quot;</span>, <span class="number">2</span>));  <span class="comment">// 插入元素</span></span><br><span class="line">mp.<span class="built_in">insert</span>(&#123; <span class="string">&quot;ef&quot;</span>, <span class="number">5</span> &#125;);  <span class="comment">// 同上</span></span><br><span class="line">mp.<span class="built_in">size</span>();  <span class="comment">// 返回map中元素的个数</span></span><br><span class="line">mp.<span class="built_in">empty</span>();  <span class="comment">// 返回map是否为空，若为空返回true否则返回false</span></span><br><span class="line">mp.<span class="built_in">clear</span>();  <span class="comment">// 清空map</span></span><br><span class="line">mp.<span class="built_in">erase</span>(<span class="string">&quot;ef&quot;</span>);  <span class="comment">// 清除元素&#123;&quot;ef&quot;, 5&#125;</span></span><br><span class="line">mp[<span class="string">&quot;abc&quot;</span>];  <span class="comment">// 返回&quot;abc&quot;映射的值</span></span><br><span class="line">mp.<span class="built_in">begin</span>();  <span class="comment">// 返回map第一个元素的迭代器</span></span><br><span class="line">mp.<span class="built_in">end</span>();  <span class="comment">// 返回map最后一个元素后一个位置的迭代器</span></span><br><span class="line">mp.<span class="built_in">find</span>(<span class="string">&quot;ab&quot;</span>);  <span class="comment">// 返回第一个键值为&quot;ab&quot;的迭代器，若不存在则返回mp.end()</span></span><br><span class="line">mp.<span class="built_in">find</span>(&#123; <span class="string">&quot;abc&quot;</span>, <span class="number">3</span> &#125;);  <span class="comment">// 返回元素&#123;&quot;abc&quot;, 3&#125;的迭代器，若不存在则返回mp.end()</span></span><br><span class="line">mp.<span class="built_in">count</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 返回第一个键值为&quot;abc&quot;的元素数量1，由于map元素不能重复因此count返回值只有0或1</span></span><br><span class="line">mp.<span class="built_in">count</span>(&#123; <span class="string">&quot;abc&quot;</span>, <span class="number">2</span> &#125;);  <span class="comment">// 返回第一个键值为&quot;abc&quot;的元素数量1，注意和find不一样，count只判断第一个键值</span></span><br><span class="line">mp.<span class="built_in">lower_bound</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 返回第一个键值大于等于&quot;abc&quot;的元素的迭代器，&#123;&quot;abc&quot;, 3&#125;</span></span><br><span class="line">mp.<span class="built_in">upper_bound</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 返回第一个键值大于&quot;abc&quot;的元素的迭代器，&#123;&quot;cd&quot;, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;string, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; (*it).first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// for_each遍历(C++11)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : mp)</span><br><span class="line">    cout &lt;&lt; x.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 扩展推断范围的for_each遍历(C++17)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li>set&#x2F;mutiset-集合 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">// 元素是有序且不重复的。</span></span><br><span class="line"><span class="comment">// multiset允许有重复元素。</span></span><br><span class="line"><span class="comment">// set和multiset的底层实现都是红黑树。</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;  <span class="comment">// 定义一个set，其中的元素类型为int</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; st[N];  <span class="comment">// 定义一个set数组，其中有N个set</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mulst;  <span class="comment">// 定义一个multiset</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mulst[N];  <span class="comment">// 定义一个multiset数组，其中有N个multiset</span></span><br><span class="line"></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);  <span class="comment">// 插入元素5</span></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">6</span>);  <span class="comment">// 同上</span></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">7</span>);  <span class="comment">// 同上</span></span><br><span class="line">st.<span class="built_in">size</span>();  <span class="comment">// 返回set中元素的个数</span></span><br><span class="line">st.<span class="built_in">empty</span>();  <span class="comment">// 返回set是否为空，若为空返回true否则返回false</span></span><br><span class="line">st.<span class="built_in">erase</span>(<span class="number">6</span>);  <span class="comment">// 清除元素6</span></span><br><span class="line">st.<span class="built_in">begin</span>();  <span class="comment">// 返回set第一个元素的迭代器</span></span><br><span class="line">st.<span class="built_in">end</span>();  <span class="comment">// 返回set最后一个元素后一个位置的迭代器</span></span><br><span class="line">st.<span class="built_in">clear</span>();  <span class="comment">// 清空set</span></span><br><span class="line">st.<span class="built_in">find</span>(<span class="number">5</span>);  <span class="comment">// 返回元素5的迭代器，若不存在则返回st.end()</span></span><br><span class="line">st.<span class="built_in">count</span>(<span class="number">5</span>);  <span class="comment">// 返回元素5的个数1，由于set元素不会重复，因此count返回值只有0或1</span></span><br><span class="line">st.<span class="built_in">lower_bound</span>(<span class="number">5</span>);  <span class="comment">// 返回第一个键值大于等于5的元素的迭代器，返回元素5的迭代器</span></span><br><span class="line">st.<span class="built_in">upper_bound</span>(<span class="number">5</span>);  <span class="comment">// 返回第一个键值大于5的元素的迭代器，返回元素7的迭代器</span></span><br></pre></td></tr></table></figure></li>
<li>unordered_map&#x2F;unordered_set <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无序，采用的是hash表结构，拥有快速检索的功能。</span></span><br><span class="line"><span class="comment">// unordered_map/unordered_set 增删改查的时间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// 不支持lower_bound()/upper_bound()函数</span></span><br><span class="line"><span class="comment">// map/set增删改查的时间复杂度为O(logn)</span></span><br><span class="line"></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; st;  <span class="comment">// 定义一个unordered_set，其中的元素类型为int</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; st[N];  <span class="comment">// 定义一个unordered_set数组，其中有N个unordered_set</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;  <span class="comment">// 定义一个unordered_map</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp[N];  <span class="comment">// 定义一个unordered_map数组，其中有N个unordered_map</span></span><br><span class="line"></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);  <span class="comment">// 插入元素5</span></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">6</span>);  <span class="comment">// 同上</span></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">7</span>);  <span class="comment">// 同上</span></span><br><span class="line">st.<span class="built_in">size</span>();  <span class="comment">// 返回unordered_set中元素的个数</span></span><br><span class="line">st.<span class="built_in">empty</span>();  <span class="comment">// 返回unordered_set是否为空，若为空返回true否则返回false</span></span><br><span class="line">st.<span class="built_in">erase</span>(<span class="number">6</span>);  <span class="comment">// 清除元素6</span></span><br><span class="line">st.<span class="built_in">find</span>(<span class="number">5</span>);  <span class="comment">// 返回元素5的迭代器，若不存在则返回st.end()</span></span><br><span class="line">st.<span class="built_in">count</span>(<span class="number">5</span>);  <span class="comment">// 返回元素5的个数，由于unordered_set元素不会重复，因此count返回值只有0或1</span></span><br><span class="line">st.<span class="built_in">begin</span>();  <span class="comment">// 返回unordered_set第一个元素的迭代器</span></span><br><span class="line">st.<span class="built_in">end</span>();  <span class="comment">// 返回unordered_set最后一个元素后一个位置的迭代器</span></span><br><span class="line">st.<span class="built_in">clear</span>();  <span class="comment">// 清空unordered_set</span></span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 插入元素&#123;1, 2&#125;</span></span><br><span class="line">mp.<span class="built_in">insert</span>(&#123; <span class="number">3</span>, <span class="number">4</span> &#125;);  <span class="comment">// 同上</span></span><br><span class="line">mp.<span class="built_in">size</span>();  <span class="comment">// 返回unordered_map中元素的个数</span></span><br><span class="line">mp.<span class="built_in">empty</span>();  <span class="comment">// 返回unordered_map是否为空，若为空返回true否则返回false</span></span><br><span class="line">mp.<span class="built_in">erase</span>(<span class="number">3</span>);  <span class="comment">// 清除元素&#123;3, 4&#125;</span></span><br><span class="line">mp.<span class="built_in">find</span>(<span class="number">1</span>);  <span class="comment">// 返回第一个键值为1的迭代器，若不存在则返回mp.end()</span></span><br><span class="line">mp.<span class="built_in">count</span>(<span class="number">1</span>);  <span class="comment">// 返回第一个键值为1的元素数量，由于unordered_map元素不能重复因此count返回值只有0或1</span></span><br><span class="line">mp.<span class="built_in">begin</span>();  <span class="comment">// 返回unordered_map第一个元素的迭代器</span></span><br><span class="line">mp.<span class="built_in">end</span>();  <span class="comment">// 返回unordered_map最后一个元素后一个位置的迭代器</span></span><br><span class="line">mp.<span class="built_in">clear</span>();  <span class="comment">// 清空unordered_map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (unordered_set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; (*it) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// for_each遍历(C++11)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : st)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; (*it).first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// for_each遍历(C++11)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : mp)</span><br><span class="line">    cout &lt;&lt; x.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 扩展推断范围的for_each遍历(C++17)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="STL-算法"><a href="#STL-算法" class="headerlink" title="STL 算法"></a>STL 算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序算法</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">5</span>);  <span class="comment">// 将区间[0, 5)内元素按字典序从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">5</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// 将区间[0, 5)内元素按字典序从大到小排序</span></span><br><span class="line"><span class="built_in">reverse</span>(a, a + <span class="number">5</span>);  <span class="comment">// 将区间[0, 5)内元素翻转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找与统计算法</span></span><br><span class="line"><span class="built_in">find</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 在区间[0, 5)内查找等于3的元素，返回迭代器，若不存在则返回end()</span></span><br><span class="line"><span class="built_in">binary_search</span>(a, a + <span class="number">5</span>, <span class="number">2</span>);  <span class="comment">// 二分查找区间[0, 5)内是否存在元素2，若存在返回true否则返回false</span></span><br><span class="line"><span class="built_in">count</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 返回区间[0, 5)内元素3的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变序列算法</span></span><br><span class="line"><span class="built_in">copy</span>(a, a + <span class="number">2</span>, a + <span class="number">3</span>);  <span class="comment">// 将区间[0, 2)的元素复制到以a+3开始的区间，即[3, 5)</span></span><br><span class="line"><span class="built_in">replace</span>(a, a + <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 将区间[0, 5)内等于3的元素替换为4</span></span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">5</span>, <span class="number">1</span>);  <span class="comment">// 将1写入区间[0, 5)中(初始化数组函数)</span></span><br><span class="line"><span class="type">int</span>* pend = <span class="built_in">unique</span>(a, a + <span class="number">4</span>);  <span class="comment">// 将相邻元素间的重复元素全部移动至末端，返回去重之后数组最后一个元素之后的地址</span></span><br><span class="line"><span class="type">int</span>* pend = <span class="built_in">remove</span>(a, a + <span class="number">4</span>, <span class="number">3</span>);  <span class="comment">// 将区间[0, 5)中的元素3移至末端，返回新数组最后一个元素之后的地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>* p = c; p != pend; p++)</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://cplusplus.com/">官网</a><br><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">菜鸟教程-c++</a><br><a href="https://www.acwing.com/blog/content/10558/">算法竞赛C++ STL容器、算法、迭代器详解</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>django</title>
    <url>/%E6%A1%86%E6%9E%B6/django/</url>
    <content><![CDATA[<p>Django是一个由Python编写的具有完整架站能力的开源Web框架。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>web 框架架构 <img src="/%E6%A1%86%E6%9E%B6/django/web_frame.png" class="" title="web 框架架构"></li>
<li>django 架构<ol>
<li>Django本身基于MVC架构，即Model（模型）+View（视图）+ Controller（控制器）设计模式，因此天然具有MVC的出色基因：开发快捷、部署方便、可重用性高、维护成本低等优点。</li>
<li>Django是一个全栈Web框架。所谓全栈框架，是指除了封装网络和线程操作，还提供HTTP请求和响应、数据库读写管理、HTML模板渲染等一系列功能的框架。</li>
<li>强大的数据库访问API。Django的Model层自带数据库ORM组件。</li>
<li>丰富的Template模板功能：Django自带类似jinjia的模板语言，不但原生功能丰富，还可以自定义模板标签和过滤器。并且以类似Python的调用机制和视图默契配合。</li>
<li>自带后台管理应用admin：只需要通过简单的几行配置和代码就可以实现一个完整的后台数据管理控制平台。这是Django最受欢迎的功能。</li>
</ol>
</li>
<li>MVC设计模式：<ol>
<li>模型(Model)：用于封装与应用程序的业务逻辑相关的数据及对数据的处理方法，是Web应用程序中用于处理应用程序的数据逻辑的部分，Model只提供功能性的接口，通过这些接口可以获取Model的所有功能。白话说，这个模块就是业务逻辑和数据库的交互层，定义了数据表。</li>
<li>视图(View)：负责数据的显示和呈现，是对用户的直接输出。</li>
<li>控制器(Controller)：负责从用户端收集用户的输入，可以看成提供View的反向功能。</li>
</ol>
</li>
<li>MTV设计模式<ol>
<li>模型(Model)：和MVC中的定义一样  </li>
<li>模板(Template)：将模型数据与HTML页面结合起来的引擎  </li>
<li>视图(View)：负责实际的业务逻辑实现</li>
</ol>
</li>
<li>Django对传统的MVC设计模式进行了修改<br> 将视图分成View模块和Template模块两部分，将动态的逻辑处理与静态的页面展示分离开。而Model采用了ORM技术，将关系型数据库表抽象成面向对象的Python类，将数据库的表操作转换成Python的类操作，避免了编写复杂的SQL语句。 <img src="/%E6%A1%86%E6%9E%B6/django/MTV.png" class="" title="web 框架架构"></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">python3 -m pip install Django</span><br><span class="line"># 或者</span><br><span class="line">pip3 install Django</span><br><span class="line"></span><br><span class="line"># 查看版本</span><br><span class="line">python -m django --version</span><br></pre></td></tr></table></figure>


<h1 id="创建项目过程"><a href="#创建项目过程" class="headerlink" title="创建项目过程"></a>创建项目过程</h1><ol>
<li>创建项目 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建项目目录</span><br><span class="line">mkdir -p /data/service/mysite</span><br><span class="line">cd /data/service/mysite</span><br><span class="line"></span><br><span class="line"># 创建虚拟环境</span><br><span class="line">virtualenv venv</span><br><span class="line"># 如果没有virtualenv则按照</span><br><span class="line">python3 -m pip install virtualenv</span><br><span class="line"># 激活虚拟环境</span><br><span class="line">source venv/bin/activate </span><br><span class="line"></span><br><span class="line"># 安装django</span><br><span class="line">python3 -m pip install Django</span><br><span class="line"></span><br><span class="line"># 当前目录下生成django项目</span><br><span class="line">django-admin startproject mysite .</span><br><span class="line"># 生成如下结构</span><br><span class="line">mysite/</span><br><span class="line">├── manage.py</span><br><span class="line">├── mysite</span><br><span class="line">│   ├── asgi.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">└── venv</span><br><span class="line">    ├── bin</span><br><span class="line">    ├── lib</span><br><span class="line">    ├── lib64</span><br><span class="line">    └── pyvenv.cfg</span><br></pre></td></tr></table></figure></li>
<li>更新sqlite3(如果需要) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https://www.sqlite.org/2023/sqlite-autoconf-3410200.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压编译</span><br><span class="line">tar zxvf sqlite-autoconf-3410200.tar.gz</span><br><span class="line">cd sqlite-autoconf-3410200/</span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"># 删除旧的，关联新的</span><br><span class="line">mv /usr/bin/sqlite3 /usr/bin/sqlite3_old</span><br><span class="line">ln -s /usr/local/bin/sqlite3 /usr/bin/sqlite3</span><br><span class="line">echo &#x27;/usr/local/lib&#x27; &gt; /etc/ld.so.conf.d/sqlite3.conf</span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line"># 查看版本</span><br><span class="line">sqlite3 -version</span><br></pre></td></tr></table></figure></li>
<li>运行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加远程主机，防火墙也要放开监听端口通过</span><br><span class="line">vim mysite/settings.py </span><br><span class="line">ALLOWED_HOSTS = [&#x27;云主机IP&#x27;]</span><br><span class="line"></span><br><span class="line"># 仅本机浏览器查看，以127.0.0.1:8000这个默认配置启动开发服务器。</span><br><span class="line">python3 manage.py runserver</span><br><span class="line"></span><br><span class="line"># 远程云主机浏览器也能查看</span><br><span class="line">python3 manage.py runserver 0:8000</span><br><span class="line"></span><br><span class="line"># 浏览器查看</span><br><span class="line">http://&lt;服务器IP&gt;:8000</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="创建投票项目应用"><a href="#创建投票项目应用" class="headerlink" title="创建投票项目应用"></a>创建投票项目应用</h2><ol start="0">
<li>项目内容<br> 一个可以让公众用户进行投票和查看投票结果的站点<br> 一个可以进行增、删、改、查的后台管理界面，也就是我们常说的admin站点</li>
<li>请求和响应<ol>
<li>创建应用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py startapp polls</span><br><span class="line"></span><br><span class="line"># 结构如下</span><br><span class="line">polls/</span><br><span class="line">├── admin.py</span><br><span class="line">├── apps.py</span><br><span class="line">├── __init__.py</span><br><span class="line">├── migrations</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── models.py</span><br><span class="line">├── tests.py</span><br><span class="line">└── views.py</span><br></pre></td></tr></table></figure></li>
<li>修改<ol>
<li><p>根路由：vim mysite&#x2F;urls.py</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    # include语法相当于多级路由，它把接收到的url地址去除与此项匹配的部分</span><br><span class="line">    path(&#x27;polls/&#x27;, include(&#x27;polls.urls&#x27;)),</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>应用app路由：vim polls&#x2F;urls.py</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line"># 应用名，模版中防止不同应用相同路由</span><br><span class="line">app_name = &#x27;polls&#x27;</span><br><span class="line">urlpatterns = [</span><br><span class="line">    # ex: /polls/</span><br><span class="line">    path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;),</span><br><span class="line"></span><br><span class="line">    # ex: /polls/5/</span><br><span class="line">    path(&#x27;&lt;int:question_id&gt;/&#x27;, views.detail, name=&#x27;detail&#x27;),</span><br><span class="line"></span><br><span class="line">    # ex: /polls/5/results/</span><br><span class="line">    path(&#x27;&lt;int:question_id&gt;/results/&#x27;, views.results, name=&#x27;results&#x27;),</span><br><span class="line"></span><br><span class="line">    # ex: /polls/5/vote/</span><br><span class="line">    path(&#x27;&lt;int:question_id&gt;/vote/&#x27;, views.vote, name=&#x27;vote&#x27;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>模版文件：vim polls&#x2F;templates&#x2F;polls&#x2F;xxx.html</p>
<ol>
<li>展示最近5个问题：index.html <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;&#123;%url &#x27;polls:detail&#x27; question.id %&#125;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;p&gt;No polls are available.&lt;/p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li>展示某个问题详情包括问题本身和投票项目 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&#123;% url &#x27;polls:vote&#x27; question.id %&#125;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">    &lt;legend&gt;&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;/legend&gt;</span><br><span class="line">    &#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;</span><br><span class="line">    &#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">        &lt;input type=&quot;radio&quot; name=&quot;choice&quot; id=&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot; value=&quot;&#123;&#123; choice.id &#125;&#125;&quot;&gt;       &lt;label for=&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot;&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Vote&quot;&gt;</span><br><span class="line">&lt;/form&gt;               </span><br></pre></td></tr></table></figure></li>
<li>展示某个问题投票后结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;polls:detail&#x27; question.id %&#125;&quot;&gt;Vote again?&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>视图函数：vim polls&#x2F;views.py</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, get_object_or_404</span><br><span class="line">from django.http import HttpResponse, HttpResponseRedirect, Http404</span><br><span class="line">from .models import Question</span><br><span class="line">from django.urls import reverse</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    &quot;&quot;&quot;展示最近5个问题&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    latest_question_list = Question.objects.order_by(&#x27;-pub_date&#x27;)[:5]</span><br><span class="line">    context = &#123;</span><br><span class="line">        &#x27;latest_question_list&#x27;: latest_question_list,</span><br><span class="line">    &#125;</span><br><span class="line">    return render(request, &#x27;polls/index.html&#x27;, context)</span><br><span class="line">    # return HttpResponse(template.render(context, request))</span><br><span class="line">    # return HttpResponse(&quot;hello, world. You&#x27;re at the polls index.&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def detail(request, question_id):</span><br><span class="line">    &quot;&quot;&quot;展示每个问题详情&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # try:</span><br><span class="line">    #     question = Question.objects.get(pk=question_id)</span><br><span class="line">    # except Question.DoesNotExist:</span><br><span class="line">    #     raise Http404(&quot;Question does not exist&quot;)</span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    return render(request, &#x27;polls/detail.html&#x27;, &#123;&#x27;question&#x27;: question&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def results(request, question_id):</span><br><span class="line">    &quot;&quot;&quot;投票结果&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    return render(request, &#x27;polls/results.html&#x27;, &#123;&#x27;question&#x27;: question&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def vote(request, question_id):</span><br><span class="line">    &quot;&quot;&quot;投票&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    try:</span><br><span class="line">        selected_choice = question.choice_set.get(pk=request.POST[&#x27;choice&#x27;])</span><br><span class="line">    except (KeyError, Choice.DoesNotExist):</span><br><span class="line">        # 投票选项不存在,返回详情页</span><br><span class="line">        return render(request, &#x27;polls/detail.html&#x27;, &#123;</span><br><span class="line">            &#x27;question&#x27;: question,</span><br><span class="line">            &#x27;error_message&#x27;: &quot;You didn&#x27;t select a choice.&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    else:</span><br><span class="line">        # 投票选项存在,增加该选项值,返回投票结果页</span><br><span class="line">        selected_choice.votes += 1</span><br><span class="line">        selected_choice.save()</span><br><span class="line">        return HttpResponseRedirect(reverse(&#x27;polls:results&#x27;, args=(question.id,)))</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 浏览器输入</span><br><span class="line">http://&lt;服务器IP&gt;:8000/polls/</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>模型和数据库<ol>
<li>默认数据库sqlite3切换为mysql<br> vim mysite&#x2F;settings.py <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;mysite&#x27;,</span><br><span class="line">        &#x27;USER&#x27;: &#x27;root&#x27;,</span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;jesonlin&#x27;,</span><br><span class="line">        &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">        &#x27;OPTIONS&#x27;: &#123;&#x27;init_command&#x27;: &#x27;set names utf8mb4;&#x27;, &#x27;charset&#x27;: &#x27;utf8mb4&#x27;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 需要依赖包</span><br><span class="line">yum install mysql-devel</span><br><span class="line">yum install python3-devel</span><br><span class="line">yum install gcc</span><br><span class="line">pip3 install mysqlclient</span><br><span class="line"></span><br><span class="line"># 为 INSTALLED_APPS 默认应用创建表</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></li>
<li>其他设置<br> vim mysite&#x2F;settings.py <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TIME_ZONE = &#x27;Asia/Shanghai&#x27;</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...,</span><br><span class="line">    &#x27;polls&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>创建模型 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># polls/models.py</span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Question(models.Model):</span><br><span class="line">    question_text = models.CharField(max_length=200)</span><br><span class="line">    pub_date = models.DateTimeField(&#x27;date published&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.question_text</span><br><span class="line">    def was_published_recently(self):</span><br><span class="line">        return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1)</span><br><span class="line"></span><br><span class="line">class Choice(models.Model):</span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=200)</span><br><span class="line">    votes = models.IntegerField(default=0)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.choice_text       </span><br></pre></td></tr></table></figure></li>
<li>将模型生效到数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成迁移文件</span><br><span class="line">python manage.py makemigrations polls</span><br><span class="line"># 查看具体sql语句</span><br><span class="line">python manage.py sqlmigrate polls 0001</span><br><span class="line"># 执行sql语句</span><br><span class="line">python manage.py migrate polls</span><br><span class="line"># 有多个数据库时候路由</span><br><span class="line"># python manage.py migrate polls --database config</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>django的python交互式命令行<ol>
<li>启动交互式命令行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># manage.py 会设置 DJANGO_SETTINGS_MODULE 环境变量</span><br><span class="line"># 这个变量会让 Django 根据 mysite/settings.py 文件来设置 Python 包的导入路径。</span><br><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure></li>
<li>通过orm插入DB数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from polls.models import Choice, Question</span><br><span class="line">&gt;&gt;&gt; Question.objects.all()</span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; from django.utils import timezone</span><br><span class="line">&gt;&gt;&gt; q = Question(question_text=&quot;What&#x27;s new?&quot;, pub_date=timezone.now())</span><br><span class="line">&gt;&gt;&gt; q.save()</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; q.id</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; q.question_text</span><br><span class="line">&quot;What&#x27;s new?&quot;</span><br><span class="line">&gt;&gt;&gt; q.pub_date</span><br><span class="line">datetime.datetime(2023, 4, 11, 13, 12, 18, 914351, tzinfo=&lt;UTC&gt;)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; q.question_text = &quot;What&#x27;s up?&quot;</span><br><span class="line">&gt;&gt;&gt; q.save()</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; Question.objects.all()</span><br><span class="line">&lt;QuerySet [&lt;Question: What&#x27;s up?&gt;]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; current_year = timezone.now().year</span><br><span class="line">&gt;&gt;&gt; Question.objects.get(pub_date__year=current_year)</span><br><span class="line">&lt;Question: What&#x27;s up?&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"># pk 是primary key的简写</span><br><span class="line">&gt;&gt;&gt; q = Question.objects.get(pk=1)</span><br><span class="line">&gt;&gt;&gt; q.was_published_recently()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.all()</span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"># 插入外键关联的数据</span><br><span class="line">&gt;&gt;&gt; q.choice_set.create(choice_text=&#x27;Not much&#x27;, votes=0)</span><br><span class="line">&lt;Choice: Not much&gt;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.create(choice_text=&#x27;The sky&#x27;, votes=0)</span><br><span class="line">&lt;Choice: The sky&gt;</span><br><span class="line">&gt;&gt;&gt; c = q.choice_set.create(choice_text=&#x27;Just hacking again&#x27;, votes=0)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"># 被外键关联，查看所有关联项目</span><br><span class="line">&gt;&gt;&gt; q.choice_set.all()</span><br><span class="line">&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.count()</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>amdin 管理页面<ol start="0">
<li>管理页面 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://&lt;服务器IP&gt;:8000/admin/</span><br></pre></td></tr></table></figure></li>
<li>创建登录管理页面的超级用户 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line"># 按提示输入超级用户信息</span><br><span class="line"># 此时数据表auth_user就会插入一条用户信息</span><br></pre></td></tr></table></figure></li>
<li>向管理页面添加投票应用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># polls/admin.py</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Question</span><br><span class="line"># Register your models here.</span><br><span class="line"></span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>模版<ol start="0">
<li>配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysite/setting.py</span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        &#x27;APP_DIRS&#x27;: True, # 表示优先找每个app下的templates文件夹</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><pre><code>商品管理和展示（待实践）
</code></pre>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.djangoproject.com/">官网</a><br><a href="https://www.liujiangblog.com/course/django/">刘江-django教程</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch</title>
    <url>/%E5%AD%98%E5%82%A8/elasticsearch/</url>
    <content><![CDATA[<p>Elasticsearch 是一个分布式、高扩展、高实时的搜索与数据分析引擎。</p>
<span id="more"></span>

<p>待补充</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">全文搜索引擎 Elasticsearch 入门教程</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>flask</title>
    <url>/%E6%A1%86%E6%9E%B6/flask/</url>
    <content><![CDATA[<p>Flask 是一款针对Python的“微型框架”，它是构建更小应用、API和web服务的极佳选择。 Flask是任何不适用Django的Python web应用的默认选择。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>使用Flask构建应用，除了一些函数附上路由，它和写标准Python模块很相似。它真的很赞。</li>
<li>Flask不会提供一切您可能需要的内容，而是实现了web应用框架中最常用的核心组件，比如说URL路由、请求和响应对象和模板等。</li>
<li>作为Flask的用户，由您来决定选择和集成其他您可能用到的组件。比如说数据库访问或者表单生成和验证就不是Flask内置的功能。</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://flask.palletsprojects.com/en/2.2.x/">官网</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/%E5%B7%A5%E5%85%B7/git/</url>
    <content><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统，所有的版本控制系统，只能跟踪文本文件的改动，而无法跟踪二进制文件的改变。</p>
<span id="more"></span>

<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><ol>
<li>安装（cetos7为例） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install git</span><br><span class="line">&lt;!-- 验证 --&gt;</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure></li>
<li>配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 账号和邮箱 --&gt;</span><br><span class="line">git config --global user.name &quot;jesonlin&quot;</span><br><span class="line">git config --global user.email &quot;jesonlin@outlook.com&quot;</span><br><span class="line"></span><br><span class="line">&lt;!-- 颜色 --&gt;</span><br><span class="line">git config --global color.ui true</span><br><span class="line"></span><br><span class="line">&lt;!-- 设置别名 --&gt;</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">&lt;!-- 撤销暂存区git reset HEAD file --&gt;</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD&#x27;</span><br><span class="line">git config --global alias.last &#x27;log -1&#x27;</span><br><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure></li>
<li>查看配置信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">&lt;!-- 每个仓库下的配置位置 --&gt;</span><br><span class="line">.git/config</span><br><span class="line"></span><br><span class="line">&lt;!-- 全局配置位置 --&gt;</span><br><span class="line">~/.gitconfig</span><br></pre></td></tr></table></figure></li>
<li>忽略特殊文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line"></span><br><span class="line">&lt;!-- 官方提供各类忽略文件模版 --&gt;</span><br><span class="line">https://github.com/github/gitignore</span><br><span class="line"></span><br><span class="line">&lt;!-- 在线生成.gitignore --&gt;</span><br><span class="line">https://gitignore.itranswarp.com/</span><br><span class="line"></span><br><span class="line">&lt;!-- 检查某个文件被哪条规则忽略 --&gt;</span><br><span class="line">git check-ignore -v &lt;文件名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 被忽略情况下强制提交 --&gt;</span><br><span class="line">git add -f &lt;文件名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 不排除某些文件 --&gt;</span><br><span class="line">vim .gitignore</span><br><span class="line">!.gitignore</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol start="0">
<li>版本库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作区：就是你在电脑里能看到的目录。</span><br><span class="line">暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</span><br><span class="line">版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</span><br></pre></td></tr></table></figure>
 <img src="/%E5%B7%A5%E5%85%B7/git/repository.jpg" class="" title="版本库">
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 针对工作区的修改</span><br><span class="line">1. git add: 将工作区修改添加到暂存区</span><br><span class="line">    &lt;!-- 添加/删除指定文件 --&gt;</span><br><span class="line">    git add/rm &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 添加新文件/修改过的文件，不包括删除文件 --&gt;</span><br><span class="line">    git add .</span><br><span class="line"></span><br><span class="line">    &lt;!-- --update update tracked files 添加有更新变化的被追踪的文件，不包括新添加的文件 --&gt;</span><br><span class="line">    git add -u</span><br><span class="line"></span><br><span class="line">    &lt;!-- --all，添加所有修改和新增的文件 --&gt;</span><br><span class="line">    git add -A . </span><br><span class="line">2. git checkout: 撤销工作区修改，将暂存区覆盖工作区</span><br><span class="line">    &lt;!-- 撤销工作区指定文件修改，用暂存区相应内容替换工作区内容 --&gt;</span><br><span class="line">    git checkout -- &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 撤销工作区所有修改，用暂存区替换工作区，不影响新增 --&gt;</span><br><span class="line">    git checkout .</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 针对暂存区的修改</span><br><span class="line">3. git commit: 将暂存区修改添加到版本库</span><br><span class="line">    git commit -m &quot;初始化&quot;</span><br><span class="line">4. git reset: 撤销暂存区修改，将版本库覆盖暂存区</span><br><span class="line">    &lt;!-- 版本库覆盖暂存区&lt;文件&gt; --&gt;</span><br><span class="line">    git reset HEAD &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 版本库覆盖暂存区和工作区&lt;文件&gt; --&gt;</span><br><span class="line">    git reset --hard HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></li>
<li>查看提交日志&#x2F;命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 提交日志 --&gt;</span><br><span class="line">git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">&lt;!-- 所有命令（包含回退/前进） --&gt;</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure></li>
<li>版本回退&#x2F;前进 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- --hard 表示工作区和暂存存都重置，无则表示只重置暂存区 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 回退上个版本 --&gt;</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line">&lt;!-- 回退上个版本，保留修改 --&gt;</span><br><span class="line">git reset --soft HEAD^</span><br><span class="line"></span><br><span class="line">&lt;!-- 回退前10个版本 --&gt;</span><br><span class="line">git reset --hard HEAD~10</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转到指定版本（包括回退和前进，只要记得commit的id） --&gt;</span><br><span class="line">git reset --hard 【COMMIT_ID】</span><br></pre></td></tr></table></figure></li>
<li>比较差异 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 比较工作区和暂存区的修改 --&gt;</span><br><span class="line">git diff &lt;文件名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 比较工作区和上一次commit后的修改 --&gt;</span><br><span class="line">git diff HEAD &lt;文件名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 比较暂存区和上一次commit后的修改 --&gt;</span><br><span class="line">git diff --cached &lt;文件名&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ol start="0">
<li>查看分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查看分支(-a 包括远端分支) --&gt;</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure></li>
<li>创建分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建分支 --&gt;</span><br><span class="line">git branch &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 切换分支 --&gt;</span><br><span class="line">git checkout &lt;新分支名&gt;</span><br><span class="line">git switch &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 创建并切换到分支 --&gt;</span><br><span class="line">git checkout -b &lt;新分支名&gt;</span><br><span class="line">git switch -c &lt;新分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>推送分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin &lt;本地分支名&gt;:&lt;远端分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>删除分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 删除本地分支 --&gt;</span><br><span class="line">git branch -d &lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 删除远端分支 --&gt;</span><br><span class="line">git push origin :&lt;远端分支名&gt;</span><br><span class="line">git push origin --delete &lt;远端分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>合并分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 默认使用Fast forward，看不出来曾经做过合并 --&gt;</span><br><span class="line">git merge &lt;待合并的分支名&gt;</span><br><span class="line">&lt;!-- 使用普通模式，可以看出曾经合并过 --&gt;</span><br><span class="line">git merge --no-ff -m &quot;&quot; &lt;待合并分支名&gt;</span><br></pre></td></tr></table></figure>
 <img src="/%E5%B7%A5%E5%85%B7/git/merge-no-ff.png" class="" title="普通模式合并分支"></li>
<li>分支冲突 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 --&gt;</span><br><span class="line">&lt;!-- 手动修改后提交 --&gt;</span><br><span class="line">git add</span><br><span class="line">git commit -m </span><br><span class="line">&lt;!-- 查看提交日志 --&gt;</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure></li>
<li>分支策略<ol>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 <img src="/%E5%B7%A5%E5%85%B7/git/merge-strategy.png" class="" title="分支策略"></li>
</ol>
</li>
</ol>
<h2 id="实际开发（分支、多人开发冲突）"><a href="#实际开发（分支、多人开发冲突）" class="headerlink" title="实际开发（分支、多人开发冲突）"></a>实际开发（分支、多人开发冲突）</h2><ol start="0">
<li>分支基本情况<br> master<br> dev（当前已有修改）</li>
<li>stash (保存现场）<br> 临时需要修复bug <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 保存dev现场 --&gt;</span><br><span class="line">    git stash</span><br><span class="line"></span><br><span class="line">&lt;!-- 2. 切换到master分支 --&gt;</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">&lt;!-- 创建临时修复bug分支 --&gt;</span><br><span class="line">git checkout -b issue-101</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交修改 --&gt;</span><br><span class="line">git add -A .</span><br><span class="line">git commit -m &quot;fix buf 101&quot;</span><br><span class="line"></span><br><span class="line">&lt;!-- 切换到master分支 --&gt;</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">&lt;!-- 合并bug分支 --&gt;</span><br><span class="line">git merge --no-ff -m &quot;merge bug fix 101&quot; issue-101</span><br><span class="line"></span><br><span class="line">&lt;!-- 切换回dev分支 --&gt;</span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line">&lt;!-- 查看之前保存的现场 --&gt;</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line">&lt;!-- 还原旧的现场 --&gt;</span><br><span class="line">git stash apply</span><br><span class="line">&lt;!-- 还原旧的指定现场 --&gt;</span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br><span class="line">&lt;!-- 删除旧的现场 --&gt;</span><br><span class="line">git stash drop</span><br><span class="line">&lt;!-- 还原并删除 --&gt;</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li>
<li>cherry-pick (重放bug修复到dev分支) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- dev 提交bug修复的提交id --&gt;</span><br><span class="line">git cherry-pick &lt;bug分支上修复bug的commit_id&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- cherry-pick 重放指定提交 --&gt;</span><br><span class="line">a - b - c -d    master</span><br><span class="line">    |</span><br><span class="line">    e - f - g   dev</span><br><span class="line">git checkout master</span><br><span class="line">git cherry-pick f</span><br><span class="line">&lt;!-- 将dev的f提交重放到master分支 --&gt;</span><br><span class="line">a - b - c -d - f   master</span><br><span class="line">    |</span><br><span class="line">    e - f - g   dev    </span><br><span class="line"></span><br><span class="line">&lt;!-- cherry-pick 重放指定多个提交 --&gt;</span><br><span class="line">git cherry-pick &lt;A-commit_id&gt; &lt;B-commit_id&gt;</span><br><span class="line">&lt;!-- cherry-pick 重放指定多个连续提交(A,B] --&gt;</span><br><span class="line">git cherry-pick &lt;A-commit_id&gt;..&lt;B-commit_id&gt;</span><br><span class="line">&lt;!-- cherry-pick 重放指定多个连续提交[A,B] --&gt;</span><br><span class="line">git cherry-pick &lt;A-commit_id&gt;^..&lt;B-commit_id&gt;</span><br></pre></td></tr></table></figure></li>
<li>多人协作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 试图推送自己的修改 --&gt;</span><br><span class="line">git push origin &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2. 如果推送失败，使用pull试图合并 --&gt;</span><br><span class="line">git pull</span><br><span class="line">&lt;!-- 如果pull提示没有tracking，则关联本地和远程分支名 --&gt;</span><br><span class="line">git branch --set-upstream-to &lt;本地分支名&gt; origin/&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 3. 如果合并有冲突，解决冲突并提交 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 4. 没有冲突或者冲突解决后，推送 --&gt;</span><br><span class="line">git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>rebase (变基操作把本地未push的分叉提交历史整理成直线) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">origin/master    a - b - c</span><br><span class="line">                     |</span><br><span class="line">local/master         d - e</span><br><span class="line">&lt;!-- 1. 本地已有1+未push得提交 --&gt;</span><br><span class="line">（d 和 e）</span><br><span class="line"></span><br><span class="line">&lt;!-- 2. 直接提交会报冲突 --&gt;</span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">&lt;!-- 3. 先把c拉取到本地 --&gt;</span><br><span class="line">git pull </span><br><span class="line"></span><br><span class="line">&lt;!-- 4. 此时本地提交比远程超前3个提交 --&gt;</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">&lt;!-- 5. 变基，改变本地两个未提交和远程新提交顺序--&gt;</span><br><span class="line">git rebase</span><br><span class="line"></span><br><span class="line">原本分叉的提交现在变成一条直线了，Git把我们本地的提交“挪动”了位置，放到远程新提交的后面，符合整体变更顺序。</span><br></pre></td></tr></table></figure>
 <img src="/%E5%B7%A5%E5%85%B7/git/rebase-1.jpg" class="" title="变基前本地提交记录">
 <img src="/%E5%B7%A5%E5%85%B7/git/rebase-2.jpg" class="" title="变基后本地提交记录"></li>
</ol>
<h2 id="标签（版本库快照。）"><a href="#标签（版本库快照。）" class="headerlink" title="标签（版本库快照。）"></a>标签（版本库快照。）</h2><ol>
<li>标签 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查看标签列表 --&gt;</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">&lt;!-- 查看标签 --&gt;</span><br><span class="line">git show &lt;标签名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 打标签 --&gt;</span><br><span class="line">git tag -a &lt;标签名&gt; -m &quot;xxx&quot; &lt;commit_id&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 推送指定/所有标签 --&gt;</span><br><span class="line">git push origin &lt;标签名&gt;</span><br><span class="line">git pusH origin --tags</span><br><span class="line"></span><br><span class="line">&lt;!-- 删除本地标签 --&gt;</span><br><span class="line">git tag -d &lt;标签名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 删除远程标签 --&gt;</span><br><span class="line">git push origin :refs/tags/&lt;标签名&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><ol>
<li>创建本地仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line">cd project</span><br><span class="line">git init</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;init git&quot;</span><br></pre></td></tr></table></figure></li>
<li>远程仓库<ol>
<li>本地仓库关联远程仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 本地仓库关联远程仓库 --&gt;</span><br><span class="line">git remote add origin git@github.com:linjinzhong/blog.git</span><br><span class="line"></span><br><span class="line">&lt;!-- 解除关联 --&gt;</span><br><span class="line">$ git remote rm origin</span><br><span class="line"></span><br><span class="line">&lt;!-- 推送 --&gt;</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure></li>
<li>克隆远程仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 克隆远程仓库，默认只有master分钟 --&gt;</span><br><span class="line">git clone git@github.com:linjinzhong/blog.git</span><br><span class="line">&lt;!-- 克隆后希望拉取非master分支 --&gt;</span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">&lt;!-- 直接克隆非master分钟 --&gt;</span><br><span class="line">git clone -b ac git@gitlab.yopoint.vip:ac/YoPointSwift.git</span><br></pre></td></tr></table></figure></li>
<li>权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">&lt;!-- 一路回车 --&gt;</span><br><span class="line">ll /root/.ssh/</span><br><span class="line"></span><br><span class="line">&lt;!-- 将/root/.ssh/id_rsa.pub内容拷贝到git上 --&gt;</span><br><span class="line">cat /root/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">&lt;!-- git ssh地址 --&gt;</span><br><span class="line">https://github.com/settings/keys</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://git-scm.com/">git-官网</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰-Git教程</a><br><a href="https://www.runoob.com/git/git-tutorial.html">菜鸟-Git教程</a><br><a href="https://github.com/linjinzhong/blog/blob/source/source/_posts/git/git-cheat-sheet.pdf">Git-Cheat-Sheet</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>go</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/</url>
    <content><![CDATA[<p>Go 是由谷歌工程师 Robert Griesemer、Rob Pike 和 Ken Thompson 设计的。它是一种静态类型的、编译的语言。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>centos-yum <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install golang</span><br></pre></td></tr></table></figure></li>
<li>centos-tar <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 下载 --&gt;</span><br><span class="line">https://go.dev/doc/install</span><br><span class="line">&lt;!-- 解压 --&gt;</span><br><span class="line">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.4.linux-amd64.tar.gz</span><br><span class="line">&lt;!-- 添加环境变量 --&gt;</span><br><span class="line">vim /etc/profile</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">&lt;!-- 重启终端查看go版本 --&gt;</span><br><span class="line">go version</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello, word"></a>hello, word</h2><ol>
<li>Go 是由 packages（包）组成的。<br> vim main.go   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main  # 程序入口点，package main 告诉 Go 编译器，该程序被编译为可执行文件，而不是共享库。</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">  fmt.Println(&quot;Hello World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build main.go</span><br><span class="line">./main</span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li>变量<br> Go 中的变量是明确声明的。Go 是一种静态类型的语言。这意味着在声明变量的时候会检查变量的类型。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a int  // 声明a为int型，并附初始值0</span><br><span class="line">var a = 1  // 等价于 var a int = 1 </span><br><span class="line">var a, b int = 1, 2</span><br><span class="line">a := 1  // 只能在函数内部</span><br></pre></td></tr></table></figure></li>
<li>整型、浮点型、无符号整型、字符串、布尔<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var e int = 1  // 整型：int, int8, int16, int32, int64</span><br><span class="line">var d float32 = 3.14  // 浮点数：float32 和 float64</span><br><span class="line">var c uint = 1  //无符号整型：uint, uint8, uint16, uint32, uint64, uintptr</span><br><span class="line">var b string = &#x27;hello&#x27;  // 字符串：string</span><br><span class="line">var a bool = true  // 布尔：bool</span><br></pre></td></tr></table></figure></li>
<li>数组、切片、maps <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a [5]int  // 一维数组</span><br><span class="line">var multiA [2][3]int  // 二维数组</span><br><span class="line"></span><br><span class="line">var b []int  // 切片容量为 0、长度为 0 的切片。</span><br><span class="line">numbers := make([]int, 5, 10)  // 初始长度为 5，容量为 10。</span><br><span class="line">numbers = append(numbers, 1, 2, 3, 4)  // append 函数将值添加到数组的末端</span><br></pre></td></tr></table></figure></li>
<li>maps <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var m map[string]int</span><br><span class="line">m[&#x27;xx&#x27;] = 2</span><br></pre></td></tr></table></figure></li>
<li>类型转换 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := 1.1</span><br><span class="line">b := int(a)</span><br></pre></td></tr></table></figure></li>
<li>条件语句<ol>
<li>if else <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if num := 9; num &lt; 0 &#123;</span><br><span class="line">    fmt.Println(num, &quot;is negative&quot;)</span><br><span class="line">&#125; else if num &lt; 10 &#123;</span><br><span class="line">    fmt.Println(num, &quot;has 1 digit&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    fmt.Println(num, &quot;has multiple digits&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>switch case <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 2</span><br><span class="line">switch i &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        fmt.Println(&quot;one&quot;)</span><br><span class="line">    case 2:</span><br><span class="line">        fmt.Println(&quot;two&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;none&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>循环 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 0</span><br><span class="line">sum := 0</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;  // 三个条件都可以去掉</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br></pre></td></tr></table></figure></li>
<li>指针<br> 在传递结构体作为参数时，或者在为定义的类型声明方法时，通常倾向于使用指针。<br> 传递值时，实际上是在复制值，这意味着更多的内存。<br> 通过指针，函数改变的值会反映在 方法&#x2F;函数 调用者身上。   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := 12</span><br><span class="line">var ap *int</span><br><span class="line">ap = &amp;a</span><br><span class="line">var ap *int = &amp;a</span><br></pre></td></tr></table></figure></li>
<li>函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func add(a int, b int ) (c int, s string) &#123;</span><br><span class="line">    c = a + b</span><br><span class="line">    s = &quot;succ&quot;</span><br><span class="line">    return  // return c, s</span><br><span class="line">&#125;</span><br><span class="line">func add(a int, b int ) (int, string) &#123;  // 同时有或者没有变量名</span><br><span class="line">    c := a + b</span><br><span class="line">    s := &quot;succ&quot;</span><br><span class="line">    return  return c, s</span><br><span class="line">&#125;</span><br><span class="line">funcmain() &#123;</span><br><span class="line">    sum, msg := add(2, 1)</span><br><span class="line">    fmt.Println(sum, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结构体、方法、接口<br>Go并不是一种完全面向对象的语言，但通过结构体（Struct）、接口（Interface）和方法（Method），它有很多面向对象的支持和感觉。  <ol>
<li>结构体：结构体是一种类型化的、不同字段的集合。结构体用于将数据分组 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义 --&gt;</span><br><span class="line">type person struct &#123;  // 有序</span><br><span class="line">    name string</span><br><span class="line">    age int</span><br><span class="line">    gender string</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 创建 --&gt;</span><br><span class="line">p := person&#123;name: &quot;Bob&quot;, age: 12, gender: &quot;Male&quot;&#125;</span><br><span class="line">p := person&#123;&quot;Bob&quot;, 12, &quot;Male&quot;&#125;</span><br><span class="line">&lt;!-- 访问 --&gt;</span><br><span class="line">fmt.Println(p.name, p.age, p.gender)</span><br><span class="line">&lt;!-- 指针访问 --&gt;</span><br><span class="line">p := &amp;person&#123;name: &quot;Bob&quot;, age: 12, gender: &quot;Male&quot;&#125;</span><br><span class="line">fmt.Println(p.name, p.age, p.gender)</span><br></pre></td></tr></table></figure></li>
<li>方法：方法（Method）是一种特殊的函数类型，它有一个 receiver 。receiver 可以是一个值或一个指针。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (p *person) describe() &#123;</span><br><span class="line">    fmt.Printf(&quot;%v is %v years old.\n&quot;, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line">func (p *person) setAge(age int) &#123;</span><br><span class="line">    p.age = age</span><br><span class="line">&#125;</span><br><span class="line">func (p person) setName(name string) &#123;  // receiver是结构体值，并不是指针，所以是拷贝修改，不影响调用体</span><br><span class="line">    p.name = name</span><br><span class="line">&#125;</span><br><span class="line">p := &amp;person&#123;name: &quot;Bob&quot;, age: 12, gender: &quot;Male&quot;&#125;</span><br><span class="line">p.describe()</span><br><span class="line">p.setAge(66)</span><br><span class="line">fmt.Println(p.age)</span><br><span class="line">p.setName(&quot;jesonlin&quot;)</span><br><span class="line">fmt.Println(p.name)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://golang.org/">go官网</a><br><a href="https://go.dev/play/">go在线运行</a><br><a href="https://www.freecodecamp.org/chinese/news/learning-go-from-zero-to-hero/">从 0 到 1 学习 Golang</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/%E5%B7%A5%E5%85%B7/hexo/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is quick start post. Check <a href="https://hexo.io/docs/">documentation</a> for more info.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-draft"><a href="#Create-a-new-draft" class="headerlink" title="Create a new draft"></a>Create a new draft</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft <span class="string">&quot;My New Draft&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Publish-a-new-draft"><a href="#Publish-a-new-draft" class="headerlink" title="Publish a new draft"></a>Publish a new draft</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish <span class="string">&quot;My New Draft&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new post <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mac-设置</title>
    <url>/%E5%B7%A5%E5%85%B7/mac-%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>记录下windows多年老用户切换到mac系统后更趁手的设置。</p>
<span id="more"></span>

<h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><ol>
<li>触控板选项-轻点省力  <ol>
<li>【系统偏好设置】-》【触控板】-》勾选【轻点来点按】  </li>
<li>触控板有很多好用的手势，可以实时学习</li>
</ol>
</li>
<li>三指拖移-拖拽超级好用<br> 【系统偏好设置】-》【辅助功能】-》【指针控制】-》【触控板选项】-》【启用拖移】三指拖移</li>
<li>访达偏好设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【桌面】-》左上角【访达】-》【偏好设置】-》 【边栏】-》勾上所需</span><br></pre></td></tr></table></figure></li>
<li>底部程序坞设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">鼠标置于程序坞-》双指按压-》程序坞偏好设置-》置于屏幕底部/自动隐藏</span><br></pre></td></tr></table></figure></li>
<li>顶部图标栏 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按住【cmd】键，三指拖拽顶部图标下拉，有出现删除标记可以删除</span><br></pre></td></tr></table></figure></li>
<li>文件显示 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序坞打开【访达】-》按住【cmd】+[up]键直到最顶层 -》点击左上角显示-》</span><br><span class="line">选择【为列表】</span><br><span class="line">选择【显示标签页栏】</span><br><span class="line">选择【显示路径栏】</span><br><span class="line">选择【显示状态栏】</span><br><span class="line">选择【查看选项】-》勾选【始终以列表】-》排序方式【修改日期】-》选中【用作默认】</span><br></pre></td></tr></table></figure></li>
<li>触发角 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【系统偏好设置】-》【桌面与屏幕保护程序】-》【触发角】</span><br><span class="line">【左上角】-》【将显示器置于休眠状态】</span><br><span class="line">【左下角】-》【启动屏幕保护程序】</span><br><span class="line">【右上角】-》【调度中心】</span><br><span class="line">【右下角】-》【桌面】</span><br></pre></td></tr></table></figure></li>
<li>终端设置<ol>
<li>窗口设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开终端偏好设置-》样式选中【homebrew】-》字体大小选中【18】-》窗口选中列数100行数36</span><br></pre></td></tr></table></figure></li>
<li>brew <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27; &gt;&gt; /Users/XXXX/.zshrc</span><br><span class="line">echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27; &gt;&gt; /Users/jesonlin/.zshrc</span><br></pre></td></tr></table></figure></li>
<li>zsh  <ol>
<li>安装   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li>
<li>显示当前目录绝对路径   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.oh-my-zsh/themes/robbyrussell.zsh-theme</span><br><span class="line">PROMPT+=&#x27; %&#123;$fg[cyan]%&#125;%d%&#123;$reset_color%&#125; $(git_prompt_info)&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>别名的快捷操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line">export PATH=$HOME/bin:/usr/local/bin:/usr/bin:$PATH</span><br><span class="line">alias ll=&#x27;ls -alhF&#x27;</span><br><span class="line">alias subl=&quot;/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl&quot;</span><br><span class="line">alias -s py=subl</span><br><span class="line">eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Python环境<ol>
<li>安装pyenv   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</span><br><span class="line">vim ~/.zshrc</span><br><span class="line">export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;   </span><br></pre></td></tr></table></figure></li>
<li>查看看着Python版本 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv install -l</span><br></pre></td></tr></table></figure></li>
<li>安装python指定版本（m1 pro有问题） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv install 3.6.8</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>SMB共享的网络磁盘上DS_Store文件的阻止生成方案<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【终端】-》defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol start="0">
<li>复制&#x3D;&#x3D;拷贝+粘贴   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+ 【d】</span><br></pre></td></tr></table></figure></li>
<li>拷贝 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【c】</span><br></pre></td></tr></table></figure></li>
<li>粘贴  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【v】</span><br></pre></td></tr></table></figure></li>
<li>剪切（文本）   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【x】</span><br></pre></td></tr></table></figure></li>
<li>剪切（文件）   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【c】, 【cmd】 + 【opt】 + 【v】</span><br></pre></td></tr></table></figure></li>
<li>关闭软件   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【q】</span><br></pre></td></tr></table></figure></li>
<li>任务管理器   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【opt】 + 【esc】</span><br></pre></td></tr></table></figure></li>
<li>预览  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单击中 + 空格  / 三指单击</span><br></pre></td></tr></table></figure></li>
<li>数据查询和英文翻译   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三指单击</span><br></pre></td></tr></table></figure></li>
<li>截图  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全屏：【shift】 +【cmd】 + 【3】  </span><br><span class="line">指定区域：【shift】 + 【cmd】 + 【4】  </span><br><span class="line">特定窗口：【shift】 + 【cmd】 + 【4】 + 【space】  </span><br></pre></td></tr></table></figure></li>
<li>录屏<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【shift】 + 【cmd】 + 【5】</span><br></pre></td></tr></table></figure></li>
<li>聚焦搜索(升级为Alfred)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【space】</span><br></pre></td></tr></table></figure></li>
<li>调出访达搜索<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【opt】+【space】</span><br></pre></td></tr></table></figure></li>
<li>delete<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【fn】+【backpace】</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><ol>
<li><p>连接服务器</p>
<ol>
<li>连接服务器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【桌面】-》【前往】-》【连接服务器】（【cmd】+【k】）</span><br><span class="line">smb://XXX.XXX.XXX.XXX/文件夹路径</span><br></pre></td></tr></table></figure></li>
<li>连接远程服务器<ol>
<li>安装smb服务 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install samba</span><br></pre></td></tr></table></figure></li>
<li>选择要共享的文件夹，添加权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /root</span><br></pre></td></tr></table></figure></li>
<li>打开smb配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br><span class="line">// 在global下面添加一行访问端口，因为运营商常把445端口拦截了</span><br><span class="line">[global]</span><br><span class="line">        smb ports = 1315 1314</span><br><span class="line">// 文件末尾添加访问名及其对应共享文件夹</span><br><span class="line">[share]</span><br><span class="line">    comment = Share Directories</span><br><span class="line">    path=/root</span><br><span class="line">    public = yes</span><br><span class="line">    browseable = yes</span><br><span class="line">    writable = yes</span><br><span class="line">    create mask = 0777</span><br><span class="line">    directory mask = 0777</span><br></pre></td></tr></table></figure></li>
<li>创建smb登录用户名 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch /etc/samba/smbpasswd #新建文件</span><br><span class="line">smbpasswd -a root</span><br></pre></td></tr></table></figure></li>
<li>并且将smb设置为开机自启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig --level 3 smb on</span><br></pre></td></tr></table></figure></li>
<li>重新启动smb <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service smb start</span><br></pre></td></tr></table></figure></li>
<li>腾讯云服务器-》防火墙-》开启1314 1315端口</li>
</ol>
</li>
</ol>
</li>
<li><p>键位映射-karabiner-elements-神器-模拟filco键盘键位  </p>
<ol>
<li>【系统偏好设置】-》【键盘】-》【按下地球仪fn键时】-》选中不做任何操作 </li>
<li>mac键位映射-》打开karabiner-elements<ol>
<li>【Profiles】  <ol>
<li>删除所有，保留一个默认的’default’</li>
<li>新建一个’mac’，这些配置会出现在【菜单栏karabiner-elements的下拉列表】</li>
<li>将配置文件mac.json放在【~&#x2F;.config&#x2F;karabiner&#x2F;assets&#x2F;complex_modifications】</li>
<li>文件路径也可在【Misc】-》【Export &amp; Import】双击打开</li>
</ol>
</li>
<li>【Device】选择【Apple Internal Keyboard】</li>
<li>【Simple modifications】-》【Apple Internal Keyboard】: 简单的键位映射 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn -&gt; caps lock</span><br><span class="line">caps lock -&gt; left_command</span><br><span class="line">left_command -&gt; fn</span><br></pre></td></tr></table></figure></li>
<li>【Complex modifications】-》【Apple Internal Keyboard】：复杂的组合映射<ol>
<li>【Add rule】</li>
<li>选择刚才mac.json中的四条映射规则<ol>
<li>fn + aesdfg &#x3D; head&#x2F;上&#x2F;左&#x2F;下&#x2F;右&#x2F;tail</li>
<li>right_command + k&#x2F;&lt; &#x3D; home&#x2F;end</li>
<li>right_command + l&#x2F;&gt; &#x3D; page_up&#x2F;page_down</li>
<li>绑定fn + tab &#x3D; left_command + tab</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>filco-minila-air键位映射-》打开karabiner-elements<ol>
<li>新建一个’filco’,会生成对应filco.json文件放在指定路径。</li>
<li>【Device】选中连接的filco蓝牙键盘</li>
<li>【Simple modifications】-》【FILCO XXX】: 简单的键位映射<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left_control -&gt; caps lock</span><br><span class="line">caps lock -&gt; left_command</span><br><span class="line">left_command -&gt; left_control</span><br></pre></td></tr></table></figure></li>
<li>【Function keys】-》【FILCO XXX】：功能键映射，将Fx键映射本身而不是mac上的功能。</li>
<li>【Complex modifications】-》【FILCO XXX】：复杂的组合映射<ol>
<li>【Add rule】</li>
<li>选择刚才filco.json中的两条映射规则<ol>
<li>left_option + esdfag &#x3D; head&#x2F;上&#x2F;左&#x2F;下&#x2F;右&#x2F;tail</li>
<li>left_option + tab &#x3D; left_command + tab</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><ol>
<li>屏保 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://fliqlo.com/</span><br></pre></td></tr></table></figure></li>
<li>搜狗输入法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://pinyin.sogou.com/mac/</span><br></pre></td></tr></table></figure></li>
<li>谷歌浏览器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.google.com/intl/zh-CN/chrome/</span><br><span class="line"># 插件</span><br><span class="line">https://chrome.google.com/webstore/category/extensions?hl=zh-CN</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. iTab新标签页（丰富的标签页）</span><br><span class="line">2. DJSON. JSON Viewer &amp; Formatter（json格式化）</span><br><span class="line">3. Markdown Preview Plus（可以用sublime打开md文件编辑，同时用chrome打开该文件实时刷新预览）</span><br><span class="line">4. 有道词典Chrome划词插件（翻译插件）</span><br><span class="line">5. Talend API Tester - Free Edition（发包工具）</span><br></pre></td></tr></table></figure></li>
<li>sublime <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.sublimetext.com</span><br></pre></td></tr></table></figure></li>
<li>xmind <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.xmind.cn/</span><br></pre></td></tr></table></figure></li>
<li>Alfred <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过一个输入框快速完成文件搜索、自定义动作</span><br><span class="line">https://www.alfredapp.com/</span><br><span class="line"># 先取消原有聚焦搜索快捷键</span><br><span class="line">【系统偏好设置】-》【键盘】-》【快捷键】-》【聚焦搜索】</span><br><span class="line"># 设置Alfred快捷键</span><br><span class="line">【cmd】+【space】</span><br><span class="line"># 其他设置待摸索</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://github.com/linjinzhong/Software/blob/master/filco.json">filco.json</a><br><a href="https://github.com/linjinzhong/Software/blob/master/mac.json">mac.json</a> </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mac设置</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-事务</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p>
<span id="more"></span>

<h2 id="事务有哪些特性？-acid"><a href="#事务有哪些特性？-acid" class="headerlink" title="事务有哪些特性？ - acid"></a>事务有哪些特性？ - acid</h2><ol>
<li><p>原子性（atomicity）<br> 一个事务中的所有操作，要么全部完成，要么全部不完成。</p>
</li>
<li><p>一致性（consistency）<br> 事务操作前后，数据满足完整性约束，数据库保持一致性状态。</p>
</li>
<li><p>隔离性（isolation）<br> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</p>
</li>
<li><p>持久性（durability）<br> 事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。</p>
</li>
</ol>
<h2 id="InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？"><a href="#InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？" class="headerlink" title="InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？"></a>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</h2><ol>
<li>原子性-通过 uodo log(回滚日志)来保证。</li>
<li>一致性-通过持久性+原子性+隔离性来保证。</li>
<li>隔离性-通过MVCC（多版本并发控制）或锁机制来保证。</li>
<li>持久性-通过 redo log（重放日志）来保证。</li>
</ol>
<h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。那么在同时处理多个事务的时候，可能出现如下问题</p>
<p>严重性排序如下：</p>
<img src="./并行事务引发的问题.webp" width = "50%" height = "50%" alt="并行事务引发的问题" align=center />

<ol>
<li><p>脏读 - 读到其他事务未提交的数据<br> 如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p>
</li>
<li><p>不可重复读 - 前后读取的数据不一致<br> 在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。 </p>
</li>
<li><p>幻读 - 前后读取的记录数量不一致<br> 在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p>
</li>
</ol>
<h2 id="事务的隔离级别有哪些"><a href="#事务的隔离级别有哪些" class="headerlink" title="事务的隔离级别有哪些"></a>事务的隔离级别有哪些</h2><p>按隔离水平高低排序如下：<br><img src="./隔离级别.webp" width = "50%" height = "50%" alt="隔离级别" align=center /></p>
<ol>
<li>读未提交（read uncommitted）<br> 指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li>读提交（read committed）<br> 指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li>可重复读（repeatable read）<br> 指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；</li>
<li>串行化（serializable ）<br> 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ol>
<p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</p>
<p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇文章 (opens new window)），解决的方案有两种：</p>
<ol>
<li>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。</li>
<li>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，</li>
</ol>
<h2 id="事务的隔离级别实现"><a href="#事务的隔离级别实现" class="headerlink" title="事务的隔离级别实现"></a>事务的隔离级别实现</h2><ol>
<li>读未提交，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>读提交，通过 Read View 来实现的，可以理解成一个数据快照。在「每个语句执行前」都会重新生成一个 Read View。</li>
<li>可重复读，通过 Read View 来实现的，可以理解成一个数据快照。在「启动事务时」生成一个 Read View。然后整个事务期间都在用这个 Read View。</li>
<li>串行化，通过加读写锁的方式来避免并行访问；</li>
</ol>
<h2 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h2><ol>
<li><p>Read View 结构</p>
 <img src="./readview结构.webp" width = "50%" height = "50%" alt="readview结构" align=center />

<ol>
<li>creator_trx_id：创建该 Read View 的事务的事务 id。</li>
<li>m_ids：创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。</li>
<li>min_trx_id：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。</li>
<li>max_trx_id：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；</li>
</ol>
</li>
<li><p>聚簇索引记录的两个隐藏列</p>
 <img src="./记录隐藏列.webp" width = "50%" height = "50%" alt="记录隐藏列" align=center />

<ol>
<li>trx_id：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li>
<li>roll_pointer（undo log）：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo log日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。</li>
</ol>
</li>
<li><p>记录里的事务id trx_id 的划分情况</p>
 <img src="./trx_id_所有记录.webp" width = "50%" height = "50%" alt="trx_id_所有记录" align=center />

<p> 一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<pre><code> 1. 如果 trx_id &lt; Read View 中的 min_trx_id，表示这个版本的记录是在创建 Read View 之前已经提交的事务生成的，是可见的。

 2. 如果 trx_id &gt;= Read View 中的 max_trx_id，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，是不可见的。

 3. 如果 min_trx_id &lt;= trx_id &lt; max_trx_id，需要判断 trx_id 是否在 m_ids 列表中：
     1. 如果在列表中，表示生成该版本记录的活跃事务依然活跃（还没提交事务），不可见
     2. 如果不在列表中，表示生成该版本记录的活跃事务已经被提交，可见。
</code></pre>
<p> 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</p>
</li>
</ol>
<h2 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h2><p>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。</p>
<p>然后根据 Read View(读视图) 和 记录里两个隐藏列 trx_id(事务id) 和 undo log() 来实现。</p>
<h2 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h2><p>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。</p>
<p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
<h2 id="MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p>
<pre><code>1. 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。

2. 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。
</code></pre>
<p>这两个解决方案是很大程度上解决了幻读现象，但是还是有个别的情况造成的幻读现象是无法解决的。</p>
<ol>
<li><p>快照读是如何避免幻读的？<br> 可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
</li>
<li><p>当前读是如何避免幻读的？<br> MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p>
<p> 这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p>
<p> Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁。</p>
<p> 事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。</p>
<p> 然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。</p>
</li>
<li><p>幻读被完全解决了吗？<br> 可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读。</p>
<p> 在可重复读隔离级别下</p>
<pre><code> 事务 A 第一次执行普通的 select 语句时生成了一个 ReadView。

 之后事务 B 向表中新插入了一条 id = 5 的记录并提交。

 接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id。

 之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。
</code></pre>
<p> 除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p>
<pre><code> T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。

 T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；
 
 T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。
</code></pre>
<p> 要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-内存</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。</p>
<span id="more"></span>

<h1 id="为什么要有-Buffer-Pool"><a href="#为什么要有-Buffer-Pool" class="headerlink" title="为什么要有 Buffer Pool"></a>为什么要有 Buffer Pool</h1><img src="./缓冲池.webp" width = "50%" height = "50%" alt="缓冲池" align=center />

<p>MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p>
<h2 id="有了缓冲池后："><a href="#有了缓冲池后：" class="headerlink" title="有了缓冲池后："></a>有了缓冲池后：</h2><p>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</p>
<p>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</p>
<h2 id="Buffer-Pool-有多大？"><a href="#Buffer-Pool-有多大？" class="headerlink" title="Buffer Pool 有多大？"></a>Buffer Pool 有多大？</h2><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下Buffer Pool 只有 128MB 。</p>
<p>可以通过调整 innodb_buffer_pool_size 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p>
<h2 id="Buffer-Pool-缓存什么？"><a href="#Buffer-Pool-缓存什么？" class="headerlink" title="Buffer Pool 缓存什么？"></a>Buffer Pool 缓存什么？</h2><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p>
<p>Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p>
<p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。</p>
<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p>
<img src="./bufferpool内容.webp" width = "50%" height = "50%" alt="bufferpool内容" align=center />


<h1 id="如何管理-Buffer-Pool？"><a href="#如何管理-Buffer-Pool？" class="headerlink" title="如何管理 Buffer Pool？"></a>如何管理 Buffer Pool？</h1><h2 id="如何管理空闲页？"><a href="#如何管理空闲页？" class="headerlink" title="如何管理空闲页？"></a>如何管理空闲页？</h2><img src="./freelis.webp" width = "50%" height = "50%" alt="freelis" align=center />
    
<p>Buffer Pool 是一片连续的内存空间，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 Free 链表（空闲链表）。</p>
<h2 id="如何管理脏页？"><a href="#如何管理脏页？" class="headerlink" title="如何管理脏页？"></a>如何管理脏页？</h2><img src="./Flush.webp" width = "50%" height = "50%" alt="Flush" align=center />

<p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为脏页，然后再由后台线程将脏页写入到磁盘。</p>
<p>为了能快速知道哪些缓存页是脏的，于是就设计出 Flush 链表，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p>
<h2 id="如何提高缓存命中率？"><a href="#如何提高缓存命中率？" class="headerlink" title="如何提高缓存命中率？"></a>如何提高缓存命中率？</h2><p>Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。</p>
<p>要实现这个，最容易想到的就是 LRU（Least recently used）算法。</p>
<p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p>
<p>Buffer Pool 里有三种页和链表来管理数据。</p>
<img src="./bufferpoll_page.webp" width = "50%" height = "50%" alt="bufferpoll_page" align=center />

<pre><code>Free Page（空闲页），表示此页未被使用，位于 Free 链表；
Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。
Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。
</code></pre>
<p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：<br>预读失效：</p>
<pre><code>程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。但是可能这些被提前加载进来的数据页，并没有被访问，相当于这个预读是白做了，这个就是预读失效。

解决方法：
    让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长。
</code></pre>
<img src="./young+old.webp" width = "50%" height = "50%" alt="young+old" align=center />

<p>Buffer Pool 污染：</p>
<pre><code>当某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 Buffer Pool 污染。

Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。比如索引失效导致的全表扫描。

解决方法：
    像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。

    MySQL 是这样做的，进入到 young 区域条件增加了一个停留在 old 区域的时间判断。
        
    这个间隔时间是由 innodb_old_blocks_time 控制的，默认是 1000 ms。

    也就说，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部，这样就解决了 Buffer Pool 污染的问题 。

    另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。
</code></pre>
<h2 id="脏页什么时候会被刷入磁盘？"><a href="#脏页什么时候会被刷入磁盘？" class="headerlink" title="脏页什么时候会被刷入磁盘？"></a>脏页什么时候会被刷入磁盘？</h2><p>InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p>
<p>下面几种情况会触发脏页的刷新：</p>
<pre><code>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；

Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；

MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；

MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；
</code></pre>
<p>在我们开启了慢 SQL 监控后，如果你发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p>
<p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
<h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-基础</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>MySQL 执行一条查询&#x2F;更新语句，期间发生了什么？</p>
<span id="more"></span>

<h2 id="MySQL-执行查询流程"><a href="#MySQL-执行查询流程" class="headerlink" title="MySQL 执行查询流程"></a>MySQL 执行查询流程</h2><ol start="0">
<li><p>mysql逻辑架构图</p>
 <!-- <img src="/%E5%AD%98%E5%82%A8/mysql-%E5%9F%BA%E7%A1%80/mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.webp" class="" title="mysql逻辑架构图"> -->
 <img src="./mysql逻辑架构图.webp" width = "50%" height = "50%" alt="update更新流程" align=center />
</li>
<li><p>连接器-建立连接，管理连接、校验用户身份</p>
<ol>
<li>客户端跟服务端建立连接 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</span></span><br><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure></li>
<li>TCP 三次握手；</li>
<li>验证用户名和密码，权限固定在该连接上；</li>
<li>连接后状态 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有后续动作处于空闲状态，即Command列显示sleep</span></span><br><span class="line">show processlist;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 太长没动静，根据参数wait_timeout时间断开链接，默认8小时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立链接比较复杂，尽量使用长连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为执行过程中临时使用的内存是管理在连接对象里面的。所以长连接累积下来，可能导致内存占用太大。被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</span></span><br><span class="line"><span class="comment"># 定期断开长连接或者执行较大操作后通过执行mysql_reset_connection来重新初始化连接资源。</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>查询缓存-查询语句:查询结果</p>
<ol>
<li>mysql拿到一个查询请求后，会先查询缓存看看，key 是查询的语句，value 是查询的结果。</li>
<li>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</li>
<li>缓存“按需使用”的方式。将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_cache <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
 MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</li>
</ol>
</li>
<li><p>分析器-sql语句词法和语法解析构建语法树</p>
<ol>
<li>SQL语句解析，输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</li>
<li>词法分析。</li>
<li>语法分析。</li>
</ol>
</li>
<li><p>执行器</p>
<ol>
<li>预处理阶段-字段表校验、符号扩展<br> 检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li>
<li>优化器-怎么做<ol>
<li>在表里面有多个索引的时候，决定使用哪个索引；</li>
<li>在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</li>
<li>覆盖索引，不回表，直接在二级索引就能查到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值）。同时查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大（因为主键索引叶子节点存全量数据）。</li>
</ol>
</li>
<li>执行器-具体执行。<ol>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推<ol>
<li>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配。</li>
<li>将其他条件中的联合索引部分条件在引擎层判断，减少回表后在server层判断的次数。</li>
<li>二级索引在查询时的不进行回表操作，就能提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="MySQL-执行更新流程"><a href="#MySQL-执行更新流程" class="headerlink" title="MySQL 执行更新流程"></a>MySQL 执行更新流程</h2><!-- <img src="/%E5%AD%98%E5%82%A8/mysql-%E5%9F%BA%E7%A1%80/update%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.webp" class="" title="update 更新流程"> -->
<img src="./update更新流程.webp" width = "50%" height = "50%" alt="update更新流程" align=center />


<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><img src="/%E5%AD%98%E5%82%A8/mysql-%E5%9F%BA%E7%A1%80/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png" class="" title="两阶段提交">

<p>InnoDB在写redo log时，并不是一次性写完的，而有两个阶段，Prepare与Commit阶段，这就是”两阶段提交”的含义。</p>
<ol>
<li><p>为什么要写redo log?<br> MySQL为了提升性能，引入了BufferPool缓冲池。查询数据时，先从BufferPool中查询，查询不到则从磁盘加载在BufferPool。</p>
<p> 每次对数据的更新，也不总是实时刷新到磁盘，而是先同步到BufferPool中，涉及到的数据页就会变成脏页。</p>
<p> 同时会启动后台线程，异步地将脏页刷新到磁盘中，来完成BufferPool与磁盘的数据同步。</p>
<p> 如果在某个时间，MySQL突然崩溃，则内存中的BufferPool就会丢失，剩余未同步的数据就会直接消失。</p>
<p> 虽然在更新BufferPool后，也写入了binlog中，但binlog并不具备crash-safe的能力。</p>
<p> 因为崩溃可能发生在写binlog后，刷脏前。在主从同步的情况下，从节点会拿到多出来的一条binlog。</p>
</li>
<li><p>为什么要写两次redo log?<br> 如果只写一次，存在以下两种</p>
<pre><code> 1. 先写binlog，再写redo log
     当前事务提交后，写入binlog成功，之后主节点崩溃。在主节点重启后，由于没有写入redo log，因此不会恢复该条数据。

     而从节点依据binlog在本地回放后，会相对于主节点多出来一条数据，从而产生主从不一致。

 2. 先写redo log，再写binlog
     当前事务提交后，写入redo log成功，之后主节点崩溃。在主节点重启后，主节点利用redo log进行恢复，就会相对于从节点多出来一条数据，造成主从数据不一致。
</code></pre>
<p> 因此，只写一次redo log与binlog，无法保证这两种日志在事务提交后的一致性。</p>
</li>
<li><p>两阶段提交的情况下，如何实现崩溃恢复？<br> 首先比较重要的一点是，在写入redo log时，会顺便记录当前事务id。在写入binlog时，也会写入当前事务id。</p>
<pre><code> 1. 如果在写入redo log之前崩溃，那么此时redo log与binlog中都没有，是一致的情况，崩溃也无所谓。

 2. 如果在写入redo log prepare阶段之后立马崩溃，之后会在崩溃恢复时，由于redo log没有被标记为commit。于是拿 redo log中事务id去bin log中查找，此时肯定找不到，立即执行回滚操作。

 3. 如果在写入bin log后立马崩溃，在恢复时，由redo log中的事务id可以找到对应的bin log，这个时候直接提交即可。
</code></pre>
<p> 总的来说，在崩溃恢复后，只要redo log不是处于commit阶段，那么就拿着redo log中的XID去binlog中寻找，找得到就提交，否则就回滚。</p>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-日志</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>MySQL 日志主要有 binlog（归档日志）、redo log（重做日志）、undo log（回退日志）。</p>
<span id="more"></span>

<h2 id="执行一条-update-语句，期间发生了什么？"><a href="#执行一条-update-语句，期间发生了什么？" class="headerlink" title="执行一条 update 语句，期间发生了什么？"></a>执行一条 update 语句，期间发生了什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE t_user SET name = &#x27;xiaolin&#x27; WHERE id = 1;</span><br></pre></td></tr></table></figure>
<h3 id="client-and-server-服务层操作"><a href="#client-and-server-服务层操作" class="headerlink" title="client and server 服务层操作"></a>client and server 服务层操作</h3><pre><code>1. 客户端先通过连接器建立连接，连接器自会判断用户身份；
2. 因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；
3. 解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；
4. 预处理器会判断表和字段是否存在，将*展开为对应字段列表；
5. 优化器确定执行计划，主要是索引的选择或者连表查询时的选择，这里因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；
6. 执行器负责具体执行，找到这一行，然后更新。
</code></pre>
<h3 id="server-and-InnoDB-引擎层操作"><a href="#server-and-InnoDB-引擎层操作" class="headerlink" title="server and InnoDB 引擎层操作"></a>server and InnoDB 引擎层操作</h3><pre><code>1. 执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：
    1. 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；
    2. 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。
2. 执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：
    1. 如果一样的话就不进行后续更新流程；
    2. 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；
3. 开启事务，InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。
4. InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。
5. 至此，一条记录更新完了。
6. 在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。
7. 事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：
    1. prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；
    2. commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；
</code></pre>
<h2 id="undo-log（回滚日志）、redo-log（重做日志）、binlog（归档日志）"><a href="#undo-log（回滚日志）、redo-log（重做日志）、binlog（归档日志）" class="headerlink" title="undo log（回滚日志）、redo log（重做日志）、binlog（归档日志）"></a>undo log（回滚日志）、redo log（重做日志）、binlog（归档日志）</h2><pre><code>1. undo log（回滚日志）
    是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。
2. redo log（重做日志）
    是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
3. binlog （归档日志）
    是 Server 层生成的日志，主要用于数据备份和主从复制；
</code></pre>
<h2 id="为什么需要-Buffer-Pool？"><a href="#为什么需要-Buffer-Pool？" class="headerlink" title="为什么需要 Buffer Pool？"></a>为什么需要 Buffer Pool？</h2><p>Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能</p>
<pre><code>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。

当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。
</code></pre>
<p>Buffer Pool 缓存什么？</p>
<pre><code>在 MySQL 启动的时候，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。

Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。
</code></pre>
<p>Undo 页是记录什么？</p>
<pre><code>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。
</code></pre>
<p>查询一条记录，就只需要缓冲一条记录吗？</p>
<pre><code>当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。
</code></pre>
<h2 id="为什么需要-undo-log-？"><a href="#为什么需要-undo-log-？" class="headerlink" title="为什么需要 undo log ？"></a>为什么需要 undo log ？</h2><p>undo log（回滚日志） 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。它保证了事务的 ACID 特性 (opens new window)中的原子性（Atomicity）。</p>
<p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p>
<pre><code>通过 trx_id 可以知道该记录是被哪个事务修改的；
通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；
</code></pre>
<p>另外，undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）。</p>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同。</p>
<pre><code>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。

「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。
</code></pre>
<p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p>
<p>因此，undo log 两大作用：</p>
<pre><code>实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。

实现 MVCC（多版本并发控制）关键因素之一。MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。
</code></pre>
<p>undo log 是如何刷盘（持久化到磁盘）的？</p>
<pre><code>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。

buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。
</code></pre>
<h2 id="为什么需要-redo-log-？"><a href="#为什么需要-redo-log-？" class="headerlink" title="为什么需要 redo log ？"></a>为什么需要 redo log ？</h2><p>Buffer Pool 是基于内存的，是提高了读写效率没错，但是内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL （Write-Ahead Logging）技术。</p>
<p>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</p>
<img src="./wal.webp" width = "50%" height = "50%" alt="wal" align=center />

<p>什么是 redo log？</p>
<pre><code>redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志。

在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。

当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。
</code></pre>
<p>被修改 Undo 页面，需要记录对应 redo log 吗？</p>
<pre><code>需要的。开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。不过，在内存修改该 Undo 页面后，需要记录对应的 redo log。
</code></pre>
<p>redo log 和 undo log 区别在哪？</p>
<pre><code>undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；

redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；

事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：
</code></pre>
<img src="./事务恢复.webp" width = "50%" height = "50%" alt="事务恢复" align=center />

<p>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 crash-safe（崩溃恢复）。可以看出来， redo log 保证了事务四大特性中的持久性。</p>
<p>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</p>
<pre><code>写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。

磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。
</code></pre>
<p>至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p>
<pre><code>实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；

将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能。
</code></pre>
<p>产生的 redo log 是直接写入磁盘的吗？</p>
<pre><code>不是的。

实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。

所以，redo log 也有自己的缓存—— redo log buffer，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图
</code></pre>
<p>redo log 什么时候刷盘？<br>缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？</p>
<p>主要有下面几个时机：</p>
<pre><code>1. MySQL 正常关闭时；
2. 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；
3. InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。
4. 每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。
</code></pre>
<p>加入了后台现线程后，innodb_flush_log_at_trx_commit 的刷盘时机如下图：<br><img src="./innodb_flush_log_at_trx_commit.webp" width = "50%" height = "50%" alt="innodb_flush_log_at_trx_commit" align=center /></p>
<p>redo log 文件写满了怎么办？</p>
<pre><code>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：ib_logfile0 和 ib_logfile1 。

在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。

重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。

redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置，如下图：
</code></pre>
<img src="./checkpoint.webp" width = "50%" height = "50%" alt="checkpoint" align=center />

<pre><code>如果 write pos 追上了 checkpoint，就意味着 redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞（因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要），此时会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针），然后 MySQL 恢复正常运行，继续执行新的更新操作。
</code></pre>
<h2 id="为什么需要binlog"><a href="#为什么需要binlog" class="headerlink" title="为什么需要binlog"></a>为什么需要binlog</h2><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p>
<p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<p>为什么有了 binlog， 还要有 redo log？</p>
<pre><code>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。

而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。
</code></pre>
<p>redo log 和 binlog 有什么区别？</p>
<pre><code>1、适用对象不同：
    binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；
    redo log 是 Innodb 存储引擎实现的日志；
2、文件格式不同：
    binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：
        STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；
        ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；
        MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；
    redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；
3、写入方式不同：
    binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。
    redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。
4、用途不同：
    binlog 用于备份恢复、主从复制；
    redo log 用于掉电等故障恢复。
</code></pre>
<p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p>
<pre><code>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。

因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。

binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。
</code></pre>
<p>主从复制是怎么实现？</p>
<pre><code>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。
</code></pre>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<pre><code>写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。
同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。
回放 Binlog：回放 binlog，并更新存储引擎中的数据。
</code></pre>
<p>从库是不是越多越好？</p>
<pre><code>不是的。

因为从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。
</code></pre>
<p>MySQL 主从复制还有哪些模型？</p>
<pre><code>同步复制：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。

异步复制（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。

半同步复制：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。
</code></pre>
<p>binlog 什么时候刷盘？</p>
<pre><code>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。

在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。
</code></pre>
<img src="./binlogcache.webp" width = "50%" height = "50%" alt="binlogcache" align=center />

<p>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：</p>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<pre><code>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；
sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；
sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。
</code></pre>
<p>在MySQL中系统默认的设置是 sync_binlog &#x3D; 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p>
<h2 id="为什么需要两阶段提交？"><a href="#为什么需要两阶段提交？" class="headerlink" title="为什么需要两阶段提交？"></a>为什么需要两阶段提交？</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p>
<p>在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。</p>
<p>这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p>
<p>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p>
<p>两阶段提交的过程是怎样的？</p>
<pre><code>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了内部 XA 事务（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。
</code></pre>
<img src="./两阶段提交.webp" width = "50%" height = "50%" alt="两阶段提交" align=center />
    
<pre><code>prepare 阶段：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；

commit 阶段：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；
</code></pre>
<p>所以说，两阶段提交是以 binlog 写成功为事务提交成功的标识，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p>
<p>事务没提交的时候，redo log 会被持久化到磁盘吗？</p>
<pre><code>会的。

事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。

也就是说，事务没提交的时候，redo log 也是可能被持久化到磁盘的。
</code></pre>
<p>如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</p>
<pre><code>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。

所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。
</code></pre>
<p>两阶段提交有什么问题？</p>
<pre><code>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：

磁盘 I/O 次数高：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。

锁竞争激烈：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。

MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数
</code></pre>
<h2 id="MySQL-磁盘-I-x2F-O-很高，有什么优化的方法？"><a href="#MySQL-磁盘-I-x2F-O-很高，有什么优化的方法？" class="headerlink" title="MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？"></a>MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</h2><p>我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I&#x2F;O 的频率：</p>
<pre><code>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。

将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。

将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。
</code></pre>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-索引</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p>
<span id="more"></span>

<h2 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h2><p>帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ol>
<li>数据结构：B+tree索引、hash索引、Full-text索引</li>
<li>物理存储：聚簇索引（主键索引）、非聚簇索引（二级索引、辅助索引）</li>
<li>字段特性：主键索引、唯一索引、普通索引、前缀索引</li>
<li>字段个数：单列索引、联合索引</li>
</ol>
<h2 id="InnoDB存储引擎索引选择"><a href="#InnoDB存储引擎索引选择" class="headerlink" title="InnoDB存储引擎索引选择"></a>InnoDB存储引擎索引选择</h2><ol>
<li>默认使用主键作为聚簇索引的索引建；</li>
<li>没有主键使用第一个不包含NULL值得唯一列作为聚簇索引的索引键；</li>
<li>都没有情况下，默认生成隐式自助id列作为聚簇索引的索引建；</li>
</ol>
<h2 id="B-tree索引"><a href="#B-tree索引" class="headerlink" title="B+tree索引"></a>B+tree索引</h2><ol>
<li><p>B+tree索引结构（图中叶子节点需改为双向列表）</p>
 <img src="./B+tree.webp" width = "50%" height = "50%" alt="B+tree" align=center />
 
<ol>
<li>多叉树，叶子节点才存放数据，非叶子节点只存放索引，每个节点里的数据是按主键顺序存放的。</li>
<li>叶子节点中包括了所有的索引值信息，有两个指针，分别指向下一个叶子节点和上一个叶子节点，双向链表。</li>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据，二级索引的 B+Tree 的叶子节点存放的是主键值。</li>
<li>在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。</li>
</ol>
</li>
<li><p>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</p>
<ol>
<li><p>B+Tree vs B Tree<br> B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</p>
<p> 另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。B树则需要通过中序遍历才能完成查询范围的查找。</p>
</li>
<li><p>B+Tree vs 二叉树<br> 对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。</p>
<p> 在实际的应用当中， d 值是大于100的，这样就保证了即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</p>
<p> 而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</p>
</li>
<li><p>B+Tree vs Hash<br> Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p>
<p> 但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p>
</li>
</ol>
</li>
<li><p>联合索引的最左匹配原则<br> 按照最左优先的方式进行索引的匹配<br><br> 在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。<br><br> 1. a &gt; 1 and b &gt; 2，从 a &gt; 1 开始扫描<br> 2. a &gt;&#x3D; 1 and b &#x3D; 2，从 a &#x3D; 1 and b &#x3D; 2 开始扫描<br> 3. a between 2 and 8 and b &#x3D; 2，从 a &#x3D; 2 and b &#x3D; 2 开始扫描<br> 4. name like ‘j%’ and age &#x3D; 22，从 name &#x3D; ‘j’ and age &#x3D; 22 开始扫描</p>
</li>
<li><p>索引下推<br> 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
</li>
<li><p>索引是否需要创建</p>
<ol>
<li>需要<ol>
<li>字段有唯一性限制</li>
<li>经常用于where&#x2F;group&#x2F;order by的字段</li>
</ol>
</li>
<li>不需要<ol>
<li>区分度底，某个值出现率超过30%优化器会忽略索引使用全表扫描</li>
<li>不经常用于where&#x2F;group&#x2F;order by的字段</li>
<li>表数据太少</li>
<li>经常更新的字段</li>
</ol>
</li>
</ol>
</li>
<li><p>索引优化</p>
<ol>
<li>前缀索引优化，减少索引字段大小，增加索引页中存储的索引值</li>
<li>覆盖索引优化，查询的字段在二级索引的叶子节点都能找到，减少回表操作</li>
<li>主键索引最好是自增的，插入是追加操作，不需要重新移动数据。否则需要移动数据，会造成页分裂，还会造成大量内存碎片</li>
<li>索引最好设置NOT NULL，统计复杂且占用物理空间</li>
</ol>
</li>
<li><p>索引失效情况</p>
<ol>
<li>左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；(例外情况，查询的字段在二级索引叶子节点（主键+二级索引字段）都能找到，直接全扫描二级索引树)</li>
<li>查询条件中对索引列做了计算、函数、类型转换操作；</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效；</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ol>
</li>
<li><p>explain 查看查询计划</p>
<ol start="0">
<li><p>explain 结果结构</p>
 <img src="./explain结果结构.webp" width = "50%" height = "50%" alt="explain结果结构" align=center />
</li>
<li><p>参数说明<br> a. possible_keys 字段表示可能用到的索引；<br> b. key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；<br> c. key_len 表示索引的长度；<br> d. rows 表示扫描的数据行数。<br> e. type 表示数据扫描类型，我们需要重点看这个。<br> f. extra 额外说明</p>
</li>
<li><p>type 字段参数说明<br> a. All（全表扫描）；<br> b. index（全索引扫描）；<br> c. range（索引范围扫描）；<br> d. ref（非唯一索引扫描）；<br> e. eq_ref（唯一索引扫描）；eq_ref 通常用于多表联查中；<br> f. const（结果只有一条的主键或唯一索引扫描）。const 是与常量进行比较，查询效率会更快；</p>
</li>
</ol>
</li>
</ol>
<h2 id="数据页角度看B-树"><a href="#数据页角度看B-树" class="headerlink" title="数据页角度看B+树"></a>数据页角度看B+树</h2><ol>
<li><p>InnDB 如何存储数据</p>
 <img src="./数据页.webp" width = "50%" height = "50%" alt="数据页" align=center/>

<ol>
<li>InnoDB 的数据是按「数据页」为单位来读写的</li>
<li>InnoDB 数据页的默认大小是 16KB</li>
<li>数据页中的记录按照「主键」顺序组成单向链表，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索</li>
<li>因此，数据页中有一个页目录，起到记录的索引作用</li>
<li>页目录就是由多个槽组成的<br> 槽相当于分组记录的索引，即每组最后一条记录的地址偏移量。我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</li>
<li>槽内的记录数量规定<ol>
<li>第一个分组中的记录只能有 1 条记录；</li>
<li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li>
<li>剩下的分组中记录条数范围只能在 4-8 条之间。</li>
</ol>
</li>
</ol>
</li>
<li><p>B+树如何查询数据</p>
 <img src="./B+树.webp" width = "50%" height = "50%" alt="B+树" align=center/>

<ol>
<li><p>磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要，“矮胖”的B+树数据结构所需要进行的磁盘 I&#x2F;O 次数更少，而且 B+ 树更适合进行关键字的范围查询。</p>
</li>
<li><p>B+树特点</p>
<ol>
<li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ol>
</li>
<li><p>聚簇索引和二级索引<br> 因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p>
<p> 如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</p>
</li>
</ol>
</li>
</ol>
<h2 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h2><p>不单单要从数据结构的角度出发，还要考虑磁盘 I&#x2F;O 操作次数，因为 MySQL 的数据是存储在磁盘中的嘛。</p>
<p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I&#x2F;O，而磁盘 I&#x2F;O 次数越多，所消耗的时间也就越大。</p>
<ol>
<li><p>怎样的索引数据结构是好的<br> MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。</p>
<p> 磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I&#x2F;O 操作会直接读写 8 个扇区。</p>
<p> 由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I&#x2F;O，而磁盘 I&#x2F;O 次数越多，所消耗的时间也就越大。</p>
<p> 所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<pre><code> 1. 能在尽可能少的磁盘的 I/O 操作中完成查询工作；
 2. 要能高效地查询某一个记录，也要能高效地执行范围查找；
</code></pre>
</li>
<li><p>B+ 作为索引的数据结构原因</p>
<ol>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li>
</ol>
</li>
</ol>
<h2 id="MySQL-单表不要超过-2000W-行？"><a href="#MySQL-单表不要超过-2000W-行？" class="headerlink" title="MySQL 单表不要超过 2000W 行？"></a>MySQL 单表不要超过 2000W 行？</h2><ol>
<li><p>假设</p>
<ol>
<li><p>非叶子节点内指向其他页的数量为 x<br> 索引页记录 x &#x3D; (16KB - 1KB) * 1024KB &#x2F; (8B + 4B) ~ 1280 行<br> 索引页记录 x &#x3D; (页大小 - 页头、页号、目录等) * 1024 B &#x2F; (索引行数据&#x3D;索引 + 页号)</p>
</li>
<li><p>叶子节点内能容纳的数据行数为 y<br> 数据页记录 y &#x3D; (16KB - 1KB) * 1KB &#x2F; 1KB ~ 15<br> 数据页记录 y &#x3D; (页大小 - 页头、页号、目录等) * 1024 B &#x2F; (行数据假设1KB)</p>
</li>
<li><p>B+ 数的层数为 z</p>
</li>
<li><p>总记录数 &#x3D; Total &#x3D; x^(z-1) * y</p>
</li>
<li><p>假设 B+ 树是两层<br> z &#x3D; 2， Total &#x3D; （1280 ^1 ）* 15 &#x3D; 19200</p>
</li>
<li><p>假设 B+ 树是三层<br> z &#x3D; 3， Total &#x3D; （1280 ^2） * 15 &#x3D; 24576000 （约 2.45kw）</p>
</li>
<li><p>这正好就是文章开头说的最大行数建议值 2000W。对的，一般 B+ 数的层级最多也就是 3 层。</p>
</li>
</ol>
</li>
<li><p>单行数据变多情况下，建议值减少<br> 我们刚刚在说 Y 的值时候假设的是 1K ，那比如我实际当行的数据占用空间不是 1K , 而是 5K, 那么单个数据页最多只能放下 3 条数据。</p>
<p> 同样，还是按照 z &#x3D; 3 的值来计算，那 Total &#x3D; （1280 ^2） *3 &#x3D; 4915200 （近 500w）</p>
<p> 所以，在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的，而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。</p>
<p> MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。</p>
<p> 但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。</p>
</li>
<li><p>总结</p>
<ol>
<li>MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。</li>
<li>页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。</li>
<li>在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</li>
<li>索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。更多的与单记录数据大小有关，数据越大，页节点越多，整个树层级就会越高。</li>
</ol>
</li>
</ol>
<h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><ol>
<li><p>对索引使用左或者左右模糊匹配<br> 使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 都会造成索引失效。</p>
<p> 因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</p>
</li>
<li><p>对索引使用函数<br> 如果查询条件中对索引字段使用函数，就会导致索引失效。</p>
<p> 因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p> 从 MySQL 8.0 开始，索引特性增加了函数索引</p>
</li>
<li><p>对索引进行表达式计算<br> 失效： where id + 1 &#x3D; 10;<br> 不失效：where id &#x3D; 10 - 1; </p>
</li>
<li><p>对索引隐式类型转换<br> 失效： phone &#x3D; 1300000001; where CAST(phone AS signed int) &#x3D; 1300000001;<br> 不失效： id &#x3D; ‘1’; where id &#x3D; CAST(“1” AS signed int);</p>
<p> 通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p>
<p> 自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</p>
<p> 自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，所以结果应该是 0。</p>
<p> 说明 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。</p>
</li>
<li><p>联合索引非最左匹配<br> 创建了一个 (a, b, c) 联合索引</p>
<ol>
<li><p>有效（顺序无关，优化器调整）</p>
<ol>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ol>
</li>
<li><p>无效</p>
<ol>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ol>
</li>
<li><p>截断<br> where a &#x3D; 1 and c &#x3D; 3</p>
<p> 只使用前面 a 会走索引</p>
<p> mysql5.5在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p>
<p> 从 MySQL 5.6 之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p>
</li>
<li><p>为什么联合索引不遵循最左匹配原则就会失效？<br> 原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p>
</li>
<li><p>WHERE 子句中的 OR<br> 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
</li>
</ol>
</li>
</ol>
<h2 id="MySQL-使用-like-“-x“，索引一定会失效吗？"><a href="#MySQL-使用-like-“-x“，索引一定会失效吗？" class="headerlink" title="MySQL 使用 like “%x“，索引一定会失效吗？"></a>MySQL 使用 like “%x“，索引一定会失效吗？</h2><p>不一定，关键看数据表中的字段。如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type&#x3D;all），而是走全扫描二级索引树(type&#x3D;index)。</p>
<p>只不过没利用索引树的有序性的特点，没有通过查询比较的方式，快速定位到了数据行。</p>
<h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><ol>
<li><p>结论</p>
 <img src="./count比较.webp" width = "50%" height = "50%" alt="count比较" align=center/>
</li>
<li><p>count()是什么<br> 统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。</p>
</li>
<li><p>分析</p>
<ol>
<li><p>表里只有主键索引</p>
<ol>
<li>count(字段)：遍历主键索引，判断字段 !&#x3D; NULL，count++</li>
<li>count(主键字段): 遍历主键索引，判断主键字段 !&#x3D; NULL，count++</li>
<li>count(1): 遍历主键索引, count++</li>
<li>count(*) &#x3D;&#x3D; count(0): 遍历主键索引, count++</li>
</ol>
</li>
<li><p>表里有二级索引</p>
<ol>
<li>count(字段)：遍历主键索引，判断字段 !&#x3D; NULL，count++</li>
<li>count(主键字段): 遍历二级索引，判断主键字段 !&#x3D; NULL，count++</li>
<li>count(1): 遍历二级索引，count++</li>
<li>count(*) &#x3D;&#x3D; count(0): 遍历二级索引，count++</li>
</ol>
</li>
</ol>
</li>
<li><p>小结<br> 所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
</li>
<li><p>为什么要通过遍历的方式来计数？</p>
<ol>
<li><p>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性。</p>
</li>
<li><p>InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。</p>
</li>
<li><p>当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行记录个数的统计。</p>
</li>
</ol>
</li>
<li><p>如何优化 count(*)？<br> 如果对一张大表经常用 count(*) 来做统计，其实是很不好的。</p>
<ol>
<li><p>第一种，近似值<br> 可以使用 show table status 或者 explain 命令来表进行估算。执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是 explain 命令对表 t_order 记录的估算值。</p>
</li>
<li><p>第二种，额外表保存计数值<br> 如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p>
<p> 当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p>
</li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-锁</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E9%94%81/</url>
    <content><![CDATA[<p>MySQL 根据加锁的范围，可以分为全局锁、表级锁和行锁三类。</p>
<span id="more"></span>

<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ol>
<li><p>加解全局锁</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加只读锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables</span><br><span class="line"><span class="comment">-- 断开会话</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局锁应用场景<br> 全局锁主要应用于全库逻辑备份，这样在备份期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
</li>
<li><p>全局锁缺点<br> 如果数据库大，那么备份就会很耗时，那么备份期间业务只能读取数据，而不能进行更新数据，会造成业务停滞。</p>
</li>
<li><p>避免方式<br> 如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
<p> 备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p> 但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
</li>
</ol>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ol>
<li><p>分类</p>
<ol>
<li>表锁</li>
<li>元数据锁</li>
<li>意向锁</li>
<li>AUTO-INC 锁</li>
</ol>
</li>
<li><p>表锁</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表级别共享锁，即读锁</span></span><br><span class="line">lock tables 表名 read</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级别独占锁，即写锁</span></span><br><span class="line">lock tables 表名 write</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables</span><br><span class="line"><span class="comment">-- 断开会话</span></span><br></pre></td></tr></table></figure>

<p> 需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p> 不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。</p>
</li>
<li><p>元数据锁<br> 我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<pre><code> 1. 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
 2. 对一张表做结构变更操作的时候，加的是 MDL 写锁；
</code></pre>
<p> MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。</p>
<p> 那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<pre><code> 1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
 2. 然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
 3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞
</code></pre>
<p> 那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<p> 所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
</li>
<li><p>意向锁<br> 意向锁的目的是为了快速判断表里是否有记录被加锁。</p>
<p> 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</p>
<p> 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</p>
<p> 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p> 而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p> 如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢</p>
</li>
<li><p>AUTO-INC 锁<br> 表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。</p>
<p> 之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的</p>
<p> AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。</p>
<p> 但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p> 因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。</p>
<p> 一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</p>
<p> InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<pre><code> 1. 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
 2. 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
 3. 当 innodb_autoinc_lock_mode = 1：
     1. 普通 insert 语句，自增锁在申请之后就马上释放；
     2. 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；
</code></pre>
<p> 当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题。</p>
<p> 这时可能存在主库两个事务随机插入，而从库是bin log原始语句顺序执行，相对有序。就会造成主从不一致情况。</p>
<p> 要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p>
<p> 所以，当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题。</p>
</li>
</ol>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ol>
<li>分类<ol>
<li><p>Record Lock，记录锁，也就是仅仅把一条记录锁上；</p>
</li>
<li><p>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</p>
</li>
<li><p>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
</li>
<li><p>插入意向锁<br> 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p> 如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p> 插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。</p>
<p> 如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
</li>
</ol>
</li>
</ol>
<h2 id="MySQL-是怎么加锁的？"><a href="#MySQL-是怎么加锁的？" class="headerlink" title="MySQL 是怎么加锁的？"></a>MySQL 是怎么加锁的？</h2><ol>
<li>什么 SQL 语句会加行级锁？<br> 如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对读取的记录加共享锁(S型锁)</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对读取的记录加独占锁(X型锁)</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

 除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。</li>
</ol>
<h2 id="update-没加索引会锁全表？"><a href="#update-没加索引会锁全表？" class="headerlink" title="update 没加索引会锁全表？"></a>update 没加索引会锁全表？</h2><ol>
<li><p>原因<br> InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。</p>
<p> 因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。</p>
<p> 当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。</p>
<p> 在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。</p>
<p> 比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁</p>
<p> 但是，在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。</p>
</li>
<li><p>如何避免这种事故的发生？<br> 我们可以将 MySQL 里的 sql_safe_updates 参数设置为 1，开启安全更新模式。<br> update 语句必须满足如下条件之一才能执行成功：</p>
<pre><code> 使用 where，并且 where 条件中必须有索引列；
 使用 limit；
 同时使用 where 和 limit，此时 where 条件中可以没有索引列；
</code></pre>
<p> delete 语句必须满足以下条件能执行成功：</p>
<pre><code> 同时使用 where 和 limit，此时 where 条件中可以没有索引列；
</code></pre>
<p> 如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 force index([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</p>
</li>
</ol>
<h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h2><p>在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。</p>
<p>有一点要注意的是，在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。</p>
<h2 id="MySQL-死锁了，怎么办？"><a href="#MySQL-死锁了，怎么办？" class="headerlink" title="MySQL 死锁了，怎么办？"></a>MySQL 死锁了，怎么办？</h2><ol>
<li><p>死锁产生<br> 两个不同事务，获取包含相同区间的 next-key 锁，却又在插入或者修改或者删除该区间记录时，被对方的 next-key 锁阻塞，从而导致死锁</p>
<p> 案例中的事务 A 和事务 B 在执行完后 select … for update 语句后都持有范围为(1006,+∞]的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。</p>
<p> 间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。</p>
</li>
<li><p>如何避免死锁？<br> 死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p>
<p> 设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。</p>
<p> 开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。</p>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/%E5%AD%98%E5%82%A8/mysql/</url>
    <content><![CDATA[<p>MySQL是目前应用最广泛的开源关系数据库。</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="centos7-安装MySQL"><a href="#centos7-安装MySQL" class="headerlink" title="centos7 安装MySQL"></a>centos7 安装MySQL</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 检查mariadb --&gt;</span><br><span class="line">rpm -qa|grep mariadb</span><br><span class="line">&lt;!-- 如有则按如下删除 --&gt;</span><br><span class="line">rpm -e --nodeps mariadb-server</span><br><span class="line">rpm -e --nodeps mariadb</span><br><span class="line">rpm -e --nodeps mariadb-libs</span><br><span class="line">&lt;!-- 检查mysql --&gt;</span><br><span class="line">rpm -qa|grep mysql</span><br><span class="line">&lt;!-- 存在则按如下删除 --&gt;</span><br><span class="line">rpm -e --nodeps 【xxx】</span><br><span class="line">&lt;!-- mysql yum源下载官网地址 --&gt;</span><br><span class="line">https://dev.mysql.com/downloads/repo/yum/</span><br><span class="line">&lt;!-- 根据自己系统版本选择 --&gt;</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">&lt;!-- centos7 选择如下 --&gt;</span><br><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el7-7.noarch.rpm</span><br><span class="line">&lt;!-- 安装mysql源 --&gt;</span><br><span class="line">rpm -Uvh mysql80-community-release-el7-7.noarch.rpm</span><br><span class="line">&lt;!-- 检查是否安装成功，是否有mysql-community.repo及 mysql-community-source.repo --&gt;</span><br><span class="line">ll /etc/yum.repos.d/</span><br><span class="line">&lt;!-- 查看源中的mysql版本 --&gt;</span><br><span class="line">yum repolist all | grep mysql</span><br><span class="line">&lt;!-- 切换mysql版本 --&gt;</span><br><span class="line">yum-config-manager --disable mysql80-community</span><br><span class="line">yum-config-manager --enable mysql57-community</span><br><span class="line">&lt;!-- 检查当前启用的mysql仓库 --&gt;</span><br><span class="line">yum repolist enabled | grep mysql</span><br><span class="line">&lt;!-- 安装mysql --&gt;</span><br><span class="line">sudo yum -y install mysql-community-server</span><br><span class="line">&lt;!-- 会安装如下 --&gt;</span><br><span class="line">mysql-community-server</span><br><span class="line">mysql-community-client</span><br><span class="line">mysql-community-common</span><br><span class="line">mysql-community-libs</span><br><span class="line">numactl-libs</span><br><span class="line">&lt;!-- 启动mysql --&gt;</span><br><span class="line">sydo systemctl start mysqld.service</span><br><span class="line">&lt;!-- 查看状态 --&gt;</span><br><span class="line">sudo systemctl status mysqld.service</span><br><span class="line">&lt;!-- 停止mysql --&gt;</span><br><span class="line">sudo systemctl stop mysqld.service</span><br><span class="line">&lt;!-- 重启mysql --&gt;</span><br><span class="line">sudo systemctl restart mysqld.service</span><br><span class="line">&lt;!-- 初始密码，MySQL第一次启动后会创建超级管理员账号root@localhost，初始密码存储在日志文件中 --&gt;</span><br><span class="line">sudo grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br><span class="line">&lt;!-- 修改密码 --&gt;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;jesonlin&#x27;;</span><br><span class="line">&lt;!-- 关闭验证密码复杂度策略 --&gt;</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">&lt;!-- 添加如下并重启 --&gt;</span><br><span class="line">validate_password=OFF</span><br><span class="line">&lt;!-- 运行远程访问 --&gt;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;jesonlin&#x27; WITH GRANT OPTION;</span><br><span class="line">&lt;!-- 查看并修改字符集 --&gt;</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-client-handshake=FALSE</span><br><span class="line">character_set_server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_unicode_ci</span><br><span class="line">init-connect=&#x27;SET NAMES utf8mb4&#x27;</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">&lt;!-- 重启并检查设置效果 --&gt;</span><br><span class="line">SHOW VARIABLES WHERE Variable_name LIKE &#x27;character_set_%&#x27; OR Variable_name LIKE &#x27;collation%&#x27;;</span><br><span class="line">&lt;!-- 设置开机启动 --&gt;</span><br><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="centos8安装mysql"><a href="#centos8安装mysql" class="headerlink" title="centos8安装mysql"></a>centos8安装mysql</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 前面下载yum源步骤同上，官方源里只有mysql8版本，需要手动修改源 --&gt;</span><br><span class="line">&lt;!-- 修改mysql-community.repo --&gt;</span><br><span class="line">vim /etc/yum.repos.d/mysql-community.repo</span><br><span class="line">&lt;!-- 添加如下 --&gt;</span><br><span class="line">[mysql57-community]</span><br><span class="line">name=MySQL 5.7 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br><span class="line">&lt;!-- 禁止mysql8 --&gt;</span><br><span class="line">yum-config-manager --disable mysql80-community</span><br><span class="line">&lt;!-- 核对输出 --&gt;</span><br><span class="line">yum repolist enabled | grep mysql</span><br><span class="line">&lt;!-- 失能模块 --&gt;</span><br><span class="line">yum module disable mysql</span><br><span class="line">&lt;!-- 安装 --&gt;</span><br><span class="line">yum install mysql-community-server</span><br><span class="line">&lt;!-- 启动mysql --&gt;</span><br><span class="line">systemctl start mysqld.service</span><br><span class="line">&lt;!-- 其他步骤同上 --&gt;</span><br><span class="line">&lt;!-- 修改密码有报错执行下面 --&gt;</span><br><span class="line">flush privileges;</span><br><span class="line">&lt;!-- 重启失败，发现不能添加如下语句 --&gt;</span><br><span class="line">validate_password=OFF</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="docker-安装启动mysql5-7"><a href="#docker-安装启动mysql5-7" class="headerlink" title="docker 安装启动mysql5.7"></a>docker 安装启动mysql5.7</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -p 3307:3306 --name mysql -v /data/service/docker/mysql/logs:/var/log/mysql -v /data/service/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=jesonlin -d mysql:5.7</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="跳过密码登录数据库"><a href="#跳过密码登录数据库" class="headerlink" title="跳过密码登录数据库"></a>跳过密码登录数据库</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 设置MYSQLD_OPTS --&gt;</span><br><span class="line">systemctl set-environment MYSQLD_OPTS=&quot;--skip-grant-tables&quot;;</span><br><span class="line">&lt;!-- 显示mysql环境变量 --&gt;</span><br><span class="line">systemctl show-environment</span><br><span class="line">&lt;!-- 撤销mysql环境变量 --&gt;</span><br><span class="line">systemctl unset-environment MYSQLD_OPTS;</span><br><span class="line">&lt;!-- 重启，脚本里有用到该参数  --&gt;</span><br><span class="line">systemctl restart mysqld.service </span><br></pre></td></tr></table></figure>
</code></pre>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><ol>
<li>创建用户 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;[用户名]&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;[密码]&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>授予权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    GRANT ALL PRIVILEGES ON `[DB]`.* TO &#x27;[用户名]&#x27;@&#x27;[host]&#x27;;</span><br><span class="line">    ```  </span><br><span class="line">3. 删除用户</span><br></pre></td></tr></table></figure>
 drop user [用户名]@’%’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 删除权限</span><br></pre></td></tr></table></figure>
 revoke all on [DB].* from ‘[用户名]‘@’[host]’;<br> Delete from mysql.user where user &#x3D; ‘[用户名]’ and host &#x3D; ‘[host]’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 改密码</span><br></pre></td></tr></table></figure>
 mysqladmin -uroot -p[旧密码] password [新密码]<br> set password for [用户名]@[host] &#x3D; password([新密码]);<br> update mysql.user set authentication_string&#x3D;password(‘新密码’) where user&#x3D;’用户名’ and Host &#x3D;’localhost’;<br> flush privileges; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 库表操作</span><br><span class="line">0. 启动、重启、停止</span><br></pre></td></tr></table></figure>
 systemctl start&#x2F;restart&#x2F;stop mysqld.service <!-- 查看启动状态 -->
 systemctl status mysqld.service <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建数据库</span><br></pre></td></tr></table></figure>
 create database [DB] if not exists [DB] default charset utf8mb4 collate utf8mb4_unicode_ci; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 创建数据表</span><br></pre></td></tr></table></figure>
 CREATE TABLE <code>[表名]</code> (<br>   <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘自增ID’,<br>   <code>name</code> varchar(32) NOT NULL COMMENT ‘名称’,<br>   <code>comment</code> varchar(255) NOT NULL COMMENT ‘备注’,<br>   <code>create_time</code> datetime DEFAULT CURRENT_TIMESTAMP COMMENT ‘创建时间’,<br>   <code>update_time</code> datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘更新时间’,<br>   PRIMARY KEY (<code>id</code>),<br>   KEY <code>idx_name</code> (<code>name</code>),<br> ) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;0 DEFAULT CHARSET&#x3D;utf8mb4 COMMENT &#x3D; ‘业务信息’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 插入数据</span><br></pre></td></tr></table></figure>
 insert into [表名] (id, name, comment) values (null, ‘’, ‘’); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 拷贝表结构</span><br></pre></td></tr></table></figure>
 create table [新表名] like [旧表名] <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 拷贝数据</span><br></pre></td></tr></table></figure>
 insert into [新表名] select * from [旧表名] <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. 导入导出数据库</span><br></pre></td></tr></table></figure>
 mysqldump -h[IP] –set-gtid-purged&#x3D;off -uroot -p[PASSWORD] –databases [DB] &gt; [DB].sql<br> mysql -h[IP] -uroot -p[PASSWORD] &lt; [DB].sql <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. 数据库大小</span><br></pre></td></tr></table></figure>
 select (sum(DATA_LENGTH)+sum(INDEX_LENGTH))&#x2F;1024&#x2F;1024&#x2F;1024 from information_schema.TABLES where TABLE_SCHEMA&#x3D;’[DB]’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. 数据库每个表大小</span><br></pre></td></tr></table></figure>
 SELECT TABLE_NAME, DATA_LENGTH&#x2F;1024&#x2F;1024&#x2F;1024, INDEX_LENGTH&#x2F;1024&#x2F;1024&#x2F;1024 FROM information_schema.TABLES WHERE TABLE_SCHEMA&#x3D;’[DB]’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. 数据表大小</span><br></pre></td></tr></table></figure>
 SELECT count(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA&#x3D;’[DB]’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10. 查询表创建和更新时间</span><br></pre></td></tr></table></figure>
 select * from information_schema.tables where information_schema.tables.TABLE_SCHEMA&#x3D;’[DB]’ and information_schema.tables.TABLE_NAME&#x3D;’[TB]’\G; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. 添加表字段</span><br></pre></td></tr></table></figure>
 alter table [TB] add [FIELD] int(11) unsigned default 0 comment “id”; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12. 到出到本地csv</span><br></pre></td></tr></table></figure>
 mysql –host&#x3D;[HOST] –user&#x3D;[USER] –password&#x3D;[PASSWORD] -se “SELECT * FROM [DB].[TB]” | sed ‘s&#x2F;\t&#x2F;“,”&#x2F;g;s&#x2F;^&#x2F;“&#x2F;;s&#x2F;$&#x2F;“&#x2F;;s&#x2F;\n&#x2F;&#x2F;g’ &gt; app.csv <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 字段操作</span><br><span class="line">1. 修改表字段类型：  </span><br></pre></td></tr></table></figure>
 alter table [TB] modify 字段名 varchar(20); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 增加表字段：  </span><br></pre></td></tr></table></figure>
 alter table [TB] add column age int(3); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 增加表字段时控制顺序（或者使用first）：  </span><br></pre></td></tr></table></figure>
 alter table [TB] add column age int(3) after [旧字段名]; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 删除表字段：  </span><br></pre></td></tr></table></figure>
 alter table [TB] drop [字段名]; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 修改表字段名：  </span><br></pre></td></tr></table></figure>
 alter table [TB] change [字段原名] [字段新名] [字段类型]; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 索引</span><br><span class="line">1. 普通索引</span><br></pre></td></tr></table></figure>
 alter table 表 add idnex(字段); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 唯一索引</span><br></pre></td></tr></table></figure>
 alter table 表 add unique(字段); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 全文索引</span><br></pre></td></tr></table></figure>
 alter table 表 add fulltext(字段); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 主键索引</span><br></pre></td></tr></table></figure>
 alter table 表 add primary key(字段); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看任务及其状态</span><br><span class="line">1. 查看任务及其状态 </span><br><span class="line">    ```sql</span><br><span class="line">    show full processlist;</span><br></pre></td></tr></table></figure></li>
<li>过滤掉Sleep链接 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pager grep <span class="operator">-</span>v Sleep</span><br></pre></td></tr></table></figure></li>
<li>结束单个任务 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">    kill Id</span><br><span class="line">    ```<span class="keyword">sql</span></span><br><span class="line"><span class="number">4.</span> 批量结束任务</span><br><span class="line">    ```<span class="keyword">sql</span></span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">&#x27;kill &#x27;</span>,id,<span class="string">&#x27;;&#x27;</span>) <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> info <span class="keyword">like</span> <span class="string">&#x27;%INSERT INTO `log`%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>查看和修改最大连接 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%max_connections%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> max_connections <span class="operator">=</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><ol>
<li>配置变量查看和修改 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%max_allowed_packet%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> max_allowed_packet<span class="operator">=</span><span class="number">1073741824</span>;</span><br></pre></td></tr></table></figure></li>
<li>查看和修改引擎 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">select</span> CONCAT(<span class="string">&#x27;alter table &#x27;</span>, table_schema, <span class="string">&#x27;.&#x27;</span>, table_name,<span class="string">&#x27; engine=InnoDB;&#x27;</span>) <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>&quot;interface_manage&quot; <span class="keyword">AND</span> ENGINE<span class="operator">=</span>&quot;MyISAM&quot;;    </span><br></pre></td></tr></table></figure></li>
<li>统计每天任务量 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),DATE_FORMAT(FROM_UNIXTIME(<span class="type">time</span>), <span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="keyword">AS</span> t <span class="keyword">from</span> [TB] <span class="keyword">WHERE</span> DATE_FORMAT(FROM_UNIXTIME(<span class="type">time</span>), <span class="string">&#x27;%Y&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;2020&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> t</span><br></pre></td></tr></table></figure></li>
<li>批量删除符合某些字符串的数据表 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以下拼接结果有长度限制，可重复多次得到结果</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT( <span class="string">&#x27;DROP TABLE &#x27;</span>, GROUP_CONCAT(table_name) , <span class="string">&#x27;;&#x27;</span> ) <span class="keyword">AS</span> statement <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema <span class="operator">=</span> [DB] <span class="keyword">AND</span> table_name <span class="keyword">LIKE</span> <span class="string">&#x27;[TB]%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 将拼接得到的结果执行删除</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">廖雪峰SQL教程</a><br><a href="https://juejin.cn/post/6844903870053761037">cenos安装mysql</a><br><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>process-thread</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/process-thread/</url>
    <content><![CDATA[<p>运行中的程序，就被称为「进程」（Process）。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>进程<ol>
<li>进程的概念</li>
<li>进程的状态</li>
<li>进程的控制结构</li>
<li>进程的控制</li>
<li>进程的上下文切换</li>
</ol>
</li>
<li>线程<ol>
<li>为什么使用线程？</li>
<li>什么是线程？</li>
<li>线程与进程的比较</li>
<li>线程的上下文切换</li>
<li>线程的实现</li>
</ol>
</li>
<li>调度<ol>
<li>调度时机</li>
<li>调度原则</li>
<li>调度算法</li>
</ol>
</li>
</ol>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol>
<li><p>进程的概念<br> 运行中的程序，就被称为「进程」（Process）。</p>
<p> 对于一个支持多进程的系统，CPU 会从一个进程快速切换至另一个进程，其间每个进程各运行几十或几百个毫秒。</p>
<p> 虽然单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是并发。</p>
<p> 并发vs并行：并发是单核处理器快速交替执行多个进程，并行是多核处理器分别执行各自的进程。</p>
 <img src="./并发与并行.webp" width = "50%" height = "50%" alt="并发与并行" align=center />

<p> 试试就试试</p>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B">进程管理</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/</url>
    <content><![CDATA[<p>Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。</p>
<span id="more"></span>


<h2 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;文档注释</span><br><span class="line"></span><br><span class="line">文档功能描述</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Jeson Lin&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SampleClass(object):</span><br><span class="line">    &quot;&quot;&quot;类功能</span><br><span class="line"></span><br><span class="line">    类功能详细描述</span><br><span class="line"></span><br><span class="line">    Attributes:</span><br><span class="line">        attr1: 属性1描述</span><br><span class="line">        attr2: 属性2描述</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, attr1=False):</span><br><span class="line">        &quot;&quot;&quot;初始化 SampleClass 用attr1&quot;&quot;&quot;</span><br><span class="line">        self.attr1 = attr1</span><br><span class="line">        self.attr2 = 0</span><br><span class="line"></span><br><span class="line">    def _inner_methon(self):</span><br><span class="line">        &quot;&quot;&quot;类内自身调用方法&quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def public_method(self):</span><br><span class="line">        &quot;&quot;&quot;公共方法&quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sample_function(param1: str, param2: &#x27;int &gt; 0&#x27;, param3: bool = False) -&gt; dict:</span><br><span class="line">    &quot;&quot;&quot;函数功能</span><br><span class="line"></span><br><span class="line">    函数功能详细描述</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        param1: 参数1说明。</span><br><span class="line">        param2: 参数2说明。</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        返回值描述</span><br><span class="line">        example:</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            &quot;a&quot;: 1,</span><br><span class="line">            &quot;b&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        返回详细描述</span><br><span class="line"></span><br><span class="line">    Raises:</span><br><span class="line">        IOError: 异常描述</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 函数功能逻辑</span><br><span class="line">    pass</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;hello, world&#x27;)</span><br></pre></td></tr></table></figure>


<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><ol>
<li>centos <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y python36</span><br><span class="line">ln -s python3.6 python3</span><br><span class="line">yum install -y python36-setuptools</span><br><span class="line">easy_install pip </span><br></pre></td></tr></table></figure></li>
<li>mac <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 官网下载安装包</span><br><span class="line">https://www.python.org/downloads/</span><br><span class="line"></span><br><span class="line"># 安装了Homebrew</span><br><span class="line">brew install python3</span><br></pre></td></tr></table></figure></li>
<li>解释器<br> 安装python后，命令行运行<code>python</code>启动python交互解释器。  <ol>
<li>CPython<br> 用<code>&gt;&gt;&gt;</code>作为提示符，用C语言开发</li>
<li>IPython<br> 用<code>In [序号]:</code>作为提示符，基于CPython之上，增强交互。</li>
<li>PyPy<br> PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。需要了解PyPy和CPython的不同点。</li>
<li>Jython<br> Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</li>
</ol>
</li>
<li>Shebang<ol>
<li>在计算机科学中，Shebang (也称为Hashbang)是一个由井号和叹号构成的字符串行(<code>#!</code>)，其出现在文本文件的第一行的前两个字符。  </li>
<li>在文件中存在Shebang的情况下， 类Unix操作系统的程序载入器会分析Shebang后的内容，将这些内容作为解释器指令， 并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。  </li>
<li>例如，以指令<code>#!/bin/sh</code>开头的文件在执行时会实际调用<code>/bin/sh 程序</code>。)</li>
</ol>
</li>
</ol>
<h2 id="虚拟环境-virtualenv"><a href="#虚拟环境-virtualenv" class="headerlink" title="虚拟环境-virtualenv"></a>虚拟环境-virtualenv</h2><ol>
<li>升级pip <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 升级pip</span><br><span class="line">python3 -m pip install --upgrade --force-reinstall pip</span><br><span class="line"></span><br><span class="line"># pip 位置变成/usr/local/bin/pip</span><br><span class="line">which pip</span><br><span class="line"></span><br><span class="line"># pip 缓存没更新/usr/bin/pip</span><br><span class="line">type pip</span><br><span class="line"></span><br><span class="line"># 更新缓存</span><br><span class="line">hash -r</span><br></pre></td></tr></table></figure></li>
<li>安装virtualenv <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">pip install virtualenv</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">virtualenv --version</span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line">mkdir project_virtualenv</span><br><span class="line">cd project_virtualenv</span><br><span class="line">virtualenv venv</span><br><span class="line"></span><br><span class="line"># 激活虚拟环境</span><br><span class="line">source venv/bin/activate</span><br><span class="line"></span><br><span class="line"># 虚拟环境安装python包</span><br><span class="line">pip install requests</span><br><span class="line"></span><br><span class="line"># 虚拟环境查看安装包</span><br><span class="line">pip freeze</span><br><span class="line"></span><br><span class="line"># 虚拟环境导出已安装包</span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"># 根据requirements.txt重新安装所有包</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"># 退出虚拟环境</span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li>编码和字符串<ol>
<li><code>ASCII</code>：1个字节，能表示最大整数是2^8-1&#x3D;255。</li>
<li><code>Unicode</code>：2个字节，能表示最大整数是2^16-1&#x3D;65535。</li>
<li><code>UTF-8</code>：1-6个字节，可变长编码，英文字母1个字节，汉字3个字节，很生僻字符4~6个字节，基于传输存储空间节约角度。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Python 3版本中，字符串是以Unicode编码的</span><br><span class="line"></span><br><span class="line"># 字符对应的整数</span><br><span class="line">ord(&#x27;A&#x27;)</span><br><span class="line"></span><br><span class="line"># 整数对应的字符</span><br><span class="line">chr(66)</span><br><span class="line"></span><br><span class="line"># 二进制</span><br><span class="line">x = b&#x27;ABC&#x27;</span><br><span class="line"></span><br><span class="line"># str转ascii(bytes)</span><br><span class="line">&#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)</span><br><span class="line"></span><br><span class="line"># str转utf-8(bytes)</span><br><span class="line">&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line"># bytes转str，用errors忽略无法解码的字节</span><br><span class="line">b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)</span><br><span class="line">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)</span><br><span class="line"></span><br><span class="line"># 格式化字符串三种方式</span><br><span class="line">str1 = &#x27;Age: %s. Gender: %s, rate: %.2f&#x27; % (25, True, 6.186)</span><br><span class="line">str2 = &#x27;Age: &#123;0&#125;. Gender: &#123;1&#125;, rate: &#123;2:.2f&#125;&#x27;.format(25, True, 6.186)</span><br><span class="line">rate=6.186</span><br><span class="line">str3 = f&#x27;Age: &#123;25&#125;. Gender: &#123;True&#125;, rate: &#123;rate:.2f&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>list和tuple <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># list 可变，如下方法</span><br><span class="line">append(元素)</span><br><span class="line">insert(位置, 元素)</span><br><span class="line">pop()  # 弹出最后一个</span><br><span class="line">pop(0)  # 弹出第一个</span><br><span class="line"></span><br><span class="line"># tuple 指向不可变</span><br><span class="line">t = (1,)  # tuple定义一个元素</span><br></pre></td></tr></table></figure></li>
<li>dict和set <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dict 删除</span><br><span class="line">A = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;</span><br><span class="line">A.pop(&#x27;c&#x27;, None)  # key不存在不报错</span><br><span class="line"></span><br><span class="line"># set 删除</span><br><span class="line">A = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;</span><br><span class="line">A.remove(&#x27;d&#x27;)  # key不存在报错</span><br><span class="line">A.discard(&#x27;d&#x27;)  # key不存在不报错</span><br><span class="line"></span><br><span class="line"># set 交集、并集、差集</span><br><span class="line">&amp;、|、-</span><br></pre></td></tr></table></figure></li>
<li>生成器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成器1-()</span><br><span class="line">g = (x * x for x in range(10))</span><br><span class="line"></span><br><span class="line"># 迭代</span><br><span class="line">next(g)</span><br><span class="line"># 或</span><br><span class="line">for x in g:</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"># e.g. 斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</span><br><span class="line">def fibonacci(N):</span><br><span class="line">    a, b, n = 0, 1, 0</span><br><span class="line">    while n &lt; N:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n += 1</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"># 生成器2-yield</span><br><span class="line">def fibonacci(N):</span><br><span class="line">    a, b, n = 0, 1, 0</span><br><span class="line">    while n &lt; N:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n += 1</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ol>
<li>高阶函数-map&#x2F;reduce&#x2F;filter&#x2F;sorted<ol>
<li>map <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map(func, iterable)</span><br><span class="line"></span><br><span class="line"># e.g.</span><br><span class="line">list(map(str, [1, 2, 3, 4]))</span><br></pre></td></tr></table></figure></li>
<li>reduce <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reduce(func, iterable)</span><br><span class="line"></span><br><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br><span class="line"></span><br><span class="line"># e.g. 正整数字符串转正整数</span><br><span class="line">from functools import reduce</span><br><span class="line">def str2int(s):</span><br><span class="line">    return reduce(lambda x, y: x * 10 + y, map(lambda x: ord(x) - ord(&#x27;0&#x27;), s))</span><br></pre></td></tr></table></figure></li>
<li>filter <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter(func, iterable)</span><br><span class="line"></span><br><span class="line"># e.g. 保留list中的奇数</span><br><span class="line">list(filter(lambda x: x % 2 == 1, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"></span><br><span class="line"># e.g. 保留list中的非空字符串</span><br><span class="line">list(filter(lambda x: x and x.strip(), [&#x27;A&#x27;, &#x27;&#x27;, &#x27;B&#x27;, None, &#x27;C&#x27;, &#x27;  &#x27;]))</span><br></pre></td></tr></table></figure></li>
<li>sorted <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sorted(iterable, key=abs)</span><br><span class="line"></span><br><span class="line"># e.g. 绝对值排序</span><br><span class="line">sorted([36, 5, -12, 9, -21], key=abs)</span><br><span class="line"></span><br><span class="line"># e.g. 默认按ascii大小排序</span><br><span class="line">sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;])</span><br><span class="line"># 等价于</span><br><span class="line">sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str)</span><br><span class="line"></span><br><span class="line"># 忽略大小写排序</span><br><span class="line">sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str.lower)</span><br><span class="line"></span><br><span class="line"># 反向排序加参数reverse=True</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>返回函数-返回的是一个函数，闭包<ol>
<li>单个函数返回 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x7f4f9c8c3730&gt;</span><br><span class="line"></span><br><span class="line"># f实际是返回的sum函数定义+参数，调用f()才真正执行</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">25</span><br></pre></td></tr></table></figure></li>
<li>多个函数返回 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    # 循环3次，fs = [func1+i, func2+i, func3+i]</span><br><span class="line">    # 最终返回是把i变成最后迭代完的3</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"># 所以</span><br><span class="line">f1() == f2() == f3() == 9</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>匿名函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = lambda x: x * x</span><br></pre></td></tr></table></figure></li>
<li>装饰器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&#x27;%s %s():&#x27; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@log(&#x27;execute&#x27;)</span><br><span class="line">def now():</span><br><span class="line">    print(&quot;2020-02-02&quot;)</span><br><span class="line"></span><br><span class="line"># 等价于</span><br><span class="line">now = log(&#x27;execute&#x27;)(now)</span><br></pre></td></tr></table></figure></li>
<li>偏函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把一个函数的某些参数给固定住</span><br><span class="line">import functools</span><br><span class="line">func_new = functools.partial(func, *args, **kw)</span><br><span class="line"></span><br><span class="line"># 自动替换默认参数的值</span><br><span class="line">func_new = functools.partial(func, args1=默认值)</span><br><span class="line"></span><br><span class="line"># 将默认值放在函数最左边</span><br><span class="line">func_new = functools.partial(func, 默认值)</span><br><span class="line"></span><br><span class="line"># 参数展开</span><br><span class="line">func_new = functools.partial(func, &#123;arg1:默认值&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol>
<li>结构 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mycompany  # 包名</span><br><span class="line">├─ __init__.py  # 有这个文件才是包目录，本身就是模块，模块名是mycompany</span><br><span class="line">├─ abc.py  # 模块名是文件名mycompany.abc</span><br><span class="line">└─ xyz.py  # 模块名是mycompanyxyz</span><br></pre></td></tr></table></figure></li>
<li>使用<br> 当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure></li>
<li>安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ol>
<li>类和实例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    </span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score  # 私有变量，不能直接访问</span><br><span class="line">            </span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if 0 &lt;= score &lt;= 100:</span><br><span class="line">            self.__score = score</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#x27;bad score&#x27;)</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    def get_grade(self):</span><br><span class="line">        if self.__score &gt;= 90:</span><br><span class="line">            return &#x27;A&#x27;</span><br><span class="line">        elif self.__score &gt;= 60:</span><br><span class="line">            return &#x27;B&#x27;</span><br><span class="line">        else:</span><br><span class="line">            return &#x27;C&#x27;</span><br><span class="line"></span><br><span class="line">stu1 = Student(&#x27;jesonlin&#x27;, 99)</span><br></pre></td></tr></table></figure></li>
<li>继承和多态<ol>
<li>类的定义<br> 当我们定义一个class的时候，我们实际上就定义了一种数据类型。</li>
<li>继承<br> 子类继承父类的全部功能，同名功能则覆盖父类功能。</li>
<li>多态<br> 同名功能则覆盖父类功能，父类参数可用子类实例。</li>
<li>开闭原则<br> 对扩展开放，允许增加子类；对修改封闭，不需要修改父类函数，只需要修改新增子类函数。有点动态绑定意思。</li>
<li>鸭子类型<br> 静态语言的父类参数对象必须是父类实例或者子类实例；而动态语言则只要子类有对应方法即可，不一定要求是继承自该父类。这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</li>
</ol>
</li>
<li>类型判断 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isinstance([1, 2, 3], list)</span><br><span class="line">isinstance((1, 2, 3), (list, tuple))</span><br><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">person = Person()</span><br><span class="line">isinstance(person, Person)</span><br></pre></td></tr></table></figure></li>
<li>属性&#x2F;方法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取所有属性和方法</span><br><span class="line">dir(&#x27;ABC&#x27;)</span><br><span class="line"></span><br><span class="line"># __xxx__的属性和方法在Python中都是有特殊用途的</span><br><span class="line">len(&#x27;ABC&#x27;) == &#x27;ABC&#x27;.__len__()</span><br><span class="line"></span><br><span class="line"># 判断属性或方法</span><br><span class="line">hasattr(person, &#x27;x&#x27;)</span><br><span class="line"></span><br><span class="line"># 获取属性或方法</span><br><span class="line">getattr(person, &#x27;z&#x27;, &#x27;不存在&#x27;)</span><br><span class="line"></span><br><span class="line"># 设置属性</span><br><span class="line">setattr(person, &#x27;y&#x27;)</span><br><span class="line"></span><br><span class="line"># 定义方法</span><br><span class="line">def set_name(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line"># 设置类方法</span><br><span class="line">Person.set_name = set_name</span><br><span class="line"></span><br><span class="line"># 设置实例方法</span><br><span class="line">from types import MethodType</span><br><span class="line">person.set_name = MethodType(set_name, person)</span><br><span class="line"></span><br><span class="line"># 限制类属性-仅对当前类实例起作用，子类不起左右，即子类没有继承__slots__</span><br><span class="line">class Student(object):</span><br><span class="line">    # 用tuple定义允许绑定的属性名称</span><br><span class="line">    __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;)</span><br><span class="line"></span><br><span class="line"># 方法用属性方式调用，@property</span><br><span class="line"> def Student(object):</span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&#x27;score must be an integer!&#x27;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&#x27;score must between 0 ~ 100!&#x27;)</span><br><span class="line">        self._score = value</span><br><span class="line">s = Student()</span><br><span class="line">s.score = 99  # 实际转换为s.set_score(99)</span><br><span class="line">s.score  # 实际转换为s.get_score()</span><br></pre></td></tr></table></figure></li>
<li>多重继承<br> 若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索。即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li>
<li>定制类 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 限制当前类对象属性</span><br><span class="line">__slots__</span><br><span class="line"></span><br><span class="line"># 作用len(实例)</span><br><span class="line">__len__()</span><br><span class="line"></span><br><span class="line"># print打印类</span><br><span class="line">__str__()</span><br><span class="line"></span><br><span class="line"># 直接打印类</span><br><span class="line">__repr__()</span><br><span class="line"></span><br><span class="line"># 类似列表迭代</span><br><span class="line">__iter__()</span><br><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a # 返回下一个值</span><br><span class="line">for n in Fib():</span><br><span class="line">    print(n)</span><br><span class="line">    </span><br><span class="line"># 类似列表取值</span><br><span class="line">__getitem__()</span><br><span class="line">class Fib(object):</span><br><span class="line">def __getitem__(self, n):</span><br><span class="line">    a, b = 1, 1</span><br><span class="line">    for x in range(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    return a</span><br><span class="line">f = Fib()</span><br><span class="line">f[1]</span><br><span class="line"></span><br><span class="line"># 类似列表切片</span><br><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        if isinstance(n, int): # n是索引</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            for x in range(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return a</span><br><span class="line">        if isinstance(n, slice): # n是切片</span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            if start is None:</span><br><span class="line">                start = 0</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            L = []</span><br><span class="line">            for x in range(stop):</span><br><span class="line">                if x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return </span><br><span class="line">f = Fib()</span><br><span class="line">f[0:5]</span><br></pre></td></tr></table></figure></li>
<li>枚举类 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line"># Month类继承Enum，有()成员属性，mth是类实例</span><br><span class="line">mth = Enum(&#x27;Month&#x27;, (&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;))</span><br><span class="line"># value属性则是自动赋给成员的int常量，默认从1开始计数。</span><br><span class="line">for name, member in mth.__members__.items():</span><br><span class="line">    print(name, &#x27;=&gt;&#x27;, member, &#x27;,&#x27;, member.value)</span><br><span class="line"></span><br><span class="line">@unique  # 装饰器可以帮助我们检查保证没有重复值。</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br><span class="line"></span><br><span class="line">Weekday.Sun == Weekday[&#x27;Sun&#x27;]</span><br><span class="line">&lt;Weekday.Sun: 0&gt;  # 返回形式</span><br><span class="line">Weekday.Sun.value</span><br><span class="line">0  # 返回形式</span><br><span class="line">for name, member in Weekday.__members__.items():</span><br><span class="line">    print(name, &#x27;=&gt;&#x27;, member)</span><br><span class="line">for name, member in Weekday.__members__.items():</span><br><span class="line">    print(name, &#x27;=&gt;&#x27;, member.value)</span><br></pre></td></tr></table></figure></li>
<li>元类 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># class的type类型就是type</span><br><span class="line">type(Person)</span><br><span class="line"></span><br><span class="line"># 通过type创建Hello类</span><br><span class="line"># 类名，父类的元组形式，方法名称与函数绑定</span><br><span class="line">Hello = type(&#x27;Hello&#x27;, (object,), dict(hello=fn)) # 创建Hello class</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="IO-编程"><a href="#IO-编程" class="headerlink" title="IO 编程"></a>IO 编程</h2><ol>
<li>文件读写 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 读取utf-8文本文件</span><br><span class="line">with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    # 打印全部</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line">    # 按行打印</span><br><span class="line">    for line in f.readlines():</span><br><span class="line">        print(line.strip()) # 把末尾的&#x27;\n&#x27;删掉</span><br><span class="line"></span><br><span class="line"># 读取二进制文件如图片、视频</span><br><span class="line">with open(&#x27;/path/to/file&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line"># 非UTF-8编码的文本文件</span><br><span class="line">with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;, errors=&#x27;ignore&#x27;) as f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line"># 写入文件，追加用&#x27;a&#x27;</span><br><span class="line">with open(&#x27;/path/to/file&#x27;, &#x27;w&#x27;, encoding=&#x27;UTF-8&#x27;) as f:</span><br><span class="line">    f.write(&#x27;Hello, world!&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>内存读写 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from io import StringIO</span><br><span class="line">f = StringIO()</span><br><span class="line">f.write(&#x27;hello&#x27;)  # 返回5</span><br><span class="line">f.write(&#x27; &#x27;)  # 返回1</span><br><span class="line">f.write(&#x27;world!&#x27;)  # 返回6</span><br><span class="line">print(f.getvalue())  # 返回hello world!</span><br><span class="line"></span><br><span class="line">from io import BytesIO</span><br><span class="line">f = BytesIO()</span><br><span class="line">f.write(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))  # 返回6表示6个字节</span><br><span class="line">print(f.getvalue())  # 返回b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br></pre></td></tr></table></figure></li>
<li>操作文件和目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">os.name  # 操作系统类型</span><br><span class="line">os.uname  # 详细的系统信息</span><br><span class="line">os.environ  # 环境变量</span><br><span class="line">os.environ.get(&#x27;PATH&#x27;)</span><br><span class="line"></span><br><span class="line">os.path.abspath(&#x27;.&#x27;)  # 查看当前目录的绝对路径</span><br><span class="line">os.path.join(&#x27;/Users/michael&#x27;, &#x27;testdir&#x27;)  # 合并路径</span><br><span class="line">os.mkdir(&#x27;/Users/michael/testdir&#x27;)  # 创建目录</span><br><span class="line">os.rmdir(&#x27;/Users/michael/testdir&#x27;)  # 删除目录</span><br><span class="line">os.path.split(&#x27;/Users/michael/testdir/file.txt&#x27;)  # 拆分路径</span><br><span class="line">os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;)  # 重命名文件</span><br><span class="line">os.remove(&#x27;test.py&#x27;)  # 删除文件</span><br><span class="line"></span><br><span class="line"># shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</span><br><span class="line"></span><br><span class="line"># 列出当前所有目录</span><br><span class="line">[x for x in os.listdir(&#x27;.&#x27;) if os.path.isdir(x)]</span><br></pre></td></tr></table></figure></li>
<li>序列化<ol>
<li>pickle-只能在同版本python <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pickle</span><br><span class="line">d = dict(name=&#x27;jesonlin&#x27;, age=30, score=99)</span><br><span class="line"></span><br><span class="line"># 序列化</span><br><span class="line"># 任意对象序列化成一个bytes，然后写入文件</span><br><span class="line">dd = pickle.dumps(d)</span><br><span class="line"># 或者直接序列化写入一个-file-like object</span><br><span class="line">with open(&#x27;dump.txt&#x27;, &#x27;wb&#x27;) as f:</span><br><span class="line">    pickle.dump(d, f)</span><br><span class="line"></span><br><span class="line"># 反序列化</span><br><span class="line">ddd = pickle.loads(dd)</span><br><span class="line"># 或者直接从文件反序列化</span><br><span class="line">with open(&#x27;dump.txt&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    ddd = pickle.load(f)</span><br></pre></td></tr></table></figure></li>
<li>json-跨语言传递对象 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">d = dict(name=&#x27;jesonlin&#x27;, age=30, score=99)</span><br><span class="line"></span><br><span class="line"># 序列化</span><br><span class="line">dd = json.dumps(d)</span><br><span class="line"># 反序列化</span><br><span class="line">ddd = json.loads(dd)</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, age, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line">stu = Student(&#x27;jesonlin&#x27;, 30, 99)</span><br><span class="line"></span><br><span class="line"># 类对象序列化，无法直接序列化，可自定义使用转换函数转换为字典</span><br><span class="line">def stu2dict(stu):</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x27;name&#x27;: stu.name,</span><br><span class="line">        &#x27;age&#x27;: stu.age,</span><br><span class="line">        &#x27;score&#x27;: stu.score</span><br><span class="line">    &#125;</span><br><span class="line">dd = json.dumps(stu, default=stu2dict)</span><br><span class="line"># 通用的</span><br><span class="line">dd = json.dumps(stu, default=lambda obj: obj.__dict__)</span><br><span class="line"></span><br><span class="line"># 类对象反序列</span><br><span class="line">def dict2stu(d):</span><br><span class="line">    return Student(d[&#x27;name&#x27;], d[&#x27;age&#x27;], d[&#x27;score&#x27;])</span><br><span class="line">json.loads(dd, object_hook=dict2stu)</span><br><span class="line"># 通用的</span><br><span class="line">json.loads(dd, object_hook=lambda obj: Student(**obj))</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ol start="0">
<li>进程 vs. 线程<ol>
<li>进程<ol>
<li>优点：稳定性高，一个子进程挂了不影响其他进程；</li>
<li>缺点：效率低，创建和调度进程开销大，进程数有限；</li>
</ol>
</li>
<li>线程<ol>
<li>优点：效率高，创建和调度线程开销较小；</li>
<li>缺点：稳定性低，一个线程挂了可能导致整个进程崩溃，因为所有线程共享进程内存。</li>
</ol>
</li>
</ol>
</li>
<li>fork<br> Unix&#x2F;Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">print(&#x27;process (%s) start...&#x27; % os.getpid())</span><br><span class="line"></span><br><span class="line"># Only works on Unix/Linux/Mac:</span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&#x27;I am child process (%s) and my parent is %s.&#x27; % (os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;I (%s) just created a child process (%s).&#x27; % (os.getpid(), pid))</span><br></pre></td></tr></table></figure></li>
<li>进程<ol>
<li>单个进程-Process <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os, time</span><br><span class="line"></span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&#x27;Begin run child process %s (%s)...&#x27; % (name, os.getpid()))</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&#x27;End run child process %s (%s)...&#x27; % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;Parent process %s.&#x27; % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(&#x27;test&#x27;,))</span><br><span class="line">    print(&#x27;Child process will start.&#x27;)</span><br><span class="line">    p.start()  # 开始执行子进程</span><br><span class="line">    p.join()  # 等待子进程结束后再继续往下运行，通常用于进程间的同步</span><br><span class="line">    print(&#x27;Child process end.&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>进程池-Pool <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line">def long_time_task(name):</span><br><span class="line">    print(&#x27;Run task %s (%s)...&#x27; % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;Task %s runs %0.2f seconds.&#x27; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;Parent process %s.&#x27; % os.getpid())</span><br><span class="line">    p = Pool(4)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        # 立刻执行，无需等待，异步非阻塞</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(&#x27;Waiting for all subprocesses done...&#x27;)</span><br><span class="line">    p.close()  # 调用close()之后就不能继续添加新的Process了</span><br><span class="line">    p.join()  # 等待所有子进程执行完毕</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&#x27;All subprocesses done.&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>子进程-subprocess <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line"># 直接调用命令</span><br><span class="line">print(&#x27;$ nslookup www.python.org&#x27;)</span><br><span class="line">subprocess.call([&#x27;nslookup&#x27;, &#x27;www.python.org&#x27;])</span><br><span class="line">print(&#x27;Exit code: %s&#x27; % r)</span><br><span class="line"></span><br><span class="line"># 交互调用命令</span><br><span class="line">print(&#x27;$ nslookup&#x27;)</span><br><span class="line">p = subprocess.Popen([&#x27;nslookup&#x27;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(b&#x27;set q=mx\npython.org\nexit\n&#x27;)</span><br><span class="line">print(output.decode(&#x27;utf-8&#x27;))</span><br><span class="line">print(&#x27;Exit code: %s&#x27; % p.returncode)</span><br></pre></td></tr></table></figure></li>
<li>进程间通信 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line"># 写数据进程执行的代码:</span><br><span class="line">def write(q):</span><br><span class="line">    print(&#x27;Process to write: %s&#x27; % os.getpid())</span><br><span class="line">    for value in [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]:</span><br><span class="line">        print(&#x27;Put %s to queue...&#x27; % value)</span><br><span class="line">        q.put(value)  # 队列写入</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"># 读数据进程执行的代码:</span><br><span class="line">def read(q):</span><br><span class="line">    print(&#x27;Process to read: %s&#x27; % os.getpid())</span><br><span class="line">    while True:</span><br><span class="line">        value = q.get(True)  # 队列读出</span><br><span class="line">        print(&#x27;Get %s from queue.&#x27; % value)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 父进程创建Queue，并传给各个子进程：</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    # 启动子进程pw，写入:</span><br><span class="line">    pw.start()</span><br><span class="line">    # 启动子进程pr，读取:</span><br><span class="line">    pr.start()</span><br><span class="line">    # 等待pw结束:</span><br><span class="line">    pw.join()</span><br><span class="line">    # pr进程里是死循环，无法等待其结束，只能强行终止:</span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>线程<br> 多线程中，所有变量都由所有线程共享<ol start="0">
<li>模块<br> Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</li>
<li>启动线程-传入函数，创建Thread实例，调用start()开始执行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    print(&#x27;thread %s is running...&#x27; % threading.current_thread().name)</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&#x27;thread %s &gt;&gt;&gt; %s&#x27; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&#x27;thread %s ended.&#x27; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&#x27;thread %s is running...&#x27; % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=&#x27;LoopThread&#x27;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&#x27;thread %s ended.&#x27; % threading.current_thread().name)</span><br></pre></td></tr></table></figure></li>
<li>锁 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 假定这是你的银行存款:</span><br><span class="line">balance = 0</span><br><span class="line"># 锁</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def change_it(n):</span><br><span class="line">    # 先存后取，结果应该为0:</span><br><span class="line">    global balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(2000000):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(5,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(8,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(balance)</span><br></pre></td></tr></table></figure></li>
<li>GIL锁<br> Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。<br> Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</li>
<li>threading.local()-解决了参数在一个线程中各个函数之间互相传递的问题。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建全局ThreadLocal对象</span><br><span class="line"># 全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。</span><br><span class="line"># 可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</span><br><span class="line"># ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line">def process_student():</span><br><span class="line">    # 获取当前线程关联的student:</span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(&#x27;Hello, %s (in %s)&#x27; % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">def process_thread(name):</span><br><span class="line">    # 绑定ThreadLocal的student:</span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=process_thread, args=(&#x27;A&#x27;,), name=&#x27;Thread-A&#x27;)</span><br><span class="line">t2 = threading.Thread(target=process_thread, args=(&#x27;B&#x27;,), name=&#x27;Thread-B&#x27;)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>分布式进程<ol>
<li>生成任务，放入任务队列，等待从结果队列取结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random, time, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 发送任务的队列:</span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"># 接收结果的队列:</span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line"># 从BaseManager继承的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span><br><span class="line">QueueManager.register(&#x27;get_task_queue&#x27;, callable=lambda: task_queue)</span><br><span class="line">QueueManager.register(&#x27;get_result_queue&#x27;, callable=lambda: result_queue)</span><br><span class="line"># 绑定端口5000, 设置验证码&#x27;abc&#x27;:</span><br><span class="line">manager = QueueManager(address=(&#x27;&#x27;, 5000), authkey=b&#x27;abc&#x27;)</span><br><span class="line"># 启动Queue:</span><br><span class="line">manager.start()</span><br><span class="line"># 获得通过网络访问的Queue对象:</span><br><span class="line">task = manager.get_task_queue()</span><br><span class="line">result = manager.get_result_queue()</span><br><span class="line"># 放几个任务进去:</span><br><span class="line">for i in range(10):</span><br><span class="line">    n = random.randint(0, 10000)</span><br><span class="line">    print(&#x27;Put task %d...&#x27; % n)</span><br><span class="line">    task.put(n)</span><br><span class="line"># 从result队列读取结果:</span><br><span class="line">print(&#x27;Try get results...&#x27;)</span><br><span class="line">for i in range(10):</span><br><span class="line">    r = result.get(timeout=10)</span><br><span class="line">    print(&#x27;Result: %s&#x27; % r)</span><br><span class="line"># 关闭:</span><br><span class="line">manager.shutdown()</span><br><span class="line">print(&#x27;master exit.&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>消费任务，从任务队列获取，将结果放入结果队列 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time, sys, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 创建类似的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span><br><span class="line">QueueManager.register(&#x27;get_task_queue&#x27;)</span><br><span class="line">QueueManager.register(&#x27;get_result_queue&#x27;)</span><br><span class="line"></span><br><span class="line"># 连接到服务器，也就是运行task_master.py的机器:</span><br><span class="line">server_addr = &#x27;127.0.0.1&#x27;</span><br><span class="line">print(&#x27;Connect to server %s...&#x27; % server_addr)</span><br><span class="line"># 端口和验证码注意保持与task_master.py设置的完全一致:</span><br><span class="line">m = QueueManager(address=(server_addr, 5000), authkey=b&#x27;abc&#x27;)</span><br><span class="line"># 从网络连接:</span><br><span class="line">m.connect()</span><br><span class="line"># 获取Queue的对象:</span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"># 从task队列取任务,并把结果写入result队列:</span><br><span class="line">for i in range(10):</span><br><span class="line">    try:</span><br><span class="line">        n = task.get(timeout=1)</span><br><span class="line">        print(&#x27;run task %d * %d...&#x27; % (n, n))</span><br><span class="line">        r = &#x27;%d * %d = %d&#x27; % (n, n, n*n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        result.put(r)</span><br><span class="line">    except Queue.Empty:</span><br><span class="line">        print(&#x27;task queue is empty.&#x27;)</span><br><span class="line"># 处理结束:</span><br><span class="line">print(&#x27;worker exit.&#x27;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol>
<li>正则表达式规则<ol>
<li>如果直接给出字符，就是精确匹配。用 <code>\d</code> 可以匹配一个数字，<code>\w</code> 可以匹配一个字母或数字。</li>
<li><code>.</code> 匹配任意字符</li>
<li><code>*</code> 匹配任意个字符（包括0个）</li>
<li><code>+</code> 匹配至少一个字符</li>
<li><code>?</code> 匹配0个或1个字符</li>
<li><code>\s</code> 匹配一个空格</li>
<li><code>&#123;n&#125;</code> 匹配那个字符</li>
<li><code>&#123;n-m&#125;</code> 匹配n-m个前面字符<br> <code>\d&#123;3&#125;\s+\d&#123;3,8&#125;</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d&#123;3&#125; 表示匹配3个数字</span><br><span class="line">\s+   表示匹配至少一个空格</span><br><span class="line">\d&#123;3,8&#125; 表示匹配3-8个数字</span><br></pre></td></tr></table></figure></li>
<li><code>[]</code> 表示范围 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0-9a-zA-Z\_]+ 可以匹配至少由一个数字、字母或者下划线组成的字符串；</span><br><span class="line">[a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</span><br><span class="line">[a-zA-Z\_][0-9a-zA-Z\_]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）；</span><br></pre></td></tr></table></figure></li>
<li><code>A|B</code> 表示匹配A或B，所以 <code>(P|p)ython</code> 可以匹配 <code>&#39;Python&#39;</code> 或者 <code>&#39;python&#39;</code></li>
<li><code>^</code> 表示行的开头，<code>^\d</code> 表示必须以数字开头</li>
<li><code>$</code> 表示行的结尾，<code>\d$</code> 表示结尾必须以数字结束</li>
</ol>
</li>
<li>re 模块<ol>
<li>python 也使用 <code>\</code> 转义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;ABC\\-001&#x27; # Python的字符串</span><br><span class="line"># 对应的正则表达式字符串变成：</span><br><span class="line"># &#x27;ABC\-001&#x27;</span><br><span class="line"></span><br><span class="line"># 建议使用Python的r前缀，就不用考虑转义的问题了</span><br><span class="line">s = r&#x27;ABC\-001&#x27; # Python的字符串</span><br><span class="line"># 对应的正则表达式字符串不变：</span><br><span class="line"># &#x27;ABC\-001&#x27;</span><br></pre></td></tr></table></figure></li>
<li>match-是否匹配 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"># 匹配成功</span><br><span class="line">re.match(r&#x27;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x27;, &#x27;010-12345&#x27;)</span><br><span class="line"># 匹配成功返回如下</span><br><span class="line">&lt;_sre.SRE_Match object at 0x7f3d6a6017e8&gt;</span><br><span class="line"># 匹配失败返回None</span><br><span class="line">re.match(r&#x27;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x27;, &#x27;010 12345&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>split-切分字符串 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;a b   c&#x27;.split(&#x27; &#x27;)</span><br><span class="line"># 无法失败联系的空格</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;c&#x27;]</span><br><span class="line"></span><br><span class="line"># 正则切割包含连续空格串</span><br><span class="line">&gt;&gt;&gt; re.split(r&#x27;\s+&#x27;, &#x27;a b   c&#x27;)</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line"></span><br><span class="line"># 正则切割包含联系空格和逗号串</span><br><span class="line">&gt;&gt;&gt; re.split(r&#x27;[\s\,]+&#x27;, &#x27;a,b, c  d&#x27;)</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><ol>
<li>asyncio <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def wget(host):</span><br><span class="line">    print(&#x27;wget %s...&#x27; % host)</span><br><span class="line">    connect = asyncio.open_connection(host, 80)</span><br><span class="line">    reader, writer = yield from connect</span><br><span class="line">    header = &#x27;GET / HTTP/1.0\r\nHost: %s\r\n\r\n&#x27; % host</span><br><span class="line">    writer.write(header.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    yield from writer.drain()</span><br><span class="line">    while True:</span><br><span class="line">        line = yield from reader.readline()</span><br><span class="line">        if line == b&#x27;\r\n&#x27;:</span><br><span class="line">            break</span><br><span class="line">        print(&#x27;%s header &gt; %s&#x27; % (host, line.decode(&#x27;utf-8&#x27;).rstrip()))</span><br><span class="line">    # Ignore the body, close the socket</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [wget(host) for host in [&#x27;www.sina.com.cn&#x27;, &#x27;www.sohu.com&#x27;, &#x27;www.163.com&#x27;]]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></li>
<li>python3.5以上新写法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    r = yield from asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br><span class="line"></span><br><span class="line"># 新写法</span><br><span class="line">async def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    r = await asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.python.org/">官网</a><br><a href="https://pythonguidecn.readthedocs.io/zh/latest/">Python最佳实践指南</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰-python教程</a><br><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/">谷歌-python风格指南</a><br><a href="https://httpbin.org/">简单的http请求和响应服务</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-数据类型</title>
    <url>/%E5%AD%98%E5%82%A8/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Redis 提供了丰富的数据类型，常见的有五种：<br>String（字符串）、List（列表）、Hash（哈希）、Set（集合）、Zset（有序集合）。</p>
<span id="more"></span>
<h1 id="Redis-数据类型对应数据结构"><a href="#Redis-数据类型对应数据结构" class="headerlink" title="Redis 数据类型对应数据结构"></a>Redis 数据类型对应数据结构</h1><img src="./redis数据类型与数据结构.webp" width = "50%" height = "50%" alt="redis数据类型与数据结构" align=center />

<h1 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>String 是最基本的 key-value 结构，，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<p>SDS 相比于 C 的原生字符串：</p>
<pre><code>SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束

SDS 获取字符串长度的时间复杂度是 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。

Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。
</code></pre>
<p>字符串对象的内部编码（encoding）有 3 种 ：int、raw和 embstr。<br>    <img src="./string结构.webp" width = "50%" height = "50%" alt="string结构" align=center /></p>
<p>整数值可以用long类型来表示<br>    <img src="./int.webp" width = "50%" height = "50%" alt="int" align=center /></p>
<p>字符申的长度小于等于 44 字节，一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS，所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。<br>    <img src="./embstr.webp" width = "50%" height = "50%" alt="embstr" align=center /></p>
<p>字符申的长度大于 44 字节，调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS。<br>    <img src="./raw.webp" width = "50%" height = "50%" alt="raw" align=center /></p>
<p> embstr 字符串长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以embstr编码的字符串对象实际上是只读的。对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="普通字符串基本操作"><a href="#普通字符串基本操作" class="headerlink" title="普通字符串基本操作"></a>普通字符串基本操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> name lin</span><br><span class="line">OK</span><br><span class="line"># 根据 key 获得对应的 <span class="keyword">value</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">GET</span> name</span><br><span class="line">&quot;lin&quot;</span><br><span class="line"># 判断某个 key 是否存在</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">EXISTS</span> name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 返回 key 所储存的字符串值的长度</span><br><span class="line"><span class="operator">&gt;</span> STRLEN name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"># 删除某个 key 对应的值</span><br><span class="line"><span class="operator">&gt;</span> DEL name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="批量设置"><a href="#批量设置" class="headerlink" title="批量设置"></a>批量设置</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 批量设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> MSET key1 value1 key2 value2 </span><br><span class="line">OK</span><br><span class="line"># 批量获取多个 key 对应的 <span class="keyword">value</span></span><br><span class="line"><span class="operator">&gt;</span> MGET key1 key2 </span><br><span class="line"><span class="number">1</span>) &quot;value1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="计数器（字符串的内容为整数的时候可以使用）："><a href="#计数器（字符串的内容为整数的时候可以使用）：" class="headerlink" title="计数器（字符串的内容为整数的时候可以使用）："></a>计数器（字符串的内容为整数的时候可以使用）：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> number <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"># 将 key 中储存的数字值增一</span><br><span class="line"><span class="operator">&gt;</span> INCR number</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 将key中存储的数字值加 <span class="number">10</span></span><br><span class="line"><span class="operator">&gt;</span> INCRBY number <span class="number">10</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">11</span></span><br><span class="line"># 将 key 中储存的数字值减一</span><br><span class="line"><span class="operator">&gt;</span> DECR number</span><br><span class="line">(<span class="type">integer</span>) <span class="number">10</span></span><br><span class="line"># 将key中存储的数字值键 <span class="number">10</span></span><br><span class="line"><span class="operator">&gt;</span> DECRBY number <span class="number">10</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="过期（默认为永不过期）："><a href="#过期（默认为永不过期）：" class="headerlink" title="过期（默认为永不过期）："></a>过期（默认为永不过期）：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置 key 在 <span class="number">60</span> 秒后过期（该方法是针对已经存在的key设置过期时间）</span><br><span class="line"><span class="operator">&gt;</span> EXPIRE name  <span class="number">60</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 查看数据还有多久过期</span><br><span class="line"><span class="operator">&gt;</span> TTL name </span><br><span class="line">(<span class="type">integer</span>) <span class="number">51</span></span><br><span class="line"></span><br><span class="line">#设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值，并设置该key的过期时间为 <span class="number">60</span> 秒</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> key  <span class="keyword">value</span> EX <span class="number">60</span></span><br><span class="line">OK</span><br><span class="line"><span class="operator">&gt;</span> SETEX key  <span class="number">60</span> <span class="keyword">value</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="不存在就插入："><a href="#不存在就插入：" class="headerlink" title="不存在就插入："></a>不存在就插入：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 不存在就插入（<span class="keyword">not</span> <span class="keyword">exists</span>）</span><br><span class="line"><span class="operator">&gt;</span>SETNX key <span class="keyword">value</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>缓存整个对象的 JSON</p>
<pre><code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;
</code></pre>
<p>将 key 进行分离为 user:ID:属性</p>
<pre><code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20
</code></pre>
<h3 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h3><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化文章的阅读量</span><br><span class="line">&gt; SET aritcle:readcount:1001 0</span><br><span class="line">OK</span><br><span class="line">#阅读量+1</span><br><span class="line">&gt; INCR aritcle:readcount:1001</span><br><span class="line">(integer) 1</span><br><span class="line">#阅读量+1</span><br><span class="line"># 获取对应文章的阅读量</span><br><span class="line">&gt; GET aritcle:readcount:1001</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<pre><code>1. 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；
2. 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。
</code></pre>
<p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p>
<pre><code>SET lock_key unique_value NX PX 10000

lock_key 就是 key 键；
unique_value 是客户端生成的唯一的标识；
NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；
PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁
</code></pre>
<p>解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。</p>
<pre><code>// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
</code></pre>
<h3 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h3><p>开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息<br><img src="./Session2.webp" width = "50%" height = "50%" alt="Session2" align=center /></p>
<h1 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。</p>
<p>列表的最大长度为 2^32 - 1，也即每个列表支持超过 40 亿个元素。</p>
<h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>List 类型的底层数据结构是由双向链表或压缩列表实现的：</p>
<pre><code>1. 如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用ziplist（压缩列表）作为 List 类型的底层数据结构；连续内存空间，存储效率高，不利于修改操作，插入和删除操作需要频繁申请和释放内存。


2. 如果列表的元素不满足上面的条件，Redis 会使用双向链表作为 List 类型的底层数据结构，前后指针浪费16字节。其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。
</code></pre>
<p>但是在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。</p>
<img src="./quicklist.webp" width = "50%" height = "50%" alt="quicklist" align=center />

<h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><img src="./list.webp" width = "50%" height = "50%" alt="list" align=center />

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 将一个或多个值<span class="keyword">value</span>插入到key列表的表头(最左边)，最后的值在最前面</span><br><span class="line">LPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...] </span><br><span class="line"># 将一个或多个值<span class="keyword">value</span>插入到key列表的表尾(最右边)</span><br><span class="line">RPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...]</span><br><span class="line"># 移除并返回key列表的头元素</span><br><span class="line">LPOP key     </span><br><span class="line"># 移除并返回key列表的尾元素</span><br><span class="line">RPOP key </span><br><span class="line"></span><br><span class="line"># 返回列表key中指定区间内的元素，区间以偏移量<span class="keyword">start</span>和stop指定，从<span class="number">0</span>开始</span><br><span class="line">LRANGE key <span class="keyword">start</span> stop</span><br><span class="line"></span><br><span class="line"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout<span class="operator">=</span><span class="number">0</span>则一直阻塞</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout<span class="operator">=</span><span class="number">0</span>则一直阻塞</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列在存取消息时，必须要满足三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。</p>
<pre><code>消息保序：使用 LPUSH + RPOP；
阻塞读取：使用 BRPOP；
重复消息处理：生产者自行实现全局唯一 ID；
消息的可靠性：使用 BRPOPLPUSH
</code></pre>
<ol>
<li><p>如何满足消息保序需求？</p>
<p> List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。</p>
<p> Redis提供了 BRPOP 命令。BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。</p>
</li>
</ol>
<img src="./消息队列.webp" width = "50%" height = "50%" alt="消息队列" align=center />

<ol start="2">
<li><p>如何处理重复的消息？</p>
<p> 每个消息都有一个全局的 ID。</p>
<p> 消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。</p>
<p> 但是 List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID</p>
</li>
<li><p>如何保证消息可靠性？</p>
<p> 如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p>
<p> 为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。</p>
</li>
</ol>
<p>List 作为消息队列有什么缺陷？<br>    List 不支持多个消费者消费同一条消息，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费</p>
<h1 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>Hash 是一个键值对（key - value）集合。Hash 特别适合用于存储对象。</p>
<h2 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h2><p>Hash 类型的底层数据结构是由压缩列表或哈希表实现的：</p>
<pre><code>1. 如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用压缩列表作为 Hash 类型的底层数据结构；

2. 如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的 底层数据结构。

3. 在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。
</code></pre>
<h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储一个哈希表key的键值</span><br><span class="line">HSET key field <span class="keyword">value</span>   </span><br><span class="line"># 获取哈希表key对应的field键值</span><br><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line"># 在一个哈希表key中存储多个键值对</span><br><span class="line">HMSET key field <span class="keyword">value</span> [field value...] </span><br><span class="line"># 批量获取哈希表key中多个field键值</span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"># 删除哈希表key中的field键值</span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"></span><br><span class="line"># 返回哈希表key中field的数量</span><br><span class="line">HLEN key       </span><br><span class="line"># 返回哈希表key中所有的键值</span><br><span class="line">HGETALL key </span><br><span class="line"></span><br><span class="line"># 为哈希表key中field键的值加上增量n</span><br><span class="line">HINCRBY key field n                         </span><br></pre></td></tr></table></figure>

<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象-1"><a href="#缓存对象-1" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</p>
<p>我们可以使用如下命令，将用户对象的信息存储到 Hash 类型：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储一个哈希表uid:<span class="number">1</span>的键值</span><br><span class="line"><span class="operator">&gt;</span> HMSET uid:<span class="number">1</span> name Tom age <span class="number">15</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"># 存储一个哈希表uid:<span class="number">2</span>的键值</span><br><span class="line"><span class="operator">&gt;</span> HMSET uid:<span class="number">2</span> name Jerry age <span class="number">13</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"># 获取哈希表用户id为<span class="number">1</span>中所有的键值</span><br><span class="line"><span class="operator">&gt;</span> HGETALL uid:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Tom&quot;</span><br><span class="line"><span class="number">3</span>) &quot;age&quot;</span><br><span class="line"><span class="number">4</span>) &quot;15&quot;</span><br></pre></td></tr></table></figure>

<h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p>以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素，如下图所示。</p>
<img src="./购物车.webp" width = "50%" height = "50%" alt="购物车" align=center />

<p>涉及的命令如下：</p>
<pre><code>添加商品：HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1
添加数量：HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1
商品总数：HLEN cart:&#123;用户id&#125;
删除商品：HDEL cart:&#123;用户id&#125; &#123;商品id&#125;
获取购物车所有商品：HGETALL cart:&#123;用户id&#125;
</code></pre>
<h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>一个集合最多可以存储 2^32-1 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<h2 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h2><p>Set 类型的底层数据结构是由哈希表或整数集合实现的：</p>
<pre><code>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；

如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。
</code></pre>
<h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li>常用操作<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span><br><span class="line">SADD key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br><span class="line"># 从集合key中删除元素</span><br><span class="line">SREM key <span class="keyword">member</span> [<span class="keyword">member</span> ...] </span><br><span class="line"># 获取集合key中所有元素</span><br><span class="line">SMEMBERS key</span><br><span class="line"># 获取集合key中的元素个数</span><br><span class="line">SCARD key</span><br><span class="line"></span><br><span class="line"># 判断<span class="keyword">member</span>元素是否存在于集合key中</span><br><span class="line">SISMEMBER key <span class="keyword">member</span></span><br><span class="line"></span><br><span class="line"># 从集合key中随机选出count个元素，元素不从key中删除</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"># 从集合key中随机选出count个元素，元素从key中删除</span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure></li>
<li>运算操作<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 交集运算</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"># 将交集结果存入新集合destination中</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 并集运算</span><br><span class="line">SUNION key [key ...]</span><br><span class="line"># 将并集结果存入新集合destination中</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 差集运算</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"># 将差集结果存入新集合destination中</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p>这里有一个潜在的风险。Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计</p>
<h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p>
<p>uid:1 、uid:2、uid:3 三个用户分别对 article:1 文章点赞了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># uid:<span class="number">1</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># uid:<span class="number">2</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># uid:<span class="number">3</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">3</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># uid:<span class="number">1</span> 取消了对 article:<span class="number">1</span> 文章点赞。</span><br><span class="line"><span class="operator">&gt;</span> SREM article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 获取 article:<span class="number">1</span> 文章所有点赞用户 :</span><br><span class="line"><span class="operator">&gt;</span> SMEMBERS article:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;uid:3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;uid:2&quot;</span><br><span class="line"></span><br><span class="line"># 判断用户 uid:<span class="number">1</span> 是否对文章 article:<span class="number">1</span> 点赞了：</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span>  # 返回<span class="number">0</span>说明没点赞，返回<span class="number">1</span>则说明点赞了</span><br></pre></td></tr></table></figure>

<h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户id，value 则是已关注的公众号的id。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># uid:<span class="number">1</span> 用户关注公众号 id 为 <span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span></span><br><span class="line"><span class="operator">&gt;</span> SADD uid:<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line"># uid:<span class="number">2</span>  用户关注公众号 id 为 <span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span>、<span class="number">10</span>、<span class="number">11</span></span><br><span class="line"><span class="operator">&gt;</span> SADD uid:<span class="number">2</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line"></span><br><span class="line"># uid:<span class="number">1</span> 和 uid:<span class="number">2</span> 共同关注的公众号：</span><br><span class="line"># 获取共同关注</span><br><span class="line"><span class="operator">&gt;</span> SINTER uid:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;7&quot;</span><br><span class="line"><span class="number">2</span>) &quot;8&quot;</span><br><span class="line"><span class="number">3</span>) &quot;9&quot;</span><br><span class="line"></span><br><span class="line"># 给 uid:<span class="number">2</span> 推荐 uid:<span class="number">1</span> 关注的公众号：</span><br><span class="line"><span class="operator">&gt;</span> SDIFF uid:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;6&quot;</span><br><span class="line"></span><br><span class="line"># 验证某个公众号是否同时被 uid:<span class="number">1</span> 或 uid:<span class="number">2</span> 关注:</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER uid:<span class="number">1</span> <span class="number">5</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span> # 返回<span class="number">0</span>，说明关注了</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER uid:<span class="number">2</span> <span class="number">5</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span> # 返回<span class="number">0</span>，说明没关注</span><br></pre></td></tr></table></figure>

<h3 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h3><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line"></span><br><span class="line"># 如果允许重复中奖，可以使用 SRANDMEMBER 命令。</span><br><span class="line"># 抽取 <span class="number">1</span> 个一等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;Tom&quot;</span><br><span class="line"># 抽取 <span class="number">2</span> 个二等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;Mark&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Jerry&quot;</span><br><span class="line"># 抽取 <span class="number">3</span> 个三等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;Sary&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Tom&quot;</span><br><span class="line"><span class="number">3</span>) &quot;Jerry&quot;</span><br><span class="line"></span><br><span class="line"># 如果不允许重复中奖，可以使用 SPOP 命令。</span><br><span class="line"># 抽取一等奖<span class="number">1</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;Sary&quot;</span><br><span class="line"># 抽取二等奖<span class="number">2</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;Jerry&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Mark&quot;</span><br><span class="line"># 抽取三等奖<span class="number">3</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;John&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Sean&quot;</span><br><span class="line"><span class="number">3</span>) &quot;Lindy&quot;</span><br></pre></td></tr></table></figure>


<h1 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p>
<p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p>
<img src="./zset.webp" width = "50%" height = "50%" alt="zset" align=center />

<h2 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h2><p>Zset 类型的底层数据结构是由压缩列表或跳表实现的：</p>
<pre><code>1. 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；

2.如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；
</code></pre>
<p>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</p>
<h2 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p>常用操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 往有序集合key中加入带分值元素</span><br><span class="line">ZADD key score <span class="keyword">member</span> [[score <span class="keyword">member</span>]...]   </span><br><span class="line"># 往有序集合key中删除元素</span><br><span class="line">ZREM key <span class="keyword">member</span> [member...]                 </span><br><span class="line"># 返回有序集合key中元素<span class="keyword">member</span>的分值</span><br><span class="line">ZSCORE key <span class="keyword">member</span></span><br><span class="line"># 返回有序集合key中元素个数</span><br><span class="line">ZCARD key </span><br><span class="line"></span><br><span class="line"># 为有序集合key中元素<span class="keyword">member</span>的分值加上increment</span><br><span class="line">ZINCRBY key increment <span class="keyword">member</span> </span><br><span class="line"></span><br><span class="line"># 正序获取有序集合key从<span class="keyword">start</span>下标到stop下标的元素</span><br><span class="line">ZRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br><span class="line"># 倒序获取有序集合key从<span class="keyword">start</span>下标到stop下标的元素</span><br><span class="line">ZREVRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT <span class="keyword">offset</span> count]</span><br><span class="line"></span><br><span class="line"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span><br><span class="line">ZRANGEBYLEX key min max [LIMIT <span class="keyword">offset</span> count]</span><br><span class="line"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT <span class="keyword">offset</span> count]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key...] </span><br><span class="line"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span><br><span class="line">ZINTERSTORE destkey numberkeys key [key...]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h2><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p>
<h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p>
<p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># arcticle:<span class="number">1</span> 文章获得了<span class="number">200</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">200</span> arcticle:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># arcticle:<span class="number">2</span> 文章获得了<span class="number">40</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">40</span> arcticle:<span class="number">2</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># arcticle:<span class="number">3</span> 文章获得了<span class="number">100</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">100</span> arcticle:<span class="number">3</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># arcticle:<span class="number">4</span> 文章获得了<span class="number">50</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">50</span> arcticle:<span class="number">4</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># arcticle:<span class="number">5</span> 文章获得了<span class="number">150</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">150</span> arcticle:<span class="number">5</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 文章 arcticle:<span class="number">4</span> 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素<span class="keyword">member</span>的分值加上increment）：</span><br><span class="line"><span class="operator">&gt;</span> ZINCRBY <span class="keyword">user</span>:xiaolin:ranking <span class="number">1</span> arcticle:<span class="number">4</span></span><br><span class="line">&quot;51&quot;</span><br><span class="line"></span><br><span class="line"># 查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</span><br><span class="line"><span class="operator">&gt;</span> ZSCORE <span class="keyword">user</span>:xiaolin:ranking arcticle:<span class="number">4</span></span><br><span class="line">&quot;50&quot;</span><br><span class="line"></span><br><span class="line"># 获取小林文章赞数最多的 <span class="number">3</span> 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从<span class="keyword">start</span>下标到stop下标的元素）：</span><br><span class="line"># WITHSCORES 表示把 score 也显示出来</span><br><span class="line"><span class="operator">&gt;</span> ZREVRANGE <span class="keyword">user</span>:xiaolin:ranking <span class="number">0</span> <span class="number">2</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) &quot;arcticle:1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;200&quot;</span><br><span class="line"><span class="number">3</span>) &quot;arcticle:5&quot;</span><br><span class="line"><span class="number">4</span>) &quot;150&quot;</span><br><span class="line"><span class="number">5</span>) &quot;arcticle:3&quot;</span><br><span class="line"><span class="number">6</span>) &quot;100&quot;</span><br><span class="line"></span><br><span class="line"># 获取小林 <span class="number">100</span> 赞到 <span class="number">200</span> 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</span><br><span class="line"><span class="operator">&gt;</span> ZRANGEBYSCORE <span class="keyword">user</span>:xiaolin:ranking <span class="number">100</span> <span class="number">200</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) &quot;arcticle:3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;100&quot;</span><br><span class="line"><span class="number">3</span>) &quot;arcticle:5&quot;</span><br><span class="line"><span class="number">4</span>) &quot;150&quot;</span><br><span class="line"><span class="number">5</span>) &quot;arcticle:1&quot;</span><br><span class="line"><span class="number">6</span>) &quot;200&quot;</span><br></pre></td></tr></table></figure>

<h3 id="电话、姓名排序"><a href="#电话、姓名排序" class="headerlink" title="电话、姓名排序"></a>电话、姓名排序</h3><p>使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序</p>
<p>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> ZADD phone <span class="number">0</span> <span class="number">13100111100</span> <span class="number">0</span> <span class="number">13110114300</span> <span class="number">0</span> <span class="number">13132110901</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="operator">&gt;</span> ZADD phone <span class="number">0</span> <span class="number">13200111100</span> <span class="number">0</span> <span class="number">13210414300</span> <span class="number">0</span> <span class="number">13252110901</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="operator">&gt;</span> ZADD phone <span class="number">0</span> <span class="number">13300111100</span> <span class="number">0</span> <span class="number">13310414300</span> <span class="number">0</span> <span class="number">13352110901</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 获取所有号码:</span><br><span class="line"><span class="number">1</span>) &quot;13100111100&quot;</span><br><span class="line"><span class="number">2</span>) &quot;13110114300&quot;</span><br><span class="line"><span class="number">3</span>) &quot;13132110901&quot;</span><br><span class="line"><span class="number">4</span>) &quot;13200111100&quot;</span><br><span class="line"><span class="number">5</span>) &quot;13210414300&quot;</span><br><span class="line"><span class="number">6</span>) &quot;13252110901&quot;</span><br><span class="line"><span class="number">7</span>) &quot;13300111100&quot;</span><br><span class="line"><span class="number">8</span>) &quot;13310414300&quot;</span><br><span class="line"><span class="number">9</span>) &quot;13352110901&quot;</span><br><span class="line"></span><br><span class="line"># 获取 <span class="number">132</span> 号段的号码：</span><br><span class="line"><span class="operator">&gt;</span> ZRANGEBYLEX phone [<span class="number">132</span> (<span class="number">133</span></span><br><span class="line"><span class="number">1</span>) &quot;13200111100&quot;</span><br><span class="line"><span class="number">2</span>) &quot;13210414300&quot;</span><br><span class="line"><span class="number">3</span>) &quot;13252110901&quot;</span><br><span class="line"></span><br><span class="line"># 获取<span class="number">132</span>、<span class="number">133</span>号段的号码：</span><br><span class="line"><span class="operator">&gt;</span> ZRANGEBYLEX phone [<span class="number">132</span> (<span class="number">134</span></span><br><span class="line"><span class="number">1</span>) &quot;13200111100&quot;</span><br><span class="line"><span class="number">2</span>) &quot;13210414300&quot;</span><br><span class="line"><span class="number">3</span>) &quot;13252110901&quot;</span><br><span class="line"><span class="number">4</span>) &quot;13300111100&quot;</span><br><span class="line"><span class="number">5</span>) &quot;13310414300&quot;</span><br><span class="line"><span class="number">6</span>) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://xiaolincoding.com/redis/">图解Redis介绍</a><br><a href="https://try.redis.io/">在线redis环境</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/%E5%AD%98%E5%82%A8/redis/</url>
    <content><![CDATA[<p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。Redis 通常被称为数据结构服务器。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>介绍<br> Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。Redis 通常被称为数据结构服务器。</li>
<li>特点  <ol>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供string&#x2F;list&#x2F;set&#x2F;zset&#x2F;hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ol>
</li>
<li>优势<ol>
<li>性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s </li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li>
</ol>
</li>
<li>redis 的 key 只能是字符串</li>
<li>redis 的 value 可以是如下<ol>
<li>String: 字符串</li>
<li>List: 列表</li>
<li>Set: 集合</li>
<li>zset: 有序集合</li>
<li>Hash: 散列</li>
</ol>
</li>
</ol>
<h2 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h2><ol>
<li>源码安装 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.14.tar.gz</span><br><span class="line">tar xzf redis-5.0.14.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-5.0.14</span><br><span class="line">make</span><br><span class="line">执行完 make 命令后，redis-5.0.14 的 src 目录下会出现编译后的 redis 服务程序 </span><br><span class="line">redis-server，还有用于测试的客户端程序 redis-cli</span><br></pre></td></tr></table></figure></li>
<li>启动 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>使用 * 号获取所有配置项 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET *</span><br></pre></td></tr></table></figure></li>
<li>使用 CONFIG SET 修改配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure></li>
<li>主要配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">databases  # 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</span><br><span class="line">timeout # 当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</span><br><span class="line">bind 127.0.0.1  # 绑定的主机地址</span><br><span class="line">port 6379  # 指定 Redis 监听端口，默认端口为 6379</span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;  # 当本机为 slave，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 </span><br><span class="line">requirepass foobared  # 设置 Redis 连接密码，如果配置了连接密码</span><br><span class="line">maxclients 128  # 设置同一时间最大客户端连接数，默认无限制</span><br><span class="line">maxmemory &lt;bytes&gt;  # 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li>登陆 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/data/service/redis5/bin/redis-cli -h 127.0.0.1 -p 6378 -a 【密码】</span><br><span class="line">redis-cli -h IP地址 -p 端口 -a 密码</span><br><span class="line">--raw  # 防止中文乱码，加上</span><br></pre></td></tr></table></figure></li>
<li>验证密码是否正确&#x2F;查看服务是否运行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AUTH 【密码】  # 返回OK        </span><br><span class="line">PING  # 返回PONG</span><br></pre></td></tr></table></figure></li>
<li>切换到指定的数据库（默认总16个数据库，当前0） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 【index】</span><br></pre></td></tr></table></figure></li>
<li>查看redis信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info 【server】/【memory】</span><br></pre></td></tr></table></figure></li>
<li>查看所有的key列表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys *  # *是通配符，可以是其他前后缀匹配</span><br></pre></td></tr></table></figure></li>
<li>统计当前db下key数量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DBSIZE</span><br></pre></td></tr></table></figure></li>
<li>查看key类型 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type 【key】</span><br></pre></td></tr></table></figure></li>
<li>判断key是否存在 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exists 【key】</span><br></pre></td></tr></table></figure></li>
<li>修改key名称 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename 【key】 【newkey】</span><br></pre></td></tr></table></figure></li>
<li>查看key过期时间<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ttl 【key】  # 以秒返回</span><br><span class="line">pttl 【key】  # 以毫秒返回</span><br><span class="line">(integer) -1  # 无过期时间返回</span><br><span class="line">(integer) -2  # KEY不存在返回</span><br></pre></td></tr></table></figure></li>
<li>设置&#x2F;清除key过期时间<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire 【key】 3  # 设置3秒过期</span><br><span class="line">pexpire 【key】 3  # 设置3毫秒过期</span><br><span class="line">persist 【key】  # 移除 key 的过期时间，key 将持久保持。</span><br></pre></td></tr></table></figure></li>
<li>设置和删除<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set 【key】 【value】</span><br><span class="line">del 【key】</span><br></pre></td></tr></table></figure></li>
<li>删除当前db&#x2F;所有db的所有key<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushdb</span><br><span class="line">flushall</span><br></pre></td></tr></table></figure></li>
<li>批量删除key<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-cli -h 127.0.0.1 -p 6379 -a【密码】keys a_* | xargs ./redis-cli -h 127.0.0.1 -p 6379 -a【密码】 del</span><br><span class="line">&lt;!-- redis是单线程，如果redis包含了大量的键，执行keys命令可能会造成redis阻塞，所以一般建议不要在生产环境下使用keys，使用scan命令渐进式的遍历所有键，可以有效防止阻塞。 --&gt;</span><br><span class="line">./redis-cli -h 127.0.0.1 -p 6379 -a【密码】--scan --pattern &#x27;a_*&#x27; | xargs ./redis-cli -h 127.0.0.1 -p 6379 -a【密码】del</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>string<br> string 是 redis 最基本的类型，一个 key 对应一个 value。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set 【key】【value】  # 设置</span><br><span class="line">get 【key】  # 获取字符串</span><br><span class="line">strlen 【key】  # 获取字符串长度</span><br><span class="line">del 【key】  # 删除</span><br><span class="line">string 类型的值最大能存储 512MB</span><br></pre></td></tr></table></figure></li>
<li>hash<br> hash 是一个 string 类型的 field 和 value 的映射表， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset【key】 A &#x27;a&#x27; B &#x27;b&#x27;  # 设置</span><br><span class="line">hget 【key】A / hget 【key】B  # 获取单个</span><br><span class="line">hgetall 【key】  # 获取所有键值对，其中奇数为filed值,偶数为对应的value值</span><br><span class="line">hlen 【key】  # 获取hash键值对数量</span><br><span class="line">hkeys 【key】  # 获取所有key</span><br><span class="line">hvals 【key】  # 获取所有val</span><br><span class="line">del 【key】  # 删除</span><br><span class="line">hdel 【key】【field】  # 删除hash中某个字段及其值</span><br><span class="line">每个 hash 可以存储 2^32 -1 键值对（40多亿）</span><br></pre></td></tr></table></figure></li>
<li>list<br> list 是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpush 【key】 a  # 右插入</span><br><span class="line">lpush 【key】 b  # 左插入</span><br><span class="line">lset 【key】 【index】 &quot;del&quot;  # 替换列表第index的原始</span><br><span class="line">lindex 【key】【index】  # 查看列表指定index的元素</span><br><span class="line">lrange 【key】 0 1  # 查看列表所有元素</span><br><span class="line">llen 【key】  # 查看列表元素个数</span><br><span class="line">del 【key】  # 删除列表</span><br><span class="line">lrem 【key】0 &quot;value&quot; //从key中删除全部等值value的元素 0为全部，负值为从尾部开始</span><br><span class="line">列表最多可存储 2^32 - 1 元素 (4294967295, 每个列表可存储40多亿)</span><br></pre></td></tr></table></figure></li>
<li>set<br> Set 是 string 类型的无序集合。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd 【key】  # 插入集合元素</span><br><span class="line">scard 【key】  # 集合元素个数</span><br><span class="line">smembers 【key】  # 查看集合元素</span><br><span class="line">del 【key】  # 删除集合</span><br><span class="line">srem 【key】【元素1】 【元素2】 # 删除集合一个或多个成员元素，不存在的成员元素会被忽略</span><br><span class="line">集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)</span><br></pre></td></tr></table></figure></li>
<li>zset<br> zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br> 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br> zset的成员是唯一的,但分数(score)却可以重复   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd 【key】【score1】 【元素1】 【score2】 【元素2】  # 插入或更新集合元素分值</span><br><span class="line">zcard 【key】  # 集合元素个数</span><br><span class="line">zcount 【key】【min】【max】  # 计算有序集合中元素个数</span><br><span class="line"></span><br><span class="line">ZRANGE key start stop  # 通过索引区间返回有序集合指定区间内的成员</span><br><span class="line">zrange 【key】 0 -1  # 查看所有原素</span><br><span class="line">ZRANGEBYLEX 【key】【min】【max】  # 通过字典区间返回有序集合的成员 </span><br><span class="line">ZRANGEBYSCORE 【key】【min】【max】  # 通过分数返回有序集合指定区间内的成员</span><br><span class="line"></span><br><span class="line">ZSCORE 【key】 【member】  # 返回有序集中，成员的分数值</span><br><span class="line">del 【key】  # 删除集合</span><br><span class="line">ZREM【key】【member】 [member ...]  # 移除有序集合中的一个或多个成员</span><br><span class="line">集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><h3 id="基本参数名"><a href="#基本参数名" class="headerlink" title="基本参数名"></a>基本参数名</h3><ol>
<li>mem_fragmentation_ratio &#x3D; used_memory_rss&#x2F; used_memory<br> 内存碎片率</li>
<li>used_memory_rss<br> 操作系统实际分配给Redis的物理内存空间</li>
<li>used_memory<br> Redis为了保存数据实际申请使用的空间</li>
<li>如何清理内存碎片<ol>
<li>重启Redis实例<ol>
<li>如果Redis中的数据没有持久化，那么，数据就会丢失；</li>
<li>即使Redis数据持久化了，我们还需要通过AOF或RDB进行恢复，恢复时长取决于AOF或RDB的大小，如果只有一个Redis实例，恢复阶段无法提供服务。</li>
</ol>
</li>
<li>从4.0-RC3版本以后，Redis自身提供了一种内存碎片自动清理的方法<ol>
<li>Redis需要启用自动内存碎片清理<br> config set activedefrag yes</li>
<li>具体什么时候清理，会受到下面这两个参数的控制<ol>
<li>active-defrag-ignore-bytes 100mb<br> 表示内存碎片的字节数达到100MB时，开始清理；</li>
<li>active-defrag-threshold-lower 10<br> 表示内存碎片空间占操作系统分配给Redis的总空间比例达到10%时，开始清理。</li>
</ol>
</li>
<li>为了尽可能减少碎片清理对Redis正常请求处理的影响，自动内存碎片清理功能在执行时，还会监控清理操作占用的CPU时间，而且还设置了两个参数，分别用于控制清理操作占用的CPU时间比例的上、下限，既保证清理工作能正常进行，又避免了降低Redis性能。这两个参数具体如下：<ol>
<li>active-defrag-cycle-min 25<br> 表示自动清理过程所用CPU时间的比例不低于25%，保证清理能正常开展；</li>
<li>active-defrag-cycle-max 75<br> 示自动清理过程所用CPU时间的比例不高于75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞Redis，导致响应延迟升高。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ol>
<li>什么是Redis？<ol>
<li>Redis 是一种基于内存的数据库，因此读写非常快，常用作缓存、消息队列、分布式锁等场景。</li>
<li>Redis 提供多种数据类型：String(字符串)、Hash(哈希)、List(列表)、Set(集合)、Zset(有序集合)、Bitmaps(位图)、HyperLogLog(基数统计)、GEO(地理信息)、Stream(流)。并且对数据类型的操作都是原子性的，因为执行命令是单线程负责，不存在并发竞争问题。</li>
<li>Redis 还支持事务、持久化、Lua脚本、多种集群方案（主从复制、哨兵模式、切片机群模式）、发布&#x2F;订阅模式、内存淘汰机制、过期删除机制等。</li>
</ol>
</li>
<li>Redis 和 Memcached 有什么区别？<ol>
<li>相同点<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
</li>
<li>不同点<ol>
<li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li>
<li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li>
<li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li>
</ol>
</li>
</ol>
</li>
<li>为什么用 Redis 作为 MySQL 的缓存？<ol>
<li>主要是因为 Redis 具备「高性能」和「高并发」两种特性。</li>
<li>高性能：访问 MySQL 数据是从硬盘读取，比较慢。而数据缓存在redis中，就是直接读取内存，速度非常快。</li>
<li>高并发：单台设备的redis的qps是mysql的10倍，能轻松突破10w，而mysql单机很难突破1w。</li>
</ol>
</li>
<li>Redis 数据类型以及使用场景分别是什么？<ol>
<li>Redis 提供了丰富的数据类型，常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。 <img src="./redis常用5种数据结构.webp" width = "50%" height = "50%" alt="redis常用5种数据结构" align=center /></li>
<li>应用场景<ol>
<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li>
<li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
</ol>
</li>
</ol>
</li>
<li>五种常见的 Redis 数据类型是怎么实现？</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://redis.io/">官网</a><br><a href="https://try.redis.io/">Redis 在线测试</a><br><a href="http://doc.redisfans.com/">Redis 命令参考</a><br><a href="https://www.runoob.com/redis/redis-tutorial.html">Redis 教程</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>sanic</title>
    <url>/%E6%A1%86%E6%9E%B6/sanic/</url>
    <content><![CDATA[<p>下一代 Python Web 服务器&#x2F;框架</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>是什么<br> Sanic 是 Python Web 服务器和 Web 框架，旨在提高性能。<br> Sanic 不仅仅是一个 框架，它还是一个 Web 服务器，具备开箱即用的功能。<br> 它可以用于编写，部署和扩展生产级 Web 应用程序。 🚀<br> Build fast. Run fast.</li>
<li>目标<br> 提供一种简单且快速，集创建和启动于一体的方法，来实现一个易于修改和拓展的 HTTP 服务</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos7 安装 python3.9</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line">wget https://www.python.org/ftp/python/3.9.10/Python-3.9.10.tgz</span><br><span class="line">tar xvf Python-3.9.10.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.9.10/</span><br><span class="line">./configure --enable-optimizations</span><br><span class="line">sudo make altinstall</span><br><span class="line">/usr/local/bin/python3.9 -m pip install --upgrade pip</span><br><span class="line">pip39 install virtualenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装sanic 23.3.0</span></span><br><span class="line">pip install sanic</span><br><span class="line"><span class="comment"># 安装扩展</span></span><br><span class="line">pip install sanic-ext</span><br></pre></td></tr></table></figure>


<h2 id="实践-helloworld"><a href="#实践-helloworld" class="headerlink" title="实践-helloworld"></a>实践-helloworld</h2><ol>
<li>编辑server.py <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Sanic</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> text, json</span><br><span class="line"></span><br><span class="line">app = Sanic(<span class="string">&quot;MyHelloWorldApp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># return text(&quot;Hello, world.&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> json(&#123;<span class="string">&#x27;hello&#x27;</span>: <span class="string">&#x27;world&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(</span><br><span class="line">        host=<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">        port=<span class="number">8000</span>,</span><br><span class="line">        workers=<span class="number">1</span>,</span><br><span class="line">        debug=<span class="literal">True</span>,</span><br><span class="line">        access_log=<span class="literal">True</span>,  <span class="comment"># 访问日志开关，进针对自带日志有效，自定义的无效</span></span><br><span class="line">        auto_reload=<span class="literal">True</span>,  <span class="comment"># 自动重载代码</span></span><br><span class="line">        dev=<span class="literal">True</span>,  <span class="comment"># 等价于debug+auto_reload</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li>运行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python server.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行验证</span></span><br><span class="line">curl localhost:8000 -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器请求服务</span></span><br><span class="line">http://&lt;服务器IP&gt;:8000</span><br><span class="line"><span class="comment"># 查看OpenAPI和运行的功能</span></span><br><span class="line">http://&lt;服务器IP&gt;:8000/docs</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="实践-docker"><a href="#实践-docker" class="headerlink" title="实践-docker"></a>实践-docker</h2><ol>
<li><p>Dockerfile</p>
 <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> sanicframework/sanic:<span class="number">3.8</span>-latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /sanic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;server.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
<li><p>server.py</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;docker_sanic</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Request, Sanic</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> text</span><br><span class="line"></span><br><span class="line">app = Sanic(<span class="string">&quot;MySanicApp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;OK!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>构建启动</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t my-sanic-image .</span><br><span class="line">docker run --name mysanic -p 8000:8000 -d my-sanic-image</span><br><span class="line"><span class="comment"># 浏览器输入</span></span><br><span class="line">http://&lt;服务器IP&gt;:8000/</span><br></pre></td></tr></table></figure></li>
<li><p>nginx_sanic.conf</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://mysanic:8000/;</span><br><span class="line">      proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">      proxy_set_header Connection upgrade;</span><br><span class="line">      proxy_set_header Accept-Encoding gzip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>docker-compose.yml</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysanic:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-sanic-image</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mynginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.13.6-alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysanic</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysanic.conf:/etc/nginx/conf.d/mysanic.conf</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 浏览器输入</span></span><br><span class="line">http://&lt;服务器IP&gt;:80/</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;测试sanic框架</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&quot;jesonlin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Request, Sanic</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> text, empty, file, redirect</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> json <span class="keyword">as</span> rsp_json</span><br><span class="line"><span class="keyword">from</span> sanic.handlers <span class="keyword">import</span> ErrorHandler</span><br><span class="line"></span><br><span class="line"><span class="comment"># from sanic.log import logger</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> LOGGING_CONFIG</span><br><span class="line"></span><br><span class="line"><span class="comment"># from sanic_ext import openapi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义request.id属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRequest</span>(<span class="title class_ inherited__">Request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;重载request加入请求id&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_id</span>(<span class="params">cls, *_</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;请求id默认自带就是用uuid&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> uuid.uuid4()</span><br><span class="line">        <span class="comment"># return time.time_ns()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义错误响应函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomErrorHandler</span>(<span class="title class_ inherited__">ErrorHandler</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义错误响应函数&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">default</span>(<span class="params">self, request, exception</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;handles errors that have no error handlers assigned&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 自定义的错误处理逻辑</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这里发生错误|%s&quot;</span> % exception)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().default(request, exception)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DIR_BASE = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">DIR_LOG = <span class="string">&quot;&#123;&#125;/logs&quot;</span>.<span class="built_in">format</span>(DIR_BASE)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(DIR_LOG):</span><br><span class="line">    os.makedirs(DIR_LOG)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化app</span></span><br><span class="line">app = Sanic(<span class="string">&quot;MyHelloWorldApp&quot;</span>, request_class=MyRequest, error_handler=CustomErrorHandler(), log_config=LOGGING_CONFIG)</span><br><span class="line"><span class="comment"># 上下文对象</span></span><br><span class="line"><span class="comment"># app.ctx.db = Database()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过配置文件加载更新配置</span></span><br><span class="line">app.update_config(<span class="string">&quot;./config.py&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># @openapi.no_autodoc  # 忽略生成文档</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;第一个sanic接口</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这是sanic的第一个接口，这里是接口注释。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    openapi:</span></span><br><span class="line"><span class="string">    ---</span></span><br><span class="line"><span class="string">    operationId: fooDots</span></span><br><span class="line"><span class="string">    tags:</span></span><br><span class="line"><span class="string">      - API</span></span><br><span class="line"><span class="string">    parameters:</span></span><br><span class="line"><span class="string">        - name: name</span></span><br><span class="line"><span class="string">          in: query</span></span><br><span class="line"><span class="string">          description: 用户名</span></span><br><span class="line"><span class="string">          required: True</span></span><br><span class="line"><span class="string">          schema:</span></span><br><span class="line"><span class="string">            type: string</span></span><br><span class="line"><span class="string">            format: str</span></span><br><span class="line"><span class="string">        - name: age</span></span><br><span class="line"><span class="string">          in: query</span></span><br><span class="line"><span class="string">          description: 用户年龄</span></span><br><span class="line"><span class="string">          required: False</span></span><br><span class="line"><span class="string">          schema:</span></span><br><span class="line"><span class="string">            type: integer</span></span><br><span class="line"><span class="string">            format: int32</span></span><br><span class="line"><span class="string">    responses:</span></span><br><span class="line"><span class="string">      &#x27;200&#x27;:</span></span><br><span class="line"><span class="string">        description: Just some dots</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">&quot;Here is your logssss: hello_world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return text(&quot;hello world.&quot;)</span></span><br><span class="line">    <span class="comment"># return rsp_json(&#123;&quot;hello&quot;: &quot;world&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">return</span> rsp_json(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;token&quot;</span>: request.token,</span><br><span class="line">            <span class="string">&quot;user&quot;</span>: request.ctx.user,</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="built_in">str</span>(request.<span class="built_in">id</span>),</span><br><span class="line">            <span class="string">&quot;AUTO_RELOAD&quot;</span>: app.config.AUTO_RELOAD,</span><br><span class="line">            <span class="string">&quot;REQUEST_TIMEOUT&quot;</span>: app.config.REQUEST_TIMEOUT,</span><br><span class="line">            <span class="string">&quot;config&quot;</span>: <span class="built_in">str</span>(app.config),</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 响应函数: https://sanic.dev/zh/guide/basics/handlers.html#%E5%85%B3%E4%BA%8E-async-a-word-about-async</span></span><br><span class="line"><span class="comment"># 响应函数(Handlers)，也就是我们通常所说的视图(views)。</span></span><br><span class="line"><span class="comment"># 它至少以一个 request 实例作为参数，并返回一个 HTTPResponse 实例或一个执行其他操作的协同程序作为响应。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/async&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_handler</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;异步响应接口，请求体&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># json -d &#x27;&#123;&quot;foo&quot;: &quot;bar&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.json)  <span class="comment"># &#123;&#x27;foo&#x27;: &#x27;bar&#x27;&#125;</span></span><br><span class="line">    <span class="comment"># raw -d &#x27;&#123;&quot;foo&quot;: &quot;bar&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.body)  <span class="comment"># b&#x27;&#123;&quot;foo&quot;: &quot;bar&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="comment"># form -d &#x27;foo=bar&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.body)  <span class="comment"># b&#x27;foo=bar&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.form)  <span class="comment"># &#123;&#x27;foo&#x27;: [&#x27;bar&#x27;]&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(request.form.get(<span class="string">&quot;foo&quot;</span>))  <span class="comment"># bar</span></span><br><span class="line">    <span class="built_in">print</span>(request.form.getlist(<span class="string">&quot;foo&quot;</span>))  <span class="comment"># [&#x27;bar&#x27;]</span></span><br><span class="line">    <span class="comment"># upload -F &#x27;my_file=@/path/to/TEST&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.body)</span><br><span class="line">    <span class="built_in">print</span>(request.files)  <span class="comment"># &#123;&#x27;my_file&#x27;: [File(type=&#x27;application/octet-stream&#x27;, body=b&#x27;hello\n&#x27;, name=&#x27;TEST&#x27;)]&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(request.files.get(<span class="string">&quot;my_file&quot;</span>))  <span class="comment"># File(type=&#x27;application/octet-stream&#x27;, body=b&#x27;hello\n&#x27;, name=&#x27;TEST&#x27;)</span></span><br><span class="line">    <span class="built_in">print</span>(request.files.getlist(<span class="string">&quot;my_file&quot;</span>))  <span class="comment"># [File(type=&#x27;application/octet-stream&#x27;, body=b&#x27;hello\n&#x27;, name=&#x27;TEST&#x27;)]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rsp_json(&#123;<span class="string">&quot;async_handlerf&quot;</span>: <span class="string">&quot;Done.&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 请求: https://sanic.dev/zh/guide/basics/request.html</span></span><br><span class="line"><span class="comment"># 所有的 响应函数 都必须返回一个 response 对象，中间件 可以自由选择是否返回 response 对象。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_fetch_user_by_token</span>(<span class="params">token</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;异步根据token获取用户名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;jesonlin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.middleware(<span class="params"><span class="string">&quot;request&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run_before_handler</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;request中间件封装参数进上下文对象</span></span><br><span class="line"><span class="string">    通常被用来存储服务端通过某些验证后需要临时存储的身份认证信息以及专有变量等内容。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    request.ctx.user = <span class="keyword">await</span> _fetch_user_by_token(request.token)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/ctx&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ctx</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试上下文对象取值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这里是接口内部&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;Hi, my name is &#123;&#125;\napp.ctx is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(request.ctx.user, app.ctx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.route(&quot;/route_tag/&lt;tag:int&gt;&quot;)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">r&quot;/route_tag/&lt;tag:[a-z]&#123;3&#125;.txt&gt;&quot;</span>, name=<span class="string">&quot;get_route_tag&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">route_tag</span>(<span class="params">request, tag: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试提取路径部分参数</span></span><br><span class="line"><span class="string">    &lt;tag:int&gt;  路径参数强制转换为int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;tag: %s\n args: %s&quot;</span> % (tag, request.args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/args/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">args</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回请求参数&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 和上述的 request.form、request.files 对象一样，request.args 同样是少数几种字典之一，每个值都是一个列表。这是因为HTTP允许单个键名被重用以发送多个值。</span></span><br><span class="line">    <span class="built_in">print</span>(request.args)</span><br><span class="line">    <span class="comment"># curl &#x27;http://localhost:8000/print_args?key1=val1&amp;key2=val2&amp;key1=\[val3\]&#x27;</span></span><br><span class="line">    <span class="comment"># &#123;&#x27;key1&#x27;: [&#x27;val1&#x27;, &#x27;[val3]&#x27;], &#x27;key2&#x27;: [&#x27;val2&#x27;]&#125;</span></span><br><span class="line">    <span class="comment"># &#x27;val1&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.args.get(<span class="string">&quot;key1&quot;</span>))</span><br><span class="line">    <span class="comment"># [&#x27;val1&#x27;, &#x27;[val3]&#x27;]</span></span><br><span class="line">    <span class="built_in">print</span>(request.args.getlist(<span class="string">&quot;key1&quot;</span>))</span><br><span class="line">    <span class="comment"># [(&#x27;key1&#x27;, &#x27;val1&#x27;), (&#x27;key2&#x27;, &#x27;val2&#x27;), (&#x27;key1&#x27;, &#x27;[val3]&#x27;)]</span></span><br><span class="line">    <span class="built_in">print</span>(request.query_args)</span><br><span class="line">    <span class="comment"># key1=val1&amp;key2=val2&amp;key1=[val3]</span></span><br><span class="line">    <span class="built_in">print</span>(request.query_string)</span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;args - type:&#123;&#125; - value:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(request.args), request.args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 响应: https://sanic.dev/zh/guide/basics/response.html</span></span><br><span class="line"><span class="comment"># 所有的 响应函数 都必须返回一个 response 对象，中间件 可以自由选择是否返回 response 对象。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/response/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">response</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试响应函数返回不同类型&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># return text(&quot;Hi 😎&quot;)</span></span><br><span class="line">    <span class="comment"># return rsp_json(&#123;&quot;foo&quot;: &quot;bar&quot;&#125;)</span></span><br><span class="line">    <span class="comment"># return redirect(&quot;/hi&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> file(<span class="string">&quot;A.jpg&quot;</span>)</span><br><span class="line">    <span class="comment"># return empty()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/route&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="comment"># @app.post(&quot;/route&quot;)</span></span><br><span class="line"><span class="comment"># @app.get(&quot;/route&quot;)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">route</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;中间件添加路由&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 路由: https://sanic.dev/zh/guide/basics/routing.html#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1-adding-a-route</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/dynamic_route&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dynamic_route</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;动态路由&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 您可以传递任意数量的关键字参数，任何非路由参数的部分都会被是做为查询字符串的一部分</span></span><br><span class="line">    <span class="comment"># 同样支持为一个键名传递多个值</span></span><br><span class="line">    <span class="comment"># url = app.url_for(&quot;route_tag&quot;, tag=&quot;abc.txt&quot;, arg_one=[&quot;one&quot;, &quot;two&quot;])</span></span><br><span class="line">    <span class="comment"># 有路由名称name则只能通过路由名称name</span></span><br><span class="line">    url = app.url_for(<span class="string">&quot;get_route_tag&quot;</span>, tag=<span class="string">&quot;abc.txt&quot;</span>, arg_one=[<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> redirect(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 监听器: https://sanic.dev/zh/guide/basics/listeners.html</span></span><br><span class="line"><span class="comment"># 允许您将功能挂载到工作进程的生命周期</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.reload_process_start</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">reload_process_start</span>(<span class="params">*_</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听重载进程，只一次&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听重载进程 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.main_process_start</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_process_start</span>(<span class="params">*_</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听启动程序进程，只一次&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听主程序启动 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_server_start</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">before_server_start</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听服务启动前&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听服务启动前 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line">    app.ctx.db = <span class="string">&quot;DB_INFO&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_server_start</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">after_server_start</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听服务启动后&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听服务启动后 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_server_stop</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">before_server_stop</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听服务结束前&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听服务结束前 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_server_stop</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">after_server_stop</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听服务结束后&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听服务结束后 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.main_process_stop</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_process_stop</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听器 设置DB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听主程序结束 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 中间件: https://sanic.dev/zh/guide/basics/middleware.html</span></span><br><span class="line"><span class="comment"># 中间件允许您将功能挂载到 HTTP 流的生命周期。</span></span><br><span class="line"><span class="comment"># 可以在执行响应函数之前或者响应函数之后执行中间件</span></span><br><span class="line"><span class="comment"># 如果中间件返回了一个 HTTPResponse 对象， 那么请求将会终止，此对象将会作为最终响应进行返回。</span></span><br><span class="line"><span class="comment"># 返回 None 值来跳过某个中间件的执行</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># @app.middleware(&quot;request&quot;)</span></span><br><span class="line"><span class="meta">@app.on_request  </span><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">extract_user</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;请求中间件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_response</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">prevent_xss</span>(<span class="params">request, response</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;响应中间件&quot;&quot;&quot;</span></span><br><span class="line">    response.headers[<span class="string">&quot;X-Request-ID&quot;</span>] = request.<span class="built_in">id</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 标头: https://sanic.dev/zh/guide/basics/headers.html</span></span><br><span class="line"><span class="comment"># 令牌(Token)：从请求头中解析到的 Token &lt;token&gt; 或者 Bearer &lt;token&gt; 将会被赋值给 request.token</span></span><br><span class="line"><span class="comment"># 请求头、响应头</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/hosts&quot;</span>, name=<span class="string">&quot;foo&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hosts</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查看hosts 信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rsp_json(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;effective host&quot;</span>: request.host,  <span class="comment"># &quot;&lt;服务器IP&gt;:8000&quot;</span></span><br><span class="line">            <span class="string">&quot;host header&quot;</span>: request.headers.get(<span class="string">&quot;host&quot;</span>),  <span class="comment"># &quot;&lt;服务器IP&gt;:8000&quot;</span></span><br><span class="line">            <span class="string">&quot;forwarded host&quot;</span>: request.forwarded.get(<span class="string">&quot;host&quot;</span>),  <span class="comment"># null</span></span><br><span class="line">            <span class="string">&quot;you are here&quot;</span>: request.url_for(<span class="string">&quot;foo&quot;</span>),  <span class="comment"># &quot;http://&lt;服务器IP&gt;:8000/hosts&quot;</span></span><br><span class="line">            <span class="string">&quot;all&quot;</span>: <span class="built_in">list</span>(request.headers.items()),</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># cookies: https://sanic.dev/zh/guide/basics/cookies.html#%E8%AF%BB%E5%8F%96-reading</span></span><br><span class="line"><span class="comment"># 通过 Request 对象的 cookies 字典来访问 Cookies。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cookie&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">cookie</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取cookies&quot;&quot;&quot;</span></span><br><span class="line">    test_cookie = request.cookies.get(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    rsp = text(<span class="string">&quot;Test cookie: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(test_cookie))</span><br><span class="line">    <span class="comment"># 写入cookies</span></span><br><span class="line">    rsp.cookies[<span class="string">&quot;test&quot;</span>] = <span class="string">&quot;cookies insert test&quot;</span></span><br><span class="line">    <span class="keyword">return</span> rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 后台任务: https://sanic.dev/zh/guide/basics/tasks.html#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1-creating-tasks</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_task</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;后台任务&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;MY TASK - PID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/data/service/python_project/project_sanic/task.txt&quot;</span>, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;begint run...\n&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    app.add_task(my_task(app))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个子进程都有</span></span><br><span class="line"><span class="comment"># app.add_task(slow_work)</span></span><br><span class="line"><span class="comment"># 通过任务别名查看任务</span></span><br><span class="line"><span class="comment"># task = app.get_task(&quot;slow_task&quot;)</span></span><br><span class="line"><span class="comment"># print(&quot;task=%s&quot; % task)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想只为主进程添加任务，您应该考虑使用 @app.main_process_start添加任务。</span></span><br><span class="line"><span class="meta">@app.before_server_start  </span><span class="comment"># 每个子进程都有</span></span><br><span class="line"><span class="comment"># @app.main_process_start  # 没效果，暂不知道原因</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_outer_task</span>(<span class="params">app, loop</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=====&gt;&gt;&gt;&gt;开始添加任务&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">&quot;=====&gt;&gt;&gt;&gt;开始添加任务&quot;</span>)</span><br><span class="line">    app.add_task(my_task(app))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 装饰器: https://sanic.dev/zh/guide/best-practices/decorators.html</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">check_request_for_authorization_status</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;验证权限&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authorized</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;权限装饰器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">f</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">f</span>)</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">decorated_function</span>(<span class="params">request, *args, **kwargs</span>):</span><br><span class="line">            <span class="comment"># run some method that checks the request</span></span><br><span class="line">            <span class="comment"># for the client&#x27;s authorization status</span></span><br><span class="line">            is_authorized = <span class="keyword">await</span> check_request_for_authorization_status(request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_authorized:</span><br><span class="line">                <span class="comment"># the user is authorized.</span></span><br><span class="line">                <span class="comment"># run the handler method and return the response</span></span><br><span class="line">                rsp = <span class="keyword">await</span> f(request, *args, **kwargs)</span><br><span class="line">                <span class="keyword">return</span> rsp</span><br><span class="line">            <span class="comment"># the user is not authorized.</span></span><br><span class="line">            <span class="keyword">return</span> rsp_json(&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;not_authorized&quot;</span>&#125;, <span class="number">403</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorated_function</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 日志: https://sanic.dev/zh/guide/best-practices/logging.html</span></span><br><span class="line"><span class="comment"># 默认日志， from sanic.log import logger  logger.info(&quot;&quot;&quot;)</span></span><br><span class="line"><span class="comment"># 自定义日志</span></span><br><span class="line"><span class="comment"># import logging</span></span><br><span class="line"><span class="comment"># DIR_BASE = os.path.dirname(os.path.abspath(__file__))</span></span><br><span class="line"><span class="comment"># DIR_LOG = &quot;&#123;&#125;/logs&quot;.format(DIR_BASE)</span></span><br><span class="line"><span class="comment"># if not os.path.exists(DIR_LOG):</span></span><br><span class="line"><span class="comment">#     os.makedirs(DIR_LOG)</span></span><br><span class="line"><span class="comment"># LOGGING_CONFIG = &#123;</span></span><br><span class="line"><span class="comment">#     &quot;version&quot;: 1,</span></span><br><span class="line"><span class="comment">#     &quot;disable_existing_loggers&quot;: False,</span></span><br><span class="line"><span class="comment">#     &quot;formatters&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;verbose&quot;: &#123;&quot;format&quot;: &quot;[%(levelname)s %(asctime)s %(name)s %(lineno)d %(process)d %(thread)d] %(message)s&quot;&#125;</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &quot;handlers&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;console&quot;: &#123;</span></span><br><span class="line"><span class="comment">#             &quot;level&quot;: &quot;INFO&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;class&quot;: &quot;logging.StreamHandler&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;formatter&quot;: &quot;verbose&quot;,</span></span><br><span class="line"><span class="comment">#         &#125;,</span></span><br><span class="line"><span class="comment">#         &quot;backend_file&quot;: &#123;</span></span><br><span class="line"><span class="comment">#             &quot;delay&quot;: True,</span></span><br><span class="line"><span class="comment">#             &quot;class&quot;: &quot;logging.handlers.TimedRotatingFileHandler&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;filename&quot;: &quot;./logs/main.log&quot;,  # 日志输出文件</span></span><br><span class="line"><span class="comment">#             &quot;when&quot;: &quot;D&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;backupCount&quot;: 10,  # 备份份数</span></span><br><span class="line"><span class="comment">#             &quot;formatter&quot;: &quot;verbose&quot;,  # 使用哪种formatters日志格式</span></span><br><span class="line"><span class="comment">#             &quot;level&quot;: &quot;DEBUG&quot;,</span></span><br><span class="line"><span class="comment">#         &#125;,</span></span><br><span class="line"><span class="comment">#         &quot;backend_err_file&quot;: &#123;</span></span><br><span class="line"><span class="comment">#             &quot;delay&quot;: True,</span></span><br><span class="line"><span class="comment">#             &quot;class&quot;: &quot;logging.handlers.TimedRotatingFileHandler&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;filename&quot;: &quot;./logs/main_error.log&quot;,  # 日志输出文件</span></span><br><span class="line"><span class="comment">#             &quot;when&quot;: &quot;D&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;backupCount&quot;: 10,  # 备份份数</span></span><br><span class="line"><span class="comment">#             &quot;formatter&quot;: &quot;verbose&quot;,  # 使用哪种formatters日志格式</span></span><br><span class="line"><span class="comment">#             &quot;level&quot;: &quot;ERROR&quot;,</span></span><br><span class="line"><span class="comment">#         &#125;,</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &quot;loggers&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;&quot;: &#123;</span></span><br><span class="line"><span class="comment">#             &quot;handlers&quot;: [&quot;backend_file&quot;, &quot;backend_err_file&quot;],</span></span><br><span class="line"><span class="comment">#             &quot;level&quot;: &quot;INFO&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;propagate&quot;: False,</span></span><br><span class="line"><span class="comment">#         &#125;</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="comment"># logger = logging.getLogger(__name__)</span></span><br><span class="line"><span class="comment"># app = Sanic(&quot;MyHelloWorldApp&quot;, log_config=LOGGING_CONFIG)</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 运行: https://sanic.dev/zh/guide/deployment/running.html#sanic-%E6%9C%8D%E5%8A%A1%E5%99%A8-sanic-server</span></span><br><span class="line"><span class="comment"># 获取系统CPU核心数量</span></span><br><span class="line"><span class="comment"># workers = multiprocessing.cpu_count()</span></span><br><span class="line"><span class="comment"># app.run(host=&#x27;0.0.0.0&#x27;, port=8000, workers=workers, fast=True)</span></span><br><span class="line"><span class="comment"># gunicorn: 一个基于 UNIX 操作系统的 WSGI HTTP 服务器。它是从 Ruby 的 Unicorn 项目中移植而来，采用的是 pre-fork worker 模型。</span></span><br><span class="line"><span class="comment"># gunicorn myapp:app --bind 0.0.0.0:1337 --worker-class sanic.worker.GunicornWorker</span></span><br><span class="line"><span class="comment"># 如果您的应用有内存泄漏的困扰，您可以通过配置 Gunicorn 使子进程在处理了一定数量的请求后平滑重启。这种方法可以很方便得减少内存泄漏带来的影响。</span></span><br><span class="line"><span class="comment"># 当通过 gunicorn 运行 Sanic 时，您将失去 async/await 带来的诸多性能优势。对于该种部署方式，请三思而后行。的确，Gunicorn 提供了很多配置选项，但它不是让 Sanic 全速运行的最佳坏境。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(</span><br><span class="line">        host=<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">        port=<span class="number">8000</span>,</span><br><span class="line">        <span class="comment"># workers=workers,</span></span><br><span class="line">        fast=<span class="literal">True</span>,  <span class="comment"># 自动以系统最大的核心数量来创建工作线程</span></span><br><span class="line">        debug=<span class="literal">True</span>,</span><br><span class="line">        access_log=<span class="literal">True</span>,  <span class="comment"># 访问日志开关，进针对自带日志有效，自定义的无效</span></span><br><span class="line">        auto_reload=<span class="literal">True</span>,  <span class="comment"># 自动重载代码</span></span><br><span class="line">        <span class="comment"># dev=True,  # 等价于debug+auto_reload</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>


<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://sanic.dev/zh/">官网</a><br><a href="https://sanic.dev/zh/plugins/sanic-ext/openapi/autodoc.html">sanic-自助生成文档</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>sanic</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite3</title>
    <url>/%E5%AD%98%E5%82%A8/sqlite3/</url>
    <content><![CDATA[<p>SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。SQLite 源代码不受版权限制。</p>
<span id="more"></span>

<h2 id="SQL-命令分类"><a href="#SQL-命令分类" class="headerlink" title="SQL 命令分类"></a>SQL 命令分类</h2><ol>
<li>DDL - 数据定义语言 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE，ALTER，DROP</span><br></pre></td></tr></table></figure></li>
<li>DML - 数据操作语言 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT，UPDATE，DELETE</span><br></pre></td></tr></table></figure></li>
<li>DQL - 数据查询语言 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ol>
<li>创建数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 将会在当前目录下创建一个文件testDB.db --&gt;</span><br><span class="line">sqlite3 testDB.db </span><br></pre></td></tr></table></figure></li>
<li>显示数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.databases</span><br></pre></td></tr></table></figure></li>
<li>导出数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite3 testDB.db .dump &gt; testDB.sql</span><br></pre></td></tr></table></figure></li>
<li>导入到数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite3 testDB.db &lt; testDB.sql</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><ol>
<li>创建数据表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table if not exists tb_config_filter(id integer primary key autoincrement, instanceid varchar(255) default &#x27;&#x27;, instancename varchar(255) default &#x27;&#x27;, metricName varchar(255) default &#x27;&#x27;, metricsshowname varchar(255) default &#x27;&#x27;, metriclimit text default &#x27;&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>显示数据表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.tables</span><br></pre></td></tr></table></figure></li>
<li>删除表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [TABLE_NAME];</span><br></pre></td></tr></table></figure></li>
<li>显示建表语句 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.schema [TABLE_NAME]</span><br></pre></td></tr></table></figure></li>
<li>插入表数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME ([COLUMN1],...,[COLUMNN]) VALUES ([VALUE1],...,[VALUEN]);</span><br><span class="line">&lt;!-- 自增id字段值可用null替代或者不写 --&gt;</span><br><span class="line">insert into tb_config_filter(id, instancename) values(null, &#x27;cdb_yunying1_dev&#x27;);</span><br><span class="line">insert into tb_config_filter(metricsshowname) values(&#x27;CPU利用率&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>删除表数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name WHERE [CONDITION];</span><br><span class="line">&lt;!-- 删除单条 --&gt;</span><br><span class="line">delete from tb_config_filter where id=2;</span><br><span class="line">&lt;!-- 删除所有数据 --&gt;</span><br><span class="line">delete from tb_config_filter </span><br></pre></td></tr></table></figure></li>
<li>更新表数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [CONDITION];</span><br><span class="line">&lt;!-- 更新自增id --&gt;</span><br><span class="line">UPDATE sqlite_sequence SET seq = &lt;下一个自增ID&gt; WHERE name = &lt;TABLE_NAME&gt;; </span><br></pre></td></tr></table></figure></li>
<li>查询表数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &lt;COLUMN1&gt;, ..., &lt;COLUMNN&gt; FROM &lt;TABLE_NAME&gt; WHERE &lt;CONDITION&gt;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 显示当前设置 --&gt;</span><br><span class="line">.show</span><br><span class="line">&lt;!-- 显示字段名称 --&gt;</span><br><span class="line">.header on</span><br><span class="line">&lt;!-- 按列格式化显示，每列字段值长度有限，会被截断 --&gt;</span><br><span class="line">.mode column</span><br><span class="line">&lt;!-- 设置列宽度 --&gt;</span><br><span class="line">.width 60</span><br><span class="line">&lt;!-- 按行格式化显示 --&gt;</span><br><span class="line">.mode line</span><br><span class="line">&lt;!-- 按csv格式化显示 --&gt;</span><br><span class="line">.mode csv</span><br><span class="line">&lt;!-- 空按NULL显示 --&gt;</span><br><span class="line">.nullvalue NULL</span><br><span class="line">&lt;!-- 输出到文件/屏幕输出 --&gt;</span><br><span class="line">.output [FILENAME]/stdout    </span><br><span class="line">&lt;!-- 所有表信息查询 --&gt;</span><br><span class="line">sq</span><br><span class="line">&lt;!-- 会有一个表sqlite_sequence记录表名对应自增id --&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><ol>
<li>增加索引 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 单列索引 --&gt;</span><br><span class="line">CREATE INDEX &lt;INDEX_NAME&gt; ON &lt;TABLE_NAME&gt; (&lt;COLUMN_NAME&gt;);</span><br><span class="line">&lt;!-- 唯一索引 --&gt;</span><br><span class="line">CREATE UNIQUE INDEX &lt;INDEX_NAME&gt; ON &lt;TABLE_NAME&gt; (&lt;COLUMN_NAME&gt;);</span><br><span class="line">&lt;!-- 组合索引 --&gt;</span><br><span class="line">CREATE INDEX &lt;INDEX_NAME&gt; ON &lt;TABLE_NAME&gt; (&lt;COLUMN1_NAME&gt;, &lt;COLUMN2_NAME&gt;);</span><br></pre></td></tr></table></figure></li>
<li>删除索引 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name</span><br></pre></td></tr></table></figure></li>
<li>什么情况下要避免使用索引？<br> 虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则：  <ol>
<li>索引不应该使用在较小的表上。</li>
<li>索引不应该使用在有频繁的大批量的更新或插入操作的表上。</li>
<li>索引不应该使用在含有大量的 NULL 值的列上。</li>
<li>索引不应该使用在频繁操作的列上。</li>
</ol>
</li>
</ol>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line">conn = sqlite3.connect(&#x27;test.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">res = cursor.execute(&quot;create table if not exists tb_config_filter(id integer primary key autoincrement, instanceid varchar(255) default &#x27;&#x27;, instancename varchar(255) default &#x27;&#x27;, metricName varchar(255) default &#x27;&#x27;, metricsshowname varchar(255) default &#x27;&#x27;, metriclimit text default &#x27;&#x27;);&quot;)</span><br><span class="line">print(res)</span><br><span class="line">res = cursor.execute(&quot;CREATE INDEX idx_instanceid ON tb_config_filter (instanceid);&quot;)</span><br><span class="line">print(res)</span><br><span class="line">conn.commit()</span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>


<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017801751919456">使用sqlite</a><br><a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">SQLite 教程</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime</title>
    <url>/%E8%BD%AF%E4%BB%B6/sublime/</url>
    <content><![CDATA[<p>Sublime Text 是一款流行的代码编辑器软件，也是HTML和散文先进的文本编辑器，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。<br><a href="https://www.sublimetext.com/">sublime英文官网</a><br><a href="https://www.sublimetextcn.com/">sublime中文官网</a></p>
<span id="more"></span>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>打开&#x2F;关闭左侧目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【k】，【cmd】+【b】</span><br></pre></td></tr></table></figure></li>
<li>展开&#x2F;折叠代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【k】+【0】/【1】/【2】</span><br></pre></td></tr></table></figure></li>
<li>打开&#x2F;关闭标签页 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【w】</span><br></pre></td></tr></table></figure></li>
<li>全屏 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【ctrl】+【f】</span><br></pre></td></tr></table></figure></li>
<li>选中中到行首&#x2F;选中到行尾 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!-- 自定义快捷键 --&gt;</span><br><span class="line">【shift】+【home】/【end】</span><br></pre></td></tr></table></figure></li>
<li>打开终端terminus <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【fn】|【option】+【t】</span><br></pre></td></tr></table></figure></li>
<li>json 格式化&#x2F;反格式化 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 自定义快捷键 --&gt;</span><br><span class="line">【cmd】+【fn】|【opt】+【j】/【m】</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>根据<a href="https://www.sublimetext.com/docs/linux_repositories.html">官方地址</a>下载安装</p>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol>
<li><p>安装 Package Control 插件包管理器</p>
<ol>
<li>旧版本安装<ol>
<li>快捷键打开控制台 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + `</span><br></pre></td></tr></table></figure></li>
<li>输入代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &#x27;6f4c264a24d933ce70df5dedcf1dcaee&#x27; + &#x27;ebe013ee18cced0ef93d5f746d80ef60&#x27;; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#x27;http://packagecontrol.io/&#x27; + pf.replace(&#x27; &#x27;, &#x27;%20&#x27;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#x27;Error validating download (got %s instead of %s), please try manual install&#x27; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#x27;wb&#x27; ).write(by) </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>新版本安装<ol>
<li>快捷键打开查找栏 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 +【shift】+【p】</span><br></pre></td></tr></table></figure></li>
<li>输入如下回车安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Install Package Control</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>其他常规配置</p>
<ol>
<li>打开侧边栏 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【shift】+【p】-》view: toggle side bar  or (【cmd】+【k】/【b】)</span><br></pre></td></tr></table></figure></li>
<li>打开上边栏  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【shift】+【p】-》view: toggle tab</span><br></pre></td></tr></table></figure></li>
<li>设置主题、字体大小及tab等 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Preferences -&gt; Settings -&gt; User or 【cmd】+【,】</span><br><span class="line">&quot;font_size&quot;: 21,</span><br><span class="line">&quot;tab_size&quot;: 4,</span><br><span class="line">&quot;translate_tabs_to_spaces&quot;: true,</span><br><span class="line">&quot;theme&quot;: &quot;Monokai Classic.sublime-theme&quot;,</span><br><span class="line">&quot;color_scheme&quot;: &quot;Monokai Classic.sublime-color-scheme&quot;,</span><br><span class="line">&quot;show_full_path&quot;: true,</span><br><span class="line">&quot;save_on_focus_lost&quot;: false,</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="插件安装-步骤"><a href="#插件安装-步骤" class="headerlink" title="插件安装-步骤"></a>插件安装-步骤</h2><ol>
<li>所有插件安装都是通过插件包管理器</li>
<li>【cmd】+【shift】+【p】</li>
<li>Install Package</li>
<li>输入对应插件名称</li>
</ol>
<h2 id="monikai-主题"><a href="#monikai-主题" class="headerlink" title="monikai 主题"></a>monikai 主题</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theme-monokai pro</span><br></pre></td></tr></table></figure></li>
<li>配置主题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」-&gt; 「Package Settings」-&gt; 「Theme-Monokai Pro」-&gt; 选择「Monikai Classic」</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="sidebar强化"><a href="#sidebar强化" class="headerlink" title="sidebar强化"></a>sidebar强化</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SideBarEnhancements</span><br></pre></td></tr></table></figure></li>
<li>配置主题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」-&gt; 「Package Settings」-&gt; 「Theme-Monokai Pro」-&gt; 选择「Side Bar」</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="terminal-终端"><a href="#terminal-终端" class="headerlink" title="terminal 终端"></a>terminal 终端</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">terminus</span><br></pre></td></tr></table></figure></li>
<li>配置快捷键 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」 -&gt; 「Key Bindings」 -&gt; 「User」</span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+fn+t&quot;], &quot;command&quot;: &quot;toggle_terminus_panel&quot;&#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="json-格式化"><a href="#json-格式化" class="headerlink" title="json 格式化"></a>json 格式化</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pretty_json</span><br></pre></td></tr></table></figure></li>
<li>配置快捷键 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」 -&gt; 「Key Bindings」 -&gt; 「User」</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;command+fn+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;,</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;command+option+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;,</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;command+fn+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;,</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;command+option+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="black-Python代码格式化"><a href="#black-Python代码格式化" class="headerlink" title="black-Python代码格式化"></a>black-Python代码格式化</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sublack</span><br></pre></td></tr></table></figure></li>
<li>配置快捷键 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」-&gt; 「Package Settings」-&gt; 「sublack」-&gt;「Settings」</span><br><span class="line">&#123;</span><br><span class="line">    &quot;black_on_save&quot;: false,</span><br><span class="line">    &quot;black_line_length&quot;: 80,</span><br><span class="line">    &quot;black_command&quot;: &quot;/Users/jesonlin/Library/Python/3.8/bin/black&quot;,</span><br><span class="line">&#125;</span><br><span class="line">「Preference」 -&gt; 「Key Bindings」 -&gt; 「User」</span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+fn+b&quot;], &quot;command&quot;: &quot;black_file&quot;&#125;, </span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+option+b&quot;], &quot;command&quot;: &quot;black_file&quot;&#125;, </span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+fn+shift+b&quot;], &quot;command&quot;: &quot;black_diff&quot;&#125;, </span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+option+shift+b&quot;], &quot;command&quot;: &quot;black_diff&quot;&#125;, </span><br></pre></td></tr></table></figure></li>
<li>依赖python环境   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 intall black</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SublimeLinter-pylint和flake8检查python代码"><a href="#SublimeLinter-pylint和flake8检查python代码" class="headerlink" title="SublimeLinter-pylint和flake8检查python代码"></a>SublimeLinter-pylint和flake8检查python代码</h1><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SublimeLinter</span><br></pre></td></tr></table></figure></li>
<li>配置快捷键 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」-&gt; 「Package Settings」-&gt; 「SublimeLinter」-&gt;「Settings」</span><br><span class="line">// SublimeLinter Settings - User</span><br><span class="line">&#123;</span><br><span class="line">    &quot;linters&quot;: &#123;</span><br><span class="line">        &quot;pylint&quot;: &#123;</span><br><span class="line">            &quot;disable&quot;: false,</span><br><span class="line">            &quot;args&quot;: [&quot;--max-line-length=120&quot;],</span><br><span class="line">            &quot;executable&quot;: &quot;/Users/jesonlin/Library/Python/3.9/bin/pylint&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">            // Exclude files that match the given pattern(s).</span><br><span class="line">            &quot;excludes&quot;: [&quot;!*.py&quot;],</span><br><span class="line">            // E.g. [&quot;warning: &quot;, &quot;W3\d\d: &quot;, &quot;missing &lt;!DOCTYPE&gt; declaration&quot;]</span><br><span class="line">            &quot;filter_errors&quot;: [&quot;R0903&quot;,&quot;E0401&quot;,&quot;C0111&quot;,&quot;I0011&quot;,&quot;I0012&quot;,&quot;W0704&quot;,&quot;W0142&quot;,&quot;W0212&quot;,&quot;W0232&quot;,&quot;W0613&quot;,&quot;W0702&quot;,&quot;R0201&quot;,&quot;W0614&quot;,&quot;R0914&quot;,&quot;R0912&quot;,&quot;R0915&quot;,&quot;R0913&quot;,&quot;R0904&quot;,&quot;R0801&quot;,&quot;C0209&quot;],</span><br><span class="line">            &quot;lint_mode&quot;: &quot;background&quot;,</span><br><span class="line">            &quot;selector&quot;: &quot;&quot;,</span><br><span class="line">            &quot;styles&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;codes&quot;: [&quot;&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            // The current working dir the lint job will run in.</span><br><span class="line">            &quot;working_dir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;python&quot;: 3,</span><br><span class="line">            &quot;disable_if_not_dependency&quot;: false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;flake8&quot;: &#123;</span><br><span class="line">            &quot;disable&quot;: false,</span><br><span class="line">            &quot;args&quot;: [&quot;--max-line-length=120&quot;],</span><br><span class="line">            &quot;executable&quot;: &quot;/Users/jesonlin/Library/Python/3.9/bin/flake8&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;&#125;,</span><br><span class="line">            // Exclude files that match the given pattern(s).</span><br><span class="line">            &quot;excludes&quot;: [&quot;!*.py&quot;],</span><br><span class="line">            &quot;filter_errors&quot;: [&quot;E203&quot;],</span><br><span class="line">            &quot;lint_mode&quot;: &quot;background&quot;,</span><br><span class="line">            &quot;selector&quot;: &quot;&quot;,</span><br><span class="line">            &quot;styles&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;codes&quot;: [&quot;&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;working_dir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;python&quot;: 3,</span><br><span class="line">            &quot;disable_if_not_dependency&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>依赖pylint和flake8 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pylint</span><br><span class="line">pip3 install flake8</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="auto-refresh"><a href="#auto-refresh" class="headerlink" title="auto refresh"></a>auto refresh</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto refresh</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="SFTP"><a href="#SFTP" class="headerlink" title="SFTP"></a>SFTP</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sftp</span><br></pre></td></tr></table></figure></li>
<li>配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「File」-&gt; 「SFT|FTP」-&gt;「Setup Server」-&gt;打开文件编辑保存即可</span><br><span class="line">&quot;host&quot;: &quot;XXX.XXX.XXX.XXX&quot;,</span><br><span class="line">&quot;user&quot;: &quot;root&quot;,</span><br><span class="line">&quot;password&quot;: &quot;XXX&quot;,</span><br><span class="line">&quot;remote_path&quot;: &quot;XXX&quot;,</span><br></pre></td></tr></table></figure></li>
<li>使用<ol>
<li>同步到本地<ol>
<li>新建一个待同步的空白文件夹</li>
<li>在文件名右键「SFTP|FTP」-&gt;「Map to Remote」-&gt; 弹出文件配置远程信息保存 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;host&quot;: &quot;XXX.XXX.XXX.XXX&quot;,</span><br><span class="line">    &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;XXX&quot;,</span><br><span class="line">&quot;remote_path&quot;: &quot;XXX&quot;,</span><br><span class="line">    &quot;keepalive&quot;: 3600,</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>鼠标文件名右键选则「Download Folder」</li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://zhuanlan.zhihu.com/p/91942738">Sublime Text 3 超详细插件安装</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
</search>
