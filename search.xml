<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排序算法</title>
    <url>/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>十大经典排序算法介绍和实现</p>
<span id="more"></span>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="排序算法介绍"><a href="#排序算法介绍" class="headerlink" title="排序算法介绍"></a>排序算法介绍</h2><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">最坏时间复杂度</th>
<th align="center">最好时间复杂度</th>
<th align="center">平均时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(logn)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">O(n+m)</td>
<td align="center">O(n+m)</td>
<td align="center">O(n+m)</td>
<td align="center">O(m)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n^2)</td>
<td align="center">O(n+m)</td>
<td align="center">O(n+m)</td>
<td align="center">O(n+m)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(n x m)</td>
<td align="center">O(n x m)</td>
<td align="center">O(n x m)</td>
<td align="center">O(n+m)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ol>
<li>介绍  <ol>
<li>比较相邻元素，交换；</li>
<li>第一轮将第n大（最大）元素逐个交换冒泡到位置n（最后）；</li>
<li>第x轮将第x大元素逐个交换冒泡到位置x；</li>
<li>第n轮将最1大（最小）元素逐个交换冒泡到位置1；</li>
<li>*<em>（无序区，有序区），从无序区通过相邻交换将最大元素冒泡到有序区前端</em>。*</li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n^2) ~ O(n)<br> 空间复杂度：O(1)<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = bubble_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">BubbleSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ol>
<li>介绍  <ol>
<li>在未排序的序列里寻找最小元素索引，交换到起始位置；</li>
<li>再从剩余未排序元素中寻找最小元素，放到已排序序列的末尾；</li>
<li>重复2直到最后一个元素；</li>
<li><strong>（有序区，无序区），从无序区找一个最小的放在有序区的后面，比较多，换得少。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n^2) ~ O(n^2)<br> 空间复杂度：O(1)<br> 稳定性：不稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        <span class="keyword">if</span> i != min_idx:</span><br><span class="line">            arr[i], arr[min_idx] = arr[min_idx], arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = select_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx])</span><br><span class="line">                min_idx = j;</span><br><span class="line">        <span class="keyword">if</span> (i != min_idx)</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[min_idx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">SelectSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ol>
<li>介绍  <ol>
<li>先用第一个元素做已排序序列，其余为未排序序列；</li>
<li>遍历未排序序列，将每个元素插入到之前已排序序列的合适位置；</li>
<li>插入过程将已排序序列元素逐个后移；</li>
<li><strong>（有序区，无序区），把无序区的第一个元素插入到有序区的合适位置。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n^2) ~ O(n)<br> 空间复杂度：O(1)<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        pre_idx = i - <span class="number">1</span></span><br><span class="line">        cur = arr[i]</span><br><span class="line">        <span class="keyword">while</span> pre_idx &gt;= <span class="number">0</span> <span class="keyword">and</span> cur &lt; arr[pre_idx]:</span><br><span class="line">            arr[pre_idx+<span class="number">1</span>] = arr[pre_idx]</span><br><span class="line">            pre_idx -= <span class="number">1</span></span><br><span class="line">        arr[pre_idx+<span class="number">1</span>] = cur</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = insert_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> pre_idx = i - <span class="number">1</span>;</span><br><span class="line">        T cur = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (pre_idx &gt;= <span class="number">0</span> &amp;&amp; cur &lt; arr[pre_idx]) &#123;</span><br><span class="line">            arr[pre_idx+<span class="number">1</span>] = arr[pre_idx];</span><br><span class="line">            pre_idx--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[pre_idx+<span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">InsertSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ol>
<li>介绍  <ol>
<li>也称递减增量排序算法，是插入排序的一种更高效的改进版本；</li>
<li>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序；</li>
<li><strong>每一轮按照事先决定的间隔进行插入排序，间隔依次减少直到1。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(nlogn) ~ O(nlogn) ~ O(n)<br> 空间复杂度：O(1)<br> 稳定性：不稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    gap = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, <span class="built_in">len</span>(arr)):</span><br><span class="line">            pre_idx = i - gap</span><br><span class="line">            cur = arr[i]</span><br><span class="line">            <span class="keyword">while</span> pre_idx &gt;= <span class="number">0</span> <span class="keyword">and</span> cur &lt; arr[pre_idx]:</span><br><span class="line">                arr[pre_idx + gap] = arr[pre_idx]</span><br><span class="line">                pre_idx -= gap</span><br><span class="line">            arr[pre_idx + gap] = cur</span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = shell_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = len / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> pre_idx = i - gap;</span><br><span class="line">            T cur = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (pre_idx &gt;= <span class="number">0</span> &amp;&amp; cur &lt; arr[pre_idx]) &#123;</span><br><span class="line">                arr[pre_idx + gap] = arr[pre_idx];</span><br><span class="line">                pre_idx -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[pre_idx + gap] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">ShellSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol>
<li>介绍  <ol>
<li>分治法，自上而下递归或者自下而上的迭代；</li>
<li><strong>把序列分为两段，递归保证两段有序后再合并有序的两段。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(nlogn) ~ O(nlogn) ~ O(nlogn)<br> 空间复杂度：O(n)<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr_left, arr_right</span>):</span><br><span class="line">    arr_res = []</span><br><span class="line">    <span class="keyword">while</span> arr_left <span class="keyword">and</span> arr_right:</span><br><span class="line">        <span class="keyword">if</span> arr_left[<span class="number">0</span>] &lt;= arr_right[<span class="number">0</span>]:</span><br><span class="line">            arr_res.append(arr_left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arr_res.append(arr_right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> arr_left:</span><br><span class="line">        arr_res.extend(arr_left)</span><br><span class="line">    <span class="keyword">if</span> arr_right:</span><br><span class="line">        arr_res.extend(arr_right)</span><br><span class="line">    <span class="keyword">return</span> arr_res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    middle = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    arr_left, arr_right = arr[<span class="number">0</span>:middle], arr[middle:]</span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(arr_left), merge_sort(arr_right))</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = merge_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T *arr_ori = arr;</span><br><span class="line">    T *res = <span class="keyword">new</span> T[len];</span><br><span class="line">    <span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len) &#123;  <span class="comment">// 递归每轮</span></span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += gap * <span class="number">2</span>) &#123;  <span class="comment">// 每轮对比组</span></span><br><span class="line">            <span class="type">int</span> ll = j, lr = j + gap;</span><br><span class="line">            <span class="type">int</span> rl = lr, rr = lr + gap;</span><br><span class="line">            <span class="keyword">while</span> (rl &lt; len &amp;&amp; ll &lt; lr &amp;&amp; rl &lt; rr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[ll] &lt;= arr[rl]) &#123;</span><br><span class="line">                    res[p++] = arr[ll++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[p++] = arr[rl++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (ll &lt; lr &amp;&amp; ll &lt; len)</span><br><span class="line">                res[p++] = arr[ll++];</span><br><span class="line">            <span class="keyword">while</span> (rl &lt; rr &amp;&amp; rl &lt; len)</span><br><span class="line">                res[p++] = arr[rl++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *tmp = arr;</span><br><span class="line">        arr = res;</span><br><span class="line">        res = tmp;</span><br><span class="line">        gap *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr != arr_ori) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        res = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ol>
<li>介绍  <ol>
<li>冒泡排序基础上的递归分治法；</li>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面；</li>
<li>在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；    </li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
<li><strong>（小区间，基准元素吗，大区间）在区间中随机挑选一个元素作为基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数和大数区间进行排序。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n2) ~ O(nlogn) ~ O(nlogn)<br> 空间复杂度：O(logn)<br> 稳定性：不稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    middle_value = arr[left]  <span class="comment"># 取首元素为分割点</span></span><br><span class="line">    p = left</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left + <span class="number">1</span>, right):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= middle_value:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">            arr[p], arr[i] = arr[i], arr[p]</span><br><span class="line">    arr[left], arr[p] = arr[p], arr[left]</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition2</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    middle_value = arr[right - <span class="number">1</span>]  <span class="comment"># 取尾元素尾分割点</span></span><br><span class="line">    p = left</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= middle_value:</span><br><span class="line">            arr[p], arr[i] = arr[i], arr[p]</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">    arr[p], arr[right - <span class="number">1</span>] = arr[right - <span class="number">1</span>], arr[p]</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        middle = partition1(arr, left, right)</span><br><span class="line">        quick_sort(arr, left, middle)</span><br><span class="line">        quick_sort(arr, middle + <span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = quick_sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partion</span><span class="params">(T arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    T middle_value = arr[left];</span><br><span class="line">    <span class="type">int</span> p = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; middle_value) &#123;</span><br><span class="line">            p += <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(arr[p], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[p], arr[left]);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(T arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> middle = <span class="built_in">Partion</span>(arr, left, right);</span><br><span class="line">        <span class="built_in">QuickSort</span>(arr, left, middle);</span><br><span class="line">        <span class="built_in">QuickSort</span>(arr, middle + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol>
<li>介绍  <ol>
<li>创建一个最大堆 H[0……n-1]；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>除去堆尾后调整堆；</li>
<li>重复2，3；</li>
<li><strong>（最大堆，有序区）交换堆顶元素与有序区前一个元素，再调整堆。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(nlogn) ~ O(nlogn) ~ O(nlogn)<br> 空间复杂度：O(1)<br> 稳定性：不稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adjust_heap</span>(<span class="params">arr, head, tail</span>):</span><br><span class="line">    left = head * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    right = left + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; tail <span class="keyword">and</span> arr[right] &gt; arr[left]:</span><br><span class="line">        left = right</span><br><span class="line">    <span class="keyword">if</span> left &lt; tail <span class="keyword">and</span> arr[head] &lt; arr[left]:</span><br><span class="line">        arr[head], arr[left] = arr[left], arr[head]</span><br><span class="line">        adjust_heap(arr, left, tail)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_max_heap</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        adjust_heap(arr, i, <span class="built_in">len</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    build_max_heap(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(arr, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = heap_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AdjustHeap</span><span class="params">(T arr[], <span class="type">int</span> head, <span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = head * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; tail &amp;&amp; arr[right] &gt; arr[left])</span><br><span class="line">        left = right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; tail &amp;&amp; arr[head] &lt; arr[left]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[head], arr[left]);</span><br><span class="line">        <span class="built_in">AdjustHeap</span>(arr, left, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BuildMaxHeap</span><span class="params">(T arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i--) &#123;  <span class="comment">// 首元素也要调整</span></span><br><span class="line">        <span class="built_in">AdjustHeap</span>(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">// 最多交换到第1元素</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">AdjustHeap</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">HeapSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><ol>
<li>介绍  <ol>
<li>计数排序不是比较排序，排序的速度快于任何比较排序算法；</li>
<li>线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数；</li>
<li><strong>新建数组统计等于该元素值索引的元素个数i，再反向写回数组。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n + m) ~ O(n + m) ~ O(n + m)<br> 空间复杂度：O(m)，m是元素最大值<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    len_bucket = <span class="built_in">max</span>(arr) + <span class="number">1</span></span><br><span class="line">    bucket = [<span class="number">0</span>] * len_bucket</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        bucket[i] += <span class="number">1</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len_bucket):</span><br><span class="line">        <span class="keyword">while</span> bucket[j]:</span><br><span class="line">            arr[idx] = j</span><br><span class="line">            bucket[j] -= <span class="number">1</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = count_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len_bucket = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="keyword">if</span> (len_bucket &lt; arr[i])</span><br><span class="line">            len_bucket = arr[i];</span><br><span class="line">    <span class="type">int</span> *bucket = <span class="keyword">new</span> <span class="type">int</span>[len_bucket + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len_bucket + <span class="number">1</span>; j++)</span><br><span class="line">        <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[idx++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] bucket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">CountSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><ol>
<li>介绍  <ol>
<li>根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；</li>
<li>遍历排序序列，将每个元素放到对应的桶里去；</li>
<li>对不是空的桶进行排序；</li>
<li>按顺序访问桶，将桶中的元素依次放回到原序列中对应的位置，完成排序。</li>
<li><strong>新建数组统计等于该元素值索引的元素个数i，再反向写回数组。</strong></li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n+m) ~ O(n+m)<br> 空间复杂度：O(n+m)，m个桶<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;桶排序&quot;&quot;&quot;</span></span><br><span class="line">    min_num, max_num = <span class="built_in">min</span>(arr), <span class="built_in">max</span>(arr)</span><br><span class="line">    <span class="comment"># 桶大小</span></span><br><span class="line">    bucket_range = (max_num - min_num) / <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 桶数组</span></span><br><span class="line">    bucket_list = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 向桶填数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        bucket_list[<span class="built_in">int</span>((i - min_num) / bucket_range)].append(i)</span><br><span class="line">    <span class="comment"># 回填</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bucket_list:</span><br><span class="line">        left, right = right, right + <span class="built_in">len</span>(i)</span><br><span class="line">        arr[left:right] = <span class="built_in">sorted</span>(i)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = bucket_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T min_num = arr[<span class="number">0</span>];</span><br><span class="line">    T max_num = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min_num)</span><br><span class="line">            min_num = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max_num)</span><br><span class="line">            max_num = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> bucket_range = <span class="built_in">double</span>(max_num - min_num) / len;</span><br><span class="line">    std::vector&lt;std::vector&lt;T&gt; &gt; <span class="built_in">bucket_list</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        bucket_list[(arr[i] - min_num) / bucket_range].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(bucket_list[i].<span class="built_in">begin</span>(), bucket_list[i].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket_list[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            arr[left++] = bucket_list[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">BucketSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ol>
<li>介绍  <ol>
<li>非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较；</li>
<li>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</li>
<li>取得数组中的最大数，并取得位数；</li>
<li>对数位较短的数前面补零；</li>
<li>分配，先从个位开始，根据位值(0-9)分别放到0~9号桶中;</li>
<li>收集，再将放置在0~9号桶中的数据按顺序放到数组中;</li>
<li>重复3~4过程，直到最高位，即可完成排序;</li>
<li>** 按位迭代排序 **</li>
</ol>
</li>
<li>复杂度<br> 时间复杂度：O(n^2) ~ O(n+m) ~ O(n+m)<br> 空间复杂度：O(n+m)，m个桶<br> 稳定性：稳定  </li>
<li>代码-python   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基数排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 记录最大值的位数</span></span><br><span class="line">    m = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(arr)))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):  <span class="comment"># m轮排序</span></span><br><span class="line">        <span class="comment"># 如果是数字，建立0-9折十个桶</span></span><br><span class="line">        bucket_list = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="comment"># 如果是26个英文字母字符串，建立26个桶</span></span><br><span class="line">        <span class="comment"># bucket_list = [[] for i in range(26)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 放入桶中</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> arr:</span><br><span class="line">            bucket_list[(a // <span class="number">10</span>**k) % <span class="number">10</span>].append(a)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从桶中拿出</span></span><br><span class="line">        arr = [a <span class="keyword">for</span> bucket <span class="keyword">in</span> bucket_list <span class="keyword">for</span> a <span class="keyword">in</span> bucket]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">arr = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序前：%s&quot;</span> % arr)</span><br><span class="line">sorted_arr = radix_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后：%s&quot;</span> % sorted_arr)</span><br></pre></td></tr></table></figure></li>
<li>代码-c++   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录最大位数</span></span><br><span class="line">    T max_num = *<span class="built_in">max_element</span>(arr, arr + len);</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        m++;</span><br><span class="line">        max_num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;  <span class="comment">// m轮排序</span></span><br><span class="line">        std::vector&lt;std::vector&lt;T&gt; &gt; <span class="built_in">bucket_list</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            bucket_list[<span class="built_in">int</span>(arr[i] / (<span class="built_in">pow</span>(<span class="number">10</span>, k))) % <span class="number">10</span>].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket_list[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">                arr[p++] = bucket_list[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArr</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">20</span>, <span class="number">111</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序前： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="built_in">RadixSort</span>(arr, len);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序后： &quot;</span>;</span><br><span class="line">    <span class="built_in">PrintArr</span>(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>桶的概念<br> 计数排序：每个桶只存储单一键值；<br> 桶排序：每个桶存储一定范围的数值；<br> 基数排序：根据键值的每位数字来分配桶；  </li>
<li>关于稳定性<br> 排序后 2 个相等键值的顺序和排序之前它们的顺序相同；<br> 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序；<br> 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序；</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法</a><br><a href="https://www.zhihu.com/column/Use-Python-to-Achieve">python实现·十大排序算法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>bash</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/bash/</url>
    <content><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell（命令行环境），是目前绝大多数 Linux 发行版的默认 Shell。</p>
<span id="more"></span>


<h2 id="shell含义和种类"><a href="#shell含义和种类" class="headerlink" title="shell含义和种类"></a>shell含义和种类</h2><ol>
<li>Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</li>
<li>Shell 是指一种用 C 语言编写的应用程序，提供了一个界面，用户通过这个界面访问操作系统内核的服务。Shell 是一个命令解释器，解释用户输入的命令。</li>
<li>用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。</li>
<li>shell包含bash、sh、csh、tcsh、ksh、zsh、fish，其中bash是最常用的shell。</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p><code>date</code>命令  </p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取当前格式化日期</span><br><span class="line">date_time=`date +%Y/%m/%d-%H:%M:%S`</span><br><span class="line"># 获取前一天日期</span><br><span class="line">early_date=`date -d -1days +%Y/%m/%d`</span><br><span class="line"># 获取后一天日期</span><br><span class="line">early_date=`date -d +1days +%Y/%m/%d`</span><br><span class="line"># 获取当前时间戳</span><br><span class="line">cur_timestamp=`date +%s`</span><br><span class="line"># 获取前1天此时的时间戳</span><br><span class="line">cur_timestamp=e</span><br><span class="line"># 获取后一天此时的时间戳</span><br><span class="line">cur_timestamp=`date -d +1days +%s`</span><br></pre></td></tr></table></figure></li>
<li><p>操作mysql数据库</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sql语句</span><br><span class="line">sql=&quot;update $&#123;mysql_table&#125; set status=-1 where status=1;&quot;</span><br><span class="line"># 执行sql语句</span><br><span class="line">op=`mysql --host=&quot;localhost&quot; --user=root --password=密码 -v -v -e &quot;$&#123;sql&#125;&quot;`</span><br><span class="line"># 参数-v -v 输出sql语句和结果</span><br><span class="line"># 参数-N输出结果不含列名，-s静默输出，每个结果一行</span><br></pre></td></tr></table></figure>
</li>
<li><p>脚本里生成配置文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">cat &gt; /root/a.sh &lt;&lt; EOF</span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">echo &quot;hello bash&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># 注释：说明当前脚本功能</span><br><span class="line"></span><br><span class="line"># 设置脚本错误停止、变量不存在停止、打印命令、管道命令错误一个也停止</span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line"># 脚本文件名和参数</span><br><span class="line">echo &#x27;脚本名称：$0=&#x27; $0</span><br><span class="line">echo &#x27;参数数量：$#=&#x27; $#</span><br><span class="line">echo &#x27;参数1：$1=&#x27; $1</span><br><span class="line">echo &#x27;参数2：$2=&#x27; $2</span><br><span class="line">echo &#x27;所有参数：$@=&#x27; $@</span><br><span class="line"></span><br><span class="line"># 遍历打印参数</span><br><span class="line">for i in &quot;$@&quot;;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 读取文件</span><br><span class="line">filename=&#x27;/etc/hosts&#x27;</span><br><span class="line">while read myline</span><br><span class="line">do</span><br><span class="line">    echo &quot;$myline&quot;</span><br><span class="line">done &lt; $filename</span><br><span class="line"></span><br><span class="line"># 函数定义</span><br><span class="line">#######################################</span><br><span class="line"># Cleanup files from the backup dir</span><br><span class="line"># Globals:</span><br><span class="line">#   BACKUP_DIR</span><br><span class="line">#   ORACLE_SID</span><br><span class="line"># Arguments:</span><br><span class="line">#   None</span><br><span class="line"># Returns:</span><br><span class="line">#   None</span><br><span class="line">#######################################</span><br><span class="line">cleanup() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 退出值为0（成功）</span><br><span class="line">exit 0</span><br><span class="line"># 退出值为1（失败）</span><br><span class="line"></span><br><span class="line">exit 1</span><br></pre></td></tr></table></figure>


<h2 id="实践2-删除数据库前N天创建的前缀为xxx的表"><a href="#实践2-删除数据库前N天创建的前缀为xxx的表" class="headerlink" title="实践2-删除数据库前N天创建的前缀为xxx的表"></a>实践2-删除数据库前N天创建的前缀为xxx的表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># 注释：删除数据库N天前创建的前缀为table_prefix的表</span><br><span class="line"></span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line">N=7</span><br><span class="line">table_prefix=&#x27;tb_xxx_&#x27;</span><br><span class="line"></span><br><span class="line">__str__=&quot;删除数据库$N天前创建的前缀为$&#123;table_prefix&#125;的表&quot;</span><br><span class="line">echo -e &quot;title: $__str__\n&quot;</span><br><span class="line"></span><br><span class="line">host=&#x27;&#x27;</span><br><span class="line">port=&#x27;&#x27;</span><br><span class="line">user=&#x27;&#x27;</span><br><span class="line">passwd=&#x27;&#x27;</span><br><span class="line">db=&quot;&quot;</span><br><span class="line">mysql_export=&quot;export MYSQL_PWD=$&#123;passwd&#125;&quot;</span><br><span class="line">mysql_login=&quot;mysql -h$host -P$port -u$user -D$db&quot;</span><br><span class="line">echo -e &quot;db: $mysql_login\n&quot;</span><br><span class="line"></span><br><span class="line">sql_select=&quot;select TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA=\&quot;$db\&quot; and TABLE_NAME like &#x27;$&#123;table_prefix&#125;%&#x27; and DATEDIFF(now(), CREATE_TIME)&gt;$N order by CREATE_TIME asc&quot;</span><br><span class="line"></span><br><span class="line">tables=`$mysql_export &amp;&amp; $mysql_login -N -e &quot;$sql_select&quot;`</span><br><span class="line">echo -e &quot;res_sql_select: $tables\n&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$tables&quot; = &quot;&quot; ]; then</span><br><span class="line">    echo &quot;NULL, exit&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">wait_del_tables=&#x27;&#x27;</span><br><span class="line">cnt=0</span><br><span class="line">for table in $tables; do</span><br><span class="line">    wait_del_tables=&quot;$wait_del_tables,$db.$table&quot;</span><br><span class="line">    ((cnt++))</span><br><span class="line">done</span><br><span class="line">wait_del_tables=$&#123;wait_del_tables:1&#125;</span><br><span class="line">echo -e &quot;wait_del_tables: $wait_del_tables\n&quot;</span><br><span class="line"></span><br><span class="line">sql_drop=&quot;drop table $wait_del_tables&quot;</span><br><span class="line">res=`$mysql_export &amp;&amp; $mysql_login -e &quot;$sql_drop&quot;`</span><br><span class="line">echo -e &quot;res_sql_drop: $res\n&quot;</span><br><span class="line"></span><br><span class="line">echo -e &quot;Successfully drop $cnt tables\n&quot;</span><br></pre></td></tr></table></figure>


<h2 id="实践3-进程监控和保活"><a href="#实践3-进程监控和保活" class="headerlink" title="实践3-进程监控和保活"></a>实践3-进程监控和保活</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line"># 注释：进程监控和保活</span><br><span class="line"></span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line"># 参数检查</span><br><span class="line">if [ $# -lt 2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;please input PROGRAM_DIR and PROGRAM_NAME&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 进入进程启动目录</span><br><span class="line">cd $&#123;PROGRAM_DIR&#125;</span><br><span class="line"></span><br><span class="line"># 检查和启动进程</span><br><span class="line">RUN_CHECK() &#123;</span><br><span class="line">    # 检查进程是否存活</span><br><span class="line">    RUN_CHECK=`ps -ef | grep $&#123;PROGRAM_NAME&#125; | grep -wv grep | grep -wv vi | grep -wv tail | grep -wv $&#123;PROGRAM_CURRENT&#125; | grep -v &quot;\.sh&quot; | grep -v &quot;/alarm &quot; | wc -l`    </span><br><span class="line">    echo &quot;check_result: $&#123;RUN_CHECK&#125;&quot;</span><br><span class="line"></span><br><span class="line">    # 进程不存在，则启动</span><br><span class="line">    if [ $&#123;RUN_CHECK&#125; -lt 1 ]</span><br><span class="line">    then</span><br><span class="line">        NOW_TIME=`date +%Y/%m/%d-%H:%M:%S`</span><br><span class="line">        echo &quot;$&#123;NOW_TIME&#125;, restart the program: $?&quot;</span><br><span class="line">        echo &#x27;nohup hexo s &amp;&#x27; | bash</span><br><span class="line">        echo &quot;Fatal: $&#123;PROGRAM_NAME&#125; down $&#123;RUN_CHECK&#125; $&#123;NOW_TIME&#125;&quot; &gt;&gt; down.log</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 每5秒检查一次</span><br><span class="line">STEP=5</span><br><span class="line">for (( i=0; i&lt;60; i=(i+$&#123;STEP&#125;) )) do</span><br><span class="line">    RUN_CHECK</span><br><span class="line">    sleep $&#123;STEP&#125;</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>


<h2 id="shell配置"><a href="#shell配置" class="headerlink" title="shell配置"></a>shell配置</h2><ol>
<li>查看当前默认shell和已安装shell <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">$ cat /etc/shells</span><br></pre></td></tr></table></figure></li>
<li>查看bash版本 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bash --version</span><br><span class="line">$ echo $BASH_VERSION</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ol>
<li>echo-原样输出参数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 原因输出包括换行格式</span><br><span class="line">$ echo &quot;&lt;HTML&gt;</span><br><span class="line">&lt;HEAD&gt;</span><br><span class="line">      &lt;TITLE&gt;Page Title&lt;/TITLE&gt;</span><br><span class="line">&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY&gt;</span><br><span class="line">      Page body.</span><br><span class="line">&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;&quot;</span><br><span class="line"></span><br><span class="line"># -n 去掉末尾默认的换行符</span><br><span class="line">$ echo -n a;echo b</span><br><span class="line">ab</span><br><span class="line"></span><br><span class="line"># -e 解释引号(单/双引号)参数里的特殊字符</span><br><span class="line">$ echo &quot;hello\nworld&quot;</span><br><span class="line">hello\nworld</span><br><span class="line"></span><br><span class="line">$ echo -e &#x27;hello\nworld&#x27;</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure></li>
<li>命令格式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 短形式</span><br><span class="line">$ ls -r</span><br><span class="line"></span><br><span class="line"># 长形式</span><br><span class="line">$ ls --reverse</span><br><span class="line"></span><br><span class="line"># 太长换行，末尾加&#x27;\&#x27;</span><br><span class="line">$ echo foo bar</span><br><span class="line"># 等同于</span><br><span class="line">$ echo foo \</span><br><span class="line">bar</span><br></pre></td></tr></table></figure></li>
<li>空格-区分不同参数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ &lt;command&gt; foo bar</span><br></pre></td></tr></table></figure></li>
<li>分号-命令结束符，后面命令不依赖前面命令执行成功与否 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ clear; ls</span><br></pre></td></tr></table></figure></li>
<li>命令组合符号-&amp;&amp; 和 || <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 依赖前面命令执行成功才能执行后面命令</span><br><span class="line">$ &lt;command_1&gt; &amp;&amp; &lt;command_2&gt;</span><br><span class="line"></span><br><span class="line"># 前面命令执行失败才执行后面命令</span><br><span class="line">$ &lt;command_1&gt; || &lt;command_2&gt;</span><br></pre></td></tr></table></figure></li>
<li>type-显示命令类型 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ type echo</span><br></pre></td></tr></table></figure></li>
<li>快捷键<ul>
<li><code>ctrl + L</code>：清除屏幕</li>
<li><code>ctrl + C</code>：终止当前正在执行的命令</li>
</ul>
</li>
</ol>
<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><ol>
<li><code>~</code>：自动扩展成当前用户的主目录；</li>
<li><code>?</code>：代表文件路径里面的任意单个字符，不包括空字符；</li>
<li><code>*</code>：代表文件路径里面的任意数量的任意个字符，包括零个字符； <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示所有隐藏文件</span><br><span class="line">$ echo .*</span><br><span class="line"></span><br><span class="line"># 显示隐藏文件排除.和..</span><br><span class="line">$ echo .[!.]*</span><br></pre></td></tr></table></figure></li>
<li><code>[]</code>：可以匹配方括号里的任意一个字符； <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件名扩展</span><br><span class="line">$ echo a[bc]d</span><br><span class="line"># 匹配文件存在，显示如下</span><br><span class="line">abd acd</span><br><span class="line"># 匹配文件不存在，显示如下</span><br><span class="line">a[bc]d</span><br><span class="line"></span><br><span class="line"># !表示匹配除了b以外</span><br><span class="line">$ echo a[!b]d</span><br></pre></td></tr></table></figure></li>
<li><code>[start-end]</code>：连续范围扩展， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a-c] 等同于[abc]</span><br><span class="line">[0-9] 等同于[0123456789]</span><br><span class="line">[!0-9] 表示除0-9外的任意字符</span><br></pre></td></tr></table></figure></li>
<li><code>&#123;&#125;</code>: 表示分别扩展大括号里的所有值，使用逗号分割，逗号前后不能有空格 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 非文件名扩展，总是扩展，不管文件是否存在</span><br><span class="line">$ echo d&#123;a,b,c,d&#125;g</span><br><span class="line">dag dbg dcg ddg</span><br><span class="line"></span><br><span class="line"># 与其他组合，优先于其他</span><br><span class="line">$ echo /bin/&#123;cat,b*&#125;</span><br><span class="line">/bin/cat /bin/bx /bin/bxx ...</span><br></pre></td></tr></table></figure></li>
<li><code>&#123;start..end&#125;</code>：扩展成一个连续序列 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 顺序扩展</span><br><span class="line">$ echo d&#123;a..c&#125;g</span><br><span class="line">dag dbg dcg ddg</span><br><span class="line"></span><br><span class="line"># 逆序扩展</span><br><span class="line">$ echo d&#123;c..a&#125;g</span><br><span class="line">dcg dbg dag</span><br><span class="line"></span><br><span class="line"># 创建系列目录</span><br><span class="line">$ mkdir fiel_&#123;a,b,c&#125;.txt</span><br><span class="line"></span><br><span class="line"># for循环</span><br><span class="line">for i in &#123;1..4&#125;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 整数前导0</span><br><span class="line">$ echo &#123;01..3&#125;</span><br><span class="line">01 02 03</span><br><span class="line"></span><br><span class="line"># 间隔步长</span><br><span class="line">$ echo &#123;1..10..2&#125;</span><br><span class="line">1 3 5 7 9</span><br><span class="line">$ echo &#123;a..g..2&#125;</span><br><span class="line">a c e g</span><br></pre></td></tr></table></figure></li>
<li><code>$&#123;&#125;</code>：变量扩展 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $&#123;SHELL&#125;</span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">&lt;!-- 所有以S开头的变量名 --&gt;</span><br><span class="line">$ echo  $&#123;!S*&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>$()</code>：子命令扩展 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $(date)</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">$ echo `date`</span><br><span class="line"></span><br><span class="line">&lt;!-- 可嵌套 --&gt;</span><br><span class="line">$ echo $(ls $(pwd))</span><br></pre></td></tr></table></figure></li>
<li><code>$(())</code>：算术扩展，扩展成整数运算结果<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $((2 + 2))</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li>
<li><code>[[:class:]]</code>：字符类，文件名扩展，class扩展成该类之中任意一个<ol>
<li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>：匹配任意英文字母</li>
<li><code>[[:digit:]]</code>：匹配任意数字0-9</li>
<li><code>[[:lower:]]</code>：匹配任意小写字母a-z</li>
<li><code>[[:upper:]]</code>：匹配任意大写字母A-Z</li>
<li><code>[[:blank:]]</code>：匹配空格和Tab健</li>
<li><code>[[:cntrl:]]</code>：匹配ASCII 码 0-31 的不可打印字符</li>
<li><code>[[:print:]]</code>：匹配ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:xdigit:]]</code>：匹配16进制字符（A-F、a-f、0-9）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打印数字开头的文件名</span><br><span class="line">$ echo [[:digit:]]*</span><br><span class="line"># 打印非数字开头的文件名</span><br><span class="line">$ echo [![:digit:]]*</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>注意项<ol>
<li>通配符是先解释再执行</li>
<li>文件名扩展在不匹配时，会解释成原样输出，再执行</li>
<li>只适用于单层路径，即不能匹配路径分隔符（<code>/</code>）。如果要匹配子目录里的文件，可以使用<code>ls */*.txt</code></li>
</ol>
</li>
<li>量词语法，也是文件名扩展<ol>
<li><code>?()</code>：模式匹配零次或1次</li>
<li><code>*()</code>：模式匹配0次或多次</li>
<li><code>+()</code>：模式匹配一次或多次</li>
<li><code>@()</code>：模式匹配仅一次</li>
<li><code>!()</code>：模式匹配给定模式之外的任何内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 匹配文件有且只有一个.txt或.php后缀</span><br><span class="line">$ ls abc@(.txt|.php)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="引号和转义-bash只有字符串一种数据类型"><a href="#引号和转义-bash只有字符串一种数据类型" class="headerlink" title="引号和转义-bash只有字符串一种数据类型"></a>引号和转义-bash只有字符串一种数据类型</h2><ol>
<li>转义-转义特殊字符 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 转义打印特殊字符比如 $、 &amp;、 *、\</span><br><span class="line">$ echo \$date</span><br><span class="line">$date</span><br><span class="line">$ echo \\</span><br><span class="line">\</span><br><span class="line"></span><br><span class="line"># 转义打印不可打印字符，需要echo -e &#x27;&#x27;</span><br><span class="line">\a: 响铃</span><br><span class="line">\b: 退格</span><br><span class="line">\t: 制表符</span><br><span class="line">\r: 回车</span><br><span class="line">\n: 换行</span><br><span class="line"></span><br><span class="line"># 换行符加上\转换为普通空字符</span><br><span class="line">$ mv \</span><br><span class="line">/root/a/b \</span><br><span class="line">/root/b/b</span><br><span class="line"># 等同于</span><br><span class="line">$ mv /root/a/b /roott/b/b</span><br></pre></td></tr></table></figure></li>
<li>单引号-用于保留字符的字面含义<ol>
<li>单引号使得bash扩展、变量引用、算术运算、子命令失效。</li>
<li>反斜杠转义功能在单引号内失效，故在单引号内使用单引号，不能使用转义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $&#x27;it\&#x27;s&#x27;</span><br><span class="line">it&#x27;s</span><br><span class="line"></span><br><span class="line"># 等同于</span><br><span class="line">$ echo &quot;it&#x27;s&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>双引号-除了<code>&amp;</code>、<code>`</code>、<code>\</code>保留特殊含义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 换行符失效</span><br><span class="line">$ echo &quot;hello </span><br><span class="line">world&quot;</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"></span><br><span class="line"># 文件名空格情况</span><br><span class="line">$ ls &quot;one file.txt&quot;</span><br><span class="line"></span><br><span class="line"># 保留原始命令结果输出</span><br><span class="line">$ echo $(cal)</span><br><span class="line">March 2023 Su Mo Tu We Th Fr Sa 1 2 3 4 5 ... 31</span><br><span class="line">$ echo &quot;$(cal)&quot;</span><br><span class="line">     March 2023     </span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">          1  2  3  4</span><br><span class="line"> 5  6  7  8  9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29 30 31</span><br></pre></td></tr></table></figure></li>
<li>here 文档 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt; token</span><br><span class="line">text</span><br><span class="line">text</span><br><span class="line">token</span><br><span class="line"></span><br><span class="line"># 可发生变量替换，支持反斜杠转义，不支持通配符和引号</span><br><span class="line">$ foo=&#x27;hello world&#x27;</span><br><span class="line">$ cat &lt;&lt; _example_</span><br><span class="line">$foo</span><br><span class="line">&quot;$foo&quot;</span><br><span class="line">&#x27;$foo&#x27;</span><br><span class="line">_example_</span><br><span class="line">hello world</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line">&#x27;hello world&#x27;</span><br><span class="line"></span><br><span class="line"># 如果不希望变量替换，则将here文档的开始标记放在单引号之中</span><br><span class="line"></span><br><span class="line"># here 字符串，将字符串通过标准输入，传递给命令</span><br><span class="line">$ md5sum &lt;&lt;&lt; &#x27;ddd&#x27;</span><br><span class="line"># 等同于</span><br><span class="line">$ echo &#x27;ddd&#x27;|md5sum</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="变量-环境变量和自定义变量"><a href="#变量-环境变量和自定义变量" class="headerlink" title="变量-环境变量和自定义变量"></a>变量-环境变量和自定义变量</h2><ol>
<li>显示所有变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure></li>
<li>创建&#x2F;赋值变量-只有字符串，无类型概念 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myvar=&#x27;hello world&#x27;</span><br><span class="line">myvar=hello</span><br><span class="line">myvar2=myvar</span><br></pre></td></tr></table></figure></li>
<li>删除变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset myvar</span><br><span class="line"># 因为不存在的变量一律等于空字符串</span><br><span class="line">myvar=&#x27;&#x27;</span><br></pre></td></tr></table></figure></li>
<li>输出变量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export NAME=value</span><br></pre></td></tr></table></figure></li>
<li>特殊变量<ol>
<li><code>$?</code>：为上一个命令退出码，成功为0，失败为其他</li>
<li><code>$$</code>：当前shell的进程ID</li>
<li><code>$@</code>：脚本的参数值</li>
<li><code>$#</code>：脚本的参数数量</li>
</ol>
</li>
<li>变量默认值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 变量存在且不为空，返回其值，否则返回默认值xxx</span><br><span class="line">$&#123;varname:-xxx&#125;</span><br><span class="line"></span><br><span class="line"># 变量存在且不为空，返回其值，否则设置并返回默认值xxx</span><br><span class="line">$&#123;varname:=xxx&#125;</span><br><span class="line"></span><br><span class="line"># 变量存在且不为空，返回其值，否则打印xxx并中断脚本</span><br><span class="line">$&#123;varname:?xxx&#125;</span><br><span class="line"></span><br><span class="line"># 变量存在且不为空，返回xxx，否则返回空</span><br><span class="line">$&#123;varname:+xxx&#125;</span><br><span class="line"></span><br><span class="line"># 上述中varname可以用数字1到9表示脚本参数</span><br><span class="line">filename=$&#123;1:?&quot;filename missing.&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>readonly只读命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readonly foo=1</span><br></pre></td></tr></table></figure></li>
<li>let命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 直接执行算术表达式</span><br><span class="line">let foo=1+2</span><br><span class="line"></span><br><span class="line"># 同时多个</span><br><span class="line">$ let &quot;v1 = 1&quot; &quot;v2 = v1++&quot;</span><br><span class="line">$ echo $v1,$v2</span><br><span class="line">2,1</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ol>
<li>获取字符串长度 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;#varname&#125;</span><br></pre></td></tr></table></figure></li>
<li>子串-${varname:offset:length} <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从头部位置offset（&gt;=0开始），截取长度为length的子串</span><br><span class="line">$&#123;varname:offset:length&#125;</span><br><span class="line"></span><br><span class="line"># 从头部位置offset（&gt;=0开始），截取到尾部的子串</span><br><span class="line">$&#123;varname:offset&#125;</span><br><span class="line"></span><br><span class="line"># 从尾部未知offset（&lt;=-1开始），负数前面必须有个空格</span><br><span class="line">foo=&quot;abcd efg hijkm&quot;</span><br><span class="line">$&#123;varname: -5&#125;</span><br><span class="line">hijkm</span><br><span class="line"># length为正数表示长度</span><br><span class="line">$&#123;varname: -5:2&#125;</span><br><span class="line"># length为负数排除尾部负数个字符</span><br><span class="line">$&#123;varname: -5:-2&#125;</span><br><span class="line">hij</span><br></pre></td></tr></table></figure></li>
<li>搜索和替换-#&#x2F;%<ol>
<li>头部尾部匹配替换 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 头部/尾部匹配删除，pattern可以使用*?[]等通配符</span><br><span class="line"># 删除最短头部匹配，返回剩余</span><br><span class="line">$&#123;variable#pattern&#125;</span><br><span class="line"># 删除最长头部匹配，返回剩余</span><br><span class="line">$&#123;variable##pattern&#125;</span><br><span class="line"># 删除最短尾部匹配，返回剩余</span><br><span class="line">$&#123;variable%pattern&#125;</span><br><span class="line"># 删除最长尾部匹配，返回剩余</span><br><span class="line">$&#123;variable%%pattern&#125;    </span><br><span class="line"></span><br><span class="line"># e.g.删除文件路径，只返回文件名</span><br><span class="line">$ path=/home/cam/book/long.file.name</span><br><span class="line">$&#123;path##*/&#125;</span><br><span class="line">long.file.name</span><br><span class="line"># e.g.删除文件名，只返回文件路径</span><br><span class="line">$&#123;path%/*&#125;</span><br><span class="line">/home/cam/book</span><br><span class="line"></span><br><span class="line"># 头部匹配替换，只有#，最长匹配替换</span><br><span class="line">$&#123;variable/#pattern/string&#125;</span><br><span class="line"># e.g.</span><br><span class="line">$ foo=XXX.jpg</span><br><span class="line">$ echo $&#123;foo/#XXX/xxx&#125;</span><br><span class="line">xxx.jpg</span><br><span class="line"># 尾部匹配替换，只有%，最长匹配替换</span><br><span class="line">$&#123;variable/%pattern/string&#125;</span><br><span class="line"># e.g.</span><br><span class="line">$ foo=XXX.jpg</span><br><span class="line">$ echo $&#123;foo/%jpg/JPG&#125;</span><br><span class="line">XXX.JPG</span><br><span class="line"></span><br><span class="line"># e.g.</span><br><span class="line">$ path=/home/cam/book/long.file.name</span><br><span class="line">$ echo $&#123;path%.*&#125;</span><br><span class="line">/home/cam/book/long.file</span><br><span class="line">$ echo $&#123;path%%.*&#125;</span><br><span class="line">/home/cam/book/long</span><br></pre></td></tr></table></figure></li>
<li>任意位置的模式匹配 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 任意位置最长匹配，仅替换第一个</span><br><span class="line">$&#123;variable/pattern/string&#125;</span><br><span class="line"># 任意位置最长匹配，替换所有</span><br><span class="line">$&#123;variable//pattern/string&#125;</span><br><span class="line"># 省略string表示替换为空字符串即删除</span><br><span class="line"></span><br><span class="line"># e.g.</span><br><span class="line">$ path=/home/cam/foo/foo.name</span><br><span class="line">$ echo $&#123;path/foo/bar&#125;</span><br><span class="line">/home/cam/bar/foo.name</span><br><span class="line">$ echo $&#123;path//foo/bar&#125;</span><br><span class="line">/home/cam/bar/bar.name</span><br><span class="line"></span><br><span class="line"># e.g.将所有:改为换行符</span><br><span class="line"># 使用-e表示将替换后的\n字符，解释为换行</span><br><span class="line">$ echo -e $&#123;PATH//:/&#x27;\n&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># e.g.通配符替换</span><br><span class="line">$ phone=&quot;555-456-1414&quot;</span><br><span class="line">$ echo $&#123;phone/5?4/-&#125;</span><br><span class="line">55-56-1414</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>改变大小写 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 转为大写</span><br><span class="line">$&#123;variable^^&#125;</span><br><span class="line"></span><br><span class="line"># 转为小写</span><br><span class="line">$&#123;variable,,&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><ol>
<li>算术运算-只能整数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自动忽略空格，不返回值，结果不为0则$?为0成功，否则为1失败</span><br><span class="line">((...))</span><br><span class="line"></span><br><span class="line"># 返回值</span><br><span class="line">$ echo $((2 + 2))</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"># 可以嵌套</span><br><span class="line">$ echo $(((2**3) * 2))</span><br><span class="line">16</span><br><span class="line">$ echo $((2**(3 * 2)))</span><br><span class="line">64</span><br><span class="line">$ echo $((2**$((3 * 2))))</span><br><span class="line">64</span><br><span class="line"></span><br><span class="line"># 内部字符串被当做变量名，可不加$</span><br><span class="line">number=2</span><br><span class="line">$ echo $((number + 1))</span><br><span class="line"></span><br><span class="line"># 内部变量不存在或变量值为字符串，默认当做0做运算</span><br></pre></td></tr></table></figure></li>
<li>支持的符号<ul>
<li><code>+</code>：加法</li>
<li><code>-</code>：减法</li>
<li><code>*</code>：乘法</li>
<li><code>/</code>：除法（整除）</li>
<li><code>%</code>：余数</li>
<li><code>**</code>：指数</li>
<li><code>++</code>：自增运算（变量前缀或后缀）</li>
<li><code>--</code>：自减运算（变量前缀或后缀）</li>
</ul>
</li>
<li>数值进制<ul>
<li><code>number</code>：没有任何特殊表示法的数字是十进制数（以10为底）。</li>
<li><code>0number</code>：八进制数。</li>
<li><code>0xnumber</code>：十六进制数。</li>
<li><code>base#number</code>：base进制的数。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $((0xff))</span><br><span class="line">255</span><br><span class="line">$ echo $((2#11111111))</span><br><span class="line">255</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>位运算<ul>
<li><code>&lt;&lt;</code>：位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>：位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>：位的“与”运算，对两个数字的所有位执行一个AND操作。</li>
<li><code>|</code>：位的“或”运算，对两个数字的所有位执行一个OR操作。</li>
<li><code>~</code>：位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。</li>
</ul>
</li>
<li>逻辑运算-逻辑表达式为真，返回1，否则返回0。<ul>
<li><code>&lt;</code>：小于</li>
<li><code>&gt;</code>：大于</li>
<li><code>&lt;=</code>：小于或相等</li>
<li><code>&gt;=</code>：大于或相等</li>
<li><code>==</code>：相等</li>
<li><code>!=</code>：不相等</li>
<li><code>&amp;&amp;</code>：逻辑与</li>
<li><code>||</code>：逻辑或</li>
<li><code>!</code>：逻辑否<br> expr1?expr2:expr3<code>：三元条件运算符。若表达式expr1的计算结果为非零值（算术真）- </code>，则执行表达式expr2，否则执行表达式expr3。</li>
</ul>
</li>
<li>赋值运算 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $((a=1))</span><br><span class="line">1</span><br><span class="line">还有+=、-=、*=、&lt;&lt;=、|=等</span><br></pre></td></tr></table></figure></li>
<li>求值运算-<code>,</code>在<code>$((...))</code>执行前后连个表达式，并返回后一个表达式的值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $((foo = 1 + 2, 3 * 4))</span><br><span class="line">12</span><br><span class="line">$ echo $foo</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li>
<li>expr <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ foo=3</span><br><span class="line">$ expr $foo + 2</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li>
<li>let命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 命令用于将算术运算的结果，赋予一个变量。不能有空格</span><br><span class="line">$ let x=2+3</span><br><span class="line">$ echo $x</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="bash脚本"><a href="#bash脚本" class="headerlink" title="bash脚本"></a>bash脚本</h2><ol start="0">
<li>运行方式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 首行的#!/bin/sh是注释不起作用，新开子进程执行</span><br><span class="line">bash x.sh</span><br><span class="line"></span><br><span class="line"># 可执行文件执行脚本，先加权限，再按首行执行解释器执行，新开子进程执行</span><br><span class="line">chmod u+rx</span><br><span class="line">./x.sh`  </span><br><span class="line">    </span><br><span class="line"># 当前进程执行，主要为了脚本内部加载外部库</span><br><span class="line">source ./x.sh == . ./x.sh</span><br></pre></td></tr></table></figure></li>
<li>读取输入&#x2F;文件-read <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 读取输入</span><br><span class="line">echo -n &quot;输入一些文本 &gt; &quot;</span><br><span class="line">read text</span><br><span class="line">echo &quot;你的输入：$text&quot;</span><br><span class="line"></span><br><span class="line"># 超时3秒和提示</span><br><span class="line">read -t 3 -p &quot;Enter one or more values &gt; &quot;</span><br><span class="line"># 没有指定变量返回到环境变量REPLY</span><br><span class="line">echo &quot;REPLY = &#x27;$REPLY&#x27;&quot;</span><br><span class="line"></span><br><span class="line"># 读取文件</span><br><span class="line">filename=&#x27;/etc/hosts&#x27;</span><br><span class="line">while read myline</span><br><span class="line">do</span><br><span class="line">    echo &quot;$myline&quot;</span><br><span class="line">done &lt; $filename</span><br></pre></td></tr></table></figure></li>
<li>条件判断 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本</span><br><span class="line">if test $1 = &#x27;root&#x27;</span><br><span class="line">then</span><br><span class="line">    echo &#x27;hello root&#x27;</span><br><span class="line">elif [ $1 = &#x27;jesonlin&#x27; ]; then</span><br><span class="line">    echo &#x27;hello jesonlin&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;you are not root&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># true/false 特殊命令</span><br><span class="line">if true</span><br><span class="line">then</span><br><span class="line">    echo &#x27;always true&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 条件三种样式</span><br><span class="line">test -e /tmp/file.txt</span><br><span class="line">[ -e /tmp/file.txt ]</span><br><span class="line">[[ -e /tmp/file.txt ]]  # 第三种还支持正则</span><br><span class="line"></span><br><span class="line"># 条件是一个命令，可以是test，也可以是其他命令，命令返回值为0表示判断成立</span><br><span class="line"># 文件是否存在</span><br><span class="line">[ -a file ]</span><br><span class="line">[ -e file ]</span><br><span class="line"># 文件是否是目录</span><br><span class="line">[ -d file ]</span><br><span class="line"></span><br><span class="line"># 字符串判断，变量放在双引号之中</span><br><span class="line">[ $str ]  # 是否不为空</span><br><span class="line">[ -n $str ]  # 长度是否大于0</span><br><span class="line">[ -z $str ]  # 长度是否为0</span><br><span class="line">[ &quot;$str1&quot; == &quot;$str2&quot; ]  # 是否相等</span><br><span class="line">[ &quot;$str1&quot; != &quot;$str2&quot; ]  # 是否不相等</span><br><span class="line">[ &quot;$str1&quot; &#x27;&gt;&#x27; &quot;$str2&quot; ]  # 字符串1是否大于2</span><br><span class="line"></span><br><span class="line"># 整数判断</span><br><span class="line">[ $num1 -eq $num2 ]  # 是否相等</span><br><span class="line">[ $num1 -ne $num2 ]  # 是否不相等</span><br><span class="line">[ $num1 -le $num2 ]  # 是否小于或等于</span><br><span class="line">[ $num1 -lt $num2 ]  # 是否小于</span><br><span class="line">[ $num1 -ge $num2 ]  # 是否大于或等于</span><br><span class="line">[ $num1 -gt $num2 ]  # 是否大于</span><br><span class="line"></span><br><span class="line"># 正则判断是否是整数</span><br><span class="line">if [[ &quot;$0&quot; =~ ^-?[0-9]+=$ ]]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;$0 is an integer&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;s0 is not an integer&#x27;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 逻辑运算</span><br><span class="line">&amp;&amp;(与) ||(或) !(非)</span><br><span class="line"></span><br><span class="line"># case结构</span><br><span class="line">case &quot;$OS&quot; in</span><br><span class="line">  FreeBSD) echo &quot;This is FreeBSD&quot; ;;</span><br><span class="line">  Darwin) echo &quot;This is Mac OSX&quot; ;;</span><br><span class="line">  AIX) echo &quot;This is AIX&quot; ;;</span><br><span class="line">  Minix) echo &quot;This is Minix&quot; ;;</span><br><span class="line">  Linux) echo &quot;This is Linux&quot; ;;</span><br><span class="line">  *) echo &quot;Failed to identify this OS&quot; ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
<li>循环 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># while 循环</span><br><span class="line">number=0</span><br><span class="line">while [ &quot;$number&quot; -lt 10 ]; do</span><br><span class="line">  echo &quot;Number = $number&quot;</span><br><span class="line">  number=$((number + 1))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># until 循环-不符合条件（判断条件失败）就不断循环</span><br><span class="line">until condition; do</span><br><span class="line">  commands</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># for...in 循环</span><br><span class="line"># 列表由通配符产生，遍历当前目录下所有png图片</span><br><span class="line">for i in *.png; do</span><br><span class="line">  ls -l $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># for 循环，类似C语言，变量不必加$</span><br><span class="line">for (( i=0; i&lt;5; i=i+1 )); do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># break, continue, 同C语言</span><br></pre></td></tr></table></figure></li>
<li>函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一种</span><br><span class="line">fn() &#123;</span><br><span class="line">  # codes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二种</span><br><span class="line">function fn() &#123;</span><br><span class="line">  # codes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 参数变量</span><br><span class="line"># 函数的参数变量，与脚本参数变量是一致的</span><br><span class="line">$1~$9：函数的第一个到第9个的参数。</span><br><span class="line">$0：函数所在的脚本名。</span><br><span class="line">$#：函数的参数总数。</span><br><span class="line">$@：函数的全部参数，参数之间使用空格分隔。</span><br><span class="line">$*：函数的全部参数，参数之间使用变量$IFS值的第一个字符分隔，</span><br><span class="line"></span><br><span class="line"># Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。</span><br><span class="line"># 函数体内不仅可以声明全局变量，还可以修改全局变量。</span><br><span class="line"># 函数里面可以用local命令声明局部变量，只在函数体内有效，函数体外没有定义。</span><br></pre></td></tr></table></figure></li>
<li>数组 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义数组</span><br><span class="line">ARRAY[INDEX]=value</span><br><span class="line">ARRAY=(value1 value2 value3)</span><br><span class="line">ARRAY=([2]value1 [0]value2 [1]value3)  # 指定每个元素位置</span><br><span class="line">$ mp3s=( *.mp3 )  # 通配符定位数组</span><br><span class="line">$ read -a dice  # 用户命令行输入传入数组</span><br><span class="line"></span><br><span class="line"># 读取数组</span><br><span class="line">$ echo $&#123;array[i]&#125;</span><br><span class="line">$ foo=(a b c d e f)</span><br><span class="line">$ echo $&#123;foo[@]&#125;</span><br><span class="line">a b c d e f</span><br><span class="line">for i in &quot;$&#123;names[@]&#125;&quot;; do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 数组长度</span><br><span class="line">$&#123;#array[*]&#125;</span><br><span class="line">$&#123;#array[@]&#125;</span><br><span class="line"></span><br><span class="line"># 数组序号</span><br><span class="line">$ arr=([5]=a [9]=b [23]=c)</span><br><span class="line">$ echo $&#123;!arr[@]&#125;</span><br><span class="line">5 9 23</span><br><span class="line">$ echo $&#123;!arr[*]&#125;</span><br><span class="line">5 9 23</span><br><span class="line"></span><br><span class="line"># 提取数组1号开始的3个成员</span><br><span class="line">$ echo $&#123;arr[@]:1:3&#125;</span><br><span class="line"># 提取数组所有个成员</span><br><span class="line">$ echo $&#123;arr[@]:0&#125;</span><br><span class="line"></span><br><span class="line"># 追加数组成员，不能有空格</span><br><span class="line">$ arr+=(d e f)</span><br><span class="line"></span><br><span class="line"># 删除数组某个成员，只是隐藏，而不是删除</span><br><span class="line">$ unset arr[0]</span><br><span class="line"># 清空数组</span><br><span class="line">$ use tarr</span><br><span class="line"></span><br><span class="line"># 关联数组，类似map</span><br><span class="line">$ declare -A colors  # 必须带-A选项</span><br><span class="line">$ colors[&quot;red&quot;]=&quot;#ff0000&quot;</span><br><span class="line">$ colors[&quot;green&quot;]=&quot;#00ff00&quot;</span><br><span class="line">$ colors[&quot;blue&quot;]=&quot;#0000ff&quot;</span><br><span class="line"># 索引</span><br><span class="line">$ echo $&#123;colors[&quot;blue&quot;]&#125;</span><br></pre></td></tr></table></figure></li>
<li>脚本命令<ol start="0">
<li>bash 执行脚本会创建一个子shell去执行，默认忽略不存在的变量</li>
<li>set 命令-修改子shell环境的运行参数，即定制环境 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line"># 不存在变量就会报错</span><br><span class="line">set -u</span><br><span class="line"></span><br><span class="line"># 执行命令前打印命令本身，行首以+表示</span><br><span class="line">set -x  # 命令打印</span><br><span class="line">set +x  # 取消命令打印</span><br><span class="line"></span><br><span class="line"># 脚本有错误就停止</span><br><span class="line">set -e  # 开启</span><br><span class="line">set +e  # 关闭-e选项</span><br><span class="line">command || &#123; echo &quot;command failed&quot;; exit 1; &#125;</span><br><span class="line"># 管道命令以最后一个命令成功与否代表整个命令的返回值</span><br><span class="line"># 管道命令中只要一个子命令失败就终止脚本</span><br><span class="line">set -eo pipefail</span><br><span class="line"></span><br><span class="line"># 不运行，只检查语法</span><br><span class="line">set -n</span><br><span class="line"></span><br><span class="line"># 总结-写法一</span><br><span class="line">set -euxo pipefail</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>常见错误<ol>
<li>命令失败情况 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果$dir_name不存在，会失败，会切换进用户主目录，执行接下来命令</span><br><span class="line">cd $dir_name</span><br><span class="line">rm *</span><br><span class="line"># 正确写法</span><br><span class="line">[[ -d $dir_name ]] &amp;&amp; cd $dir_name &amp;&amp; rm *</span><br><span class="line"># 不放心删除东西可以先打印看看</span><br><span class="line">[[ -d $dir_name ]] &amp;&amp; cd $dir_name &amp;&amp; echo rm *</span><br></pre></td></tr></table></figure></li>
<li>定位问题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 打印行号</span><br><span class="line">echo &quot;This is line $LINENO&quot;</span><br><span class="line"></span><br><span class="line"># 打印函数堆栈上的函数名</span><br><span class="line">function func1()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;func1: FUNCNAME0 is $&#123;FUNCNAME[0]&#125;&quot;</span><br><span class="line">  echo &quot;func1: FUNCNAME1 is $&#123;FUNCNAME[1]&#125;&quot;</span><br><span class="line">  echo &quot;func1: FUNCNAME2 is $&#123;FUNCNAME[2]&#125;&quot;</span><br><span class="line">  func2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 脚本调用堆栈</span><br><span class="line">function func1()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;func1: BASH_SOURCE0 is $&#123;BASH_SOURCE[0]&#125;&quot;</span><br><span class="line">  echo &quot;func1: BASH_SOURCE1 is $&#123;BASH_SOURCE[1]&#125;&quot;</span><br><span class="line">  echo &quot;func1: BASH_SOURCE2 is $&#123;BASH_SOURCE[2]&#125;&quot;</span><br><span class="line">  func2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.runoob.com/linux/linux-shell.html">菜鸟教程</a><br><a href="https://wangdoc.com/bash/">Bash 脚本教程</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历、构建、展开</title>
    <url>/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E3%80%81%E6%9E%84%E5%BB%BA%E3%80%81%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>二叉树的遍历包括深度遍历和广度遍历。深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。</p>
<span id="more"></span>


<h2 id="深度遍历"><a href="#深度遍历" class="headerlink" title="深度遍历"></a>深度遍历</h2><ol start="0">
<li><p>基础</p>
 <img src="/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E3%80%81%E6%9E%84%E5%BB%BA%E3%80%81%E5%B1%95%E5%BC%80/%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="" title="二叉树">

<p> 已知中序遍历和另一种遍历顺序，则可把这棵树构造出来：由先序遍历或后序遍历知根节点，而中序遍历中根节点左端的为左子树，右端的右子树，再由先序遍历或后序遍历知子根节点，递归地构造子树。</p>
</li>
<li><p>前序遍历-[父-左-右]-[E, B, A, D, C, G, F, I, H]</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    res.append(root.val)  <span class="comment"># 将根节点加入结果</span></span><br><span class="line">    dfs(root.left, res)  <span class="comment"># 递归左节点</span></span><br><span class="line">    dfs(root.right, res)  <span class="comment"># 递归右节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur, stack = root, []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 根节点及其左孩子入栈</span></span><br><span class="line">            res.append(cur.val)  <span class="comment"># 加入结果</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        tmp = stack.pop()  <span class="comment"># 每弹出一个元素，就到该元素的右子节点处理</span></span><br><span class="line">        cur = tmp.right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化栈，并将根节点入栈；</span></span><br><span class="line"><span class="comment"># 当栈不为空时：</span></span><br><span class="line">    <span class="comment"># 弹出栈顶元素 node，并将值添加到结果中；</span></span><br><span class="line">    <span class="comment"># 如果 node 的右子树非空，将右子树入栈；</span></span><br><span class="line">    <span class="comment"># 如果 node 的左子树非空，将左子树入栈；</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative_2</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        res.append(cur.val)  <span class="comment"># 根节点加入结果</span></span><br><span class="line">        <span class="keyword">if</span> cur.right:  <span class="comment"># 右子节点入栈</span></span><br><span class="line">            stack.append(cur.right)</span><br><span class="line">        <span class="keyword">if</span> cur.left:   <span class="comment"># 左子节点入栈</span></span><br><span class="line">            stack.append(cur.left)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pre_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># dfs(root, res)</span></span><br><span class="line">    iterative(root, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历-[左-父-右]-[A, B, C, D, E, F, G, H, I]</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dfs(root.left, res)  <span class="comment"># 递归左节点</span></span><br><span class="line">    res.append(root.val)  <span class="comment"># 将根节点加入结果</span></span><br><span class="line">    dfs(root.right, res)  <span class="comment"># 递归右节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative</span>(<span class="params">root, res</span>):</span><br><span class="line">    cur, stack = root, []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 左子节点不停入栈，到达最左端的叶子节点</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        tmp = stack.pop  <span class="comment"># 出栈</span></span><br><span class="line">        res.append(tmp.val)  <span class="comment"># 加入结果</span></span><br><span class="line">        cur = tmp.right  <span class="comment"># 处理右子节点</span></span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">in_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># dfs(root, res)</span></span><br><span class="line">    iterative(root, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历-[左-右-父]-[A, C, D, B, F, H, I, G, E]</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, res</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dfs(root.left, res)  <span class="comment"># 递归左节点</span></span><br><span class="line">    dfs(root.right, res)  <span class="comment"># 递归右节点</span></span><br><span class="line">    res.append(root.val)  <span class="comment"># 将根节点加入结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iterative</span>(<span class="params">root, res</span>):  <span class="comment"># 与前序遍历相反操作在结果取反</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur, stack = root, []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">while</span> cur:  <span class="comment"># 根节点及其右孩子入栈</span></span><br><span class="line">            res.append(cur.val)  <span class="comment"># 加入结果</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        tmp = stack.pop()  <span class="comment"># 每弹出一个元素，就到该元素的左子节点处理</span></span><br><span class="line">        cur = tmp.left</span><br><span class="line">    res.reverse()  <span class="comment"># 原地反转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># dfs(root, res)</span></span><br><span class="line">    iterative(root, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="广度遍历"><a href="#广度遍历" class="headerlink" title="广度遍历"></a>广度遍历</h2><ol>
<li>层序遍历<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_order_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    que, res = [root], []</span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        n = <span class="built_in">len</span>(que)  <span class="comment"># 每层数量</span></span><br><span class="line">        level = []  <span class="comment"># 每层结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur = que.pop(<span class="number">0</span>)</span><br><span class="line">            level.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                que.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                que.append(cur.right)</span><br><span class="line">        res.append(level)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h2><ol>
<li><p>根据前序遍历和中序遍历构建<br> 对于任意一颗树而言，前序遍历的形式总是</p>
<pre><code> [ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
</code></pre>
<p> 即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p>
<pre><code> [ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]
</code></pre>
</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">preorder, inorder, map_v2i, p_l, p_r, i_l, i_r</span>):</span><br><span class="line">    <span class="keyword">if</span> p_l &gt; p_r:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    p_root = p_l  <span class="comment"># 根节点在前序遍历的索引</span></span><br><span class="line">    i_root = map_v2i[preorder[p_root]]  <span class="comment"># 根节点在在中序遍历的索引</span></span><br><span class="line">    num_l = i_root - i_l</span><br><span class="line">    </span><br><span class="line">    root = TreeNode(preorder[p_root])</span><br><span class="line"></span><br><span class="line">    root.left = dfs(preorder, inorder, map_v2i, p_l + <span class="number">1</span>, p_l + num_l, i_l, i_root - <span class="number">1</span>)</span><br><span class="line">    root.right = dfs(preorder, inorder, map_v2i, p_l + num_l + <span class="number">1</span>, p_r, i_root + <span class="number">1</span>, i_r)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 构建中序遍历hash映射</span></span><br><span class="line">    map_v2i = &#123;v:i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(preorder, inorder, map_v2i, <span class="number">0</span>, <span class="built_in">len</span>(preorder) - <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 展开后的单链表应该与二叉树 先序遍历 顺序相同</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">root</span>):</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur.left:  <span class="comment"># 左子结点存在，找到其最右节点（即左子树先序遍历的最后一个元素）</span></span><br><span class="line">            pre = cur.left</span><br><span class="line">            <span class="keyword">while</span> pre.right:</span><br><span class="line">                pre = pre.right</span><br><span class="line">            pre.right = cur.right  <span class="comment"># 当前节点右子树作为左子树最右节点的右子树</span></span><br><span class="line">            cur.right = cur.left  <span class="comment"># 将当前节点左子树改为右子树，因为是【根左右】关系，左子树转到右子树一样顺序，右子树是左子树最右节点的右子树</span></span><br><span class="line">            cur.left = <span class="literal">None</span>  <span class="comment"># 当前节点左子树变为None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>


<h2 id="RERERENCE"><a href="#RERERENCE" class="headerlink" title="RERERENCE"></a>RERERENCE</h2><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/">图解 二叉树的四种遍历</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建-hexo+next+github</title>
    <url>/%E5%B7%A5%E5%85%B7/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-hexo+next+github/</url>
    <content><![CDATA[<p>记录下搭建个人博客流程，使用 hexo + next + github + 个人域名。</p>
<span id="more"></span>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol start="0">
<li>全局替换如下信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;USERNAME&gt;: github个人账号</span><br><span class="line">&lt;EMAIL&gt;: github个人邮箱</span><br><span class="line">&lt;CVM-IP&gt;: CVM的IP</span><br><span class="line">&lt;个人域名&gt;: 腾讯云上申请的域名，https:开头</span><br><span class="line">&lt;域名&gt;: 腾讯云上申请的域名，不带https:开头</span><br><span class="line">&lt;twitter账号&gt;: twitter个人账号</span><br><span class="line">&lt;facebook账号&gt;: facebook个人账号</span><br></pre></td></tr></table></figure></li>
<li>腾讯云 cvm-centos:7  <ol>
<li>购买初始化 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cloud.tencent.com/product/cvm?from=13950</span><br></pre></td></tr></table></figure></li>
<li>替换腾讯云源 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum update -y</span><br><span class="line">yum upgrade -y</span><br></pre></td></tr></table></figure></li>
<li>磁盘映射-samba<ol>
<li>安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install samba</span><br></pre></td></tr></table></figure></li>
<li>选择共享文件夹 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/service</span><br><span class="line">chmod 777 /data/service</span><br></pre></td></tr></table></figure></li>
<li>编辑samba配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br><span class="line">&lt;!-- global下新增一行，放开1315端口 --&gt;</span><br><span class="line">smb ports = 1315</span><br><span class="line"></span><br><span class="line">&lt;!-- 文件末尾添加如下共享文件夹 --&gt;</span><br><span class="line">[service]</span><br><span class="line">comment = service</span><br><span class="line">path = /data/service</span><br><span class="line">public = yes</span><br><span class="line">browseable = yes</span><br><span class="line">writable = yes</span><br><span class="line">create mask = 0777</span><br><span class="line">directory mask = 0777</span><br></pre></td></tr></table></figure></li>
<li>创建samba用户名和密码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smbpasswd -a root</span><br></pre></td></tr></table></figure></li>
<li>设置为开启启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig --level 3 smb on</span><br></pre></td></tr></table></figure></li>
<li>重启sambda <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service smb start</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>cvm -&gt; 安全组 -&gt; 自定义模板 -&gt; 按模板格式放开端口 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.0.0.0/0   TCP:1315</span><br><span class="line">0.0.0.0/0   TCP:4000</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>腾讯云域名<ol>
<li>注册 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://dnspod.cloud.tencent.com/</span><br></pre></td></tr></table></figure></li>
<li>添加A记录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 找到github账号所在ip --&gt;</span><br><span class="line">ping &lt;USERNAME&gt;.github.io</span><br><span class="line">@ A 默认 [IP]</span><br></pre></td></tr></table></figure></li>
<li>添加CNAME <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www CNAME 默认 &lt;USERNAME&gt;.github.io.</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>github<ol>
<li>注册和登录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/</span><br></pre></td></tr></table></figure></li>
<li>新建仓库blog <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 修改默认分支名为master --&gt;</span><br><span class="line">https://github.com/settings/repositories</span><br><span class="line">&lt;!-- 新建仓库 --&gt;</span><br><span class="line">https://github.com/&lt;USERNAME&gt;?tab=repositories</span><br><span class="line">&lt;!-- 仓库地址-SSH --&gt;</span><br><span class="line">git@github.com:&lt;USERNAME&gt;/blog.git</span><br><span class="line">&lt;!-- 默认创建master分支 --&gt;</span><br></pre></td></tr></table></figure></li>
<li>创建分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建source分支 --&gt;</span><br><span class="line">https://github.com/&lt;USERNAME&gt;/blog/branches</span><br><span class="line">&lt;!-- 修改默认分支为source分支 --&gt;</span><br><span class="line">Default branch -&gt; 最右边左右箭头 -&gt; master下拉选source -&gt; Update</span><br></pre></td></tr></table></figure></li>
<li>配置git <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;&lt;USERNAME&gt;&quot;</span><br><span class="line">git config --global user.email &quot;&lt;EMAIL&gt;&quot;</span><br></pre></td></tr></table></figure></li>
<li>新建ssh keys <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- cvm输入如下联系回车 --&gt;</span><br><span class="line">ssh-keygen -t rsa -C &quot;blog_&lt;CVM-IP&gt;&quot;</span><br><span class="line">&lt;!-- 查看公开密钥的方法 --&gt;</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">&lt;!-- 将公开秘钥填入github --&gt;</span><br><span class="line">https://github.com/settings/ssh/new</span><br></pre></td></tr></table></figure></li>
<li>配置host链接git更快 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 从该网址找到IP --&gt;</span><br><span class="line">https://www.ipaddress.com/site/github.com</span><br><span class="line">&lt;!-- 或者如下 --&gt;</span><br><span class="line">https://www.whatsmydns.net/#A/github.com</span><br><span class="line">&lt;!-- 填入到hosts --&gt;</span><br><span class="line">vim /etc/hosts</span><br><span class="line">[IP] https://github.com</span><br><span class="line">[IP] github.com</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h2><ol>
<li>安装Node.js <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y nodejs</span><br><span class="line">&lt;!-- 查询版本号 --&gt;</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li>
<li>安装git <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure></li>
<li>安装Hexo <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/service</span><br><span class="line">cd /data/service</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li>
<li>启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server</span><br></pre></td></tr></table></figure></li>
<li>本地调试-浏览器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://&lt;CVM-IP&gt;:4000/</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h2><ol>
<li>编辑_config.yml <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/service/blog</span><br><span class="line">vim _config.yml</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:&lt;USERNAME&gt;/blog.git</span><br><span class="line">  branch: master  # 这个根据github实际填master还是main，建议将github默认分支改为master</span><br><span class="line">url: https://&lt;USERNAME&gt;.github.io/blog/</span><br></pre></td></tr></table></figure></li>
<li>部署推送git的master分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/service/blog</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
<li>github配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 进入blog仓库的pages页面 --&gt;</span><br><span class="line">https://github.com/&lt;USERNAME&gt;/blog/settings/pages</span><br><span class="line">Branch -&gt; 选择master -&gt; Save</span><br><span class="line">&lt;!-- 等待几分钟，重新刷新页面，会出现如下 --&gt;</span><br><span class="line">Your site is live at https://&lt;USERNAME&gt;.github.io/blog/</span><br><span class="line">&lt;!-- 通过该网址可以访问hexo首页 --&gt;</span><br></pre></td></tr></table></figure></li>
<li>配置自定义域名<ol>
<li>编辑_config.yml <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url: &lt;个人域名&gt;</span><br></pre></td></tr></table></figure></li>
<li>github配置腾讯云域名 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/&lt;USERNAME&gt;/blog/settings/pages</span><br><span class="line">Pages -&gt; Custom domain -&gt; &lt;域名&gt; -&gt; Save</span><br><span class="line">&lt;!-- 会在master分支下生成CNAME文件 --&gt;</span><br></pre></td></tr></table></figure></li>
<li>重新部署推送 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li>
<li>问题<ol>
<li>发现master分支下的CNAME文件不见了</li>
<li>同时Pages -&gt; Custom domain下自定义的域名也被重置为一开始默认的</li>
</ol>
</li>
<li>解决方法<ol>
<li>将生成的CNAME文件放在&#x2F;data&#x2F;service&#x2F;blog&#x2F;source下</li>
<li>再次部署推送发现本地.deploy_git目录下就有CNAME文件</li>
<li>同时master分支上的内容就是该.deploy_git目录下内容</li>
</ol>
</li>
<li>最终可以通过个人域名访问hexo博客</li>
</ol>
</li>
<li>源代码保存在默认的source分支<ol>
<li>目的是可以再任意地方重新部署写文章</li>
<li>关联远程的默认source分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:&lt;USERNAME&gt;/blog.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;初始化blog&quot;</span><br><span class="line">git branch -M source</span><br><span class="line">git pull</span><br><span class="line">git branch --set-upstream-to=origin/source  source</span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>迁移到其他CVM <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/service/</span><br><span class="line">cd /data/service</span><br><span class="line">yum install -y nodejs</span><br><span class="line">yum install -y git</span><br><span class="line">git clone git@github.com:&lt;USERNAME&gt;/blog.git</span><br><span class="line">cd blog</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init .</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><ol>
<li>下载next主题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /data/service/blog</span><br><span class="line">&lt;!-- v8.13.2 --&gt;</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li>
<li>配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 站点配置文件 --&gt;</span><br><span class="line">/data/service/blog/_config.yml</span><br><span class="line">&lt;!-- 主题配置文件 --&gt;</span><br><span class="line">/data/service/blog/themes/next/_config.yml</span><br></pre></td></tr></table></figure></li>
<li>修改站点配置文件_config.yml <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: jesonlin</span><br><span class="line">subtitle: &#x27;&#x27;</span><br><span class="line">description: &#x27;choice is better than effort&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: jesonlin</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br><span class="line"></span><br><span class="line">permalink: :category/:urlname/  # 永久链接</span><br><span class="line">permalink_defaults: </span><br><span class="line">  urlname: undefined  # 永久链接中变量默认值</span><br><span class="line"></span><br><span class="line">default_layout: draft  # 使用hexo new [layout] &lt;title&gt; 默认布局改为草稿</span><br><span class="line"></span><br><span class="line">post_asset_folder: true # 将每篇博客对应生成一个文件夹目录（方便插入图片等附件）</span><br><span class="line"># 插入图片相对路径{% asset_img "xx.jpg" "" %}需要安装包</span><br><span class="line"># npm install hexo-image-link --save</span><br><span class="line"></span><br><span class="line">default_category: uncategory</span><br><span class="line"></span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></li>
<li>隐藏网页底部的由 Hexo &amp; NexT.Gemini 强力驱动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /data/service/blog/themes/next/layout/_partials/footer.swig</span><br><span class="line">&lt;!-- 搜索powered所在几行，前后分别加上 --&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    包含powered的行</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li>
<li>修改主题配置文件<ol>
<li>主题-Scheme Settings <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_file_path:</span><br><span class="line">  style: source/_data/styles.styl  # 在对应位置创建文件</span><br><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini  # 使用这个</span><br><span class="line"></span><br><span class="line"># Dark Mode</span><br><span class="line">darkmode: true  # 主题暗黑模式</span><br></pre></td></tr></table></figure></li>
<li>暗黑模式切换开关 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 依赖 --&gt;</span><br><span class="line">npm install hexo-next-darkmode --save</span><br><span class="line"># Dark Mode</span><br><span class="line">darkmode: false  # 主题暗黑模式</span><br><span class="line"># Darkmode JS</span><br><span class="line"># For more information: https://github.com/rqh656418510/hexo-next-darkmode, https://github.com/sandoche/Darkmode.js</span><br><span class="line">darkmode_js:  # 黑白模式开关，npm install hexo-next-darkmode --save</span><br><span class="line">  enable: true</span><br><span class="line">  bottom: &#x27;64px&#x27; # default: &#x27;32px&#x27;</span><br><span class="line">  right: &#x27;unset&#x27; # default: &#x27;32px&#x27;</span><br><span class="line">  left: &#x27;32px&#x27; # default: &#x27;unset&#x27;</span><br><span class="line">  time: &#x27;0.5s&#x27; # default: &#x27;0.3s&#x27;</span><br><span class="line">  mixColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  backgroundColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  buttonColorDark: &#x27;#100f2c&#x27; # default: &#x27;#100f2c&#x27;</span><br><span class="line">  buttonColorLight: &#x27;#fff&#x27; # default: &#x27;#fff&#x27;</span><br><span class="line">  isActivated: false # default false</span><br><span class="line">  saveInCookies: true # default: true</span><br><span class="line">  label: &#x27;🌓&#x27; # default: &#x27;&#x27;</span><br><span class="line">  autoMatchOsTheme: true # default: true</span><br><span class="line">  libUrl: # Set custom library cdn url for Darkmode.js</span><br></pre></td></tr></table></figure></li>
<li>站点信息-定制logo-custom_logo <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_logo: /images/qq-image.jpeg  # 定制logo</span><br><span class="line">creative_commons:</span><br><span class="line">  post: true  # 文末版权声明</span><br></pre></td></tr></table></figure></li>
<li>站点信息-文末版权声明-creative_commons <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post: true</span><br><span class="line">&lt;!-- 额外增加一行本文结束*感谢您的阅读 --&gt;</span><br><span class="line">vim themes/next/layout/_macro/passage-end-tag.njk</span><br><span class="line">&lt;!-- 粘贴如下内容 --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:24px;&quot;&gt;-------------&gt;本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- 在post.njk加上刚才新建的文件 --&gt;</span><br><span class="line">vim themes/next/layout/_macro/post.njk </span><br><span class="line">&lt;!-- 在END POST BODY后加上如下 --&gt;</span><br><span class="line">&#123;% if not is_index and theme.passage_end_tag.enabled %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &#x27;passage-end-tag.njk&#x27; %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;!-- 打开主题配置文件 --&gt;</span><br><span class="line">vim themes/next/_config.yml</span><br><span class="line">&lt;!-- 在末尾加上 --&gt;</span><br><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure></li>
<li>菜单-菜单项-menu <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: / || fa fa-home</span><br><span class="line">about: /about/ || fa fa-user</span><br><span class="line">tags: /tags/ || fa fa-tags</span><br><span class="line">categories: /categories/ || fa fa-th</span><br><span class="line">archives: /archives/ || fa fa-archive</span><br><span class="line">resources: /resources/ || fa fa-download</span><br><span class="line">#schedule: /schedule/ || fa fa-calendar</span><br><span class="line">#sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">#commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure></li>
<li>侧边栏-sidebar <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 头像-avatar --&gt;</span><br><span class="line">url: /images/handsome.jpg  # 侧边栏头像</span><br><span class="line">rounded: true  # 侧边栏头像圆形包围</span><br><span class="line">rotated: true  # 侧边栏头像旋转动画</span><br><span class="line">&lt;!-- 社交链接-social --&gt;</span><br><span class="line">GitHub: https://github.com/&lt;USERNAME&gt; || fab fa-github</span><br><span class="line">E-Mail: mailto:&lt;EMAIL&gt; || fa fa-envelope</span><br><span class="line">Twitter: https://twitter.com/&lt;twitter账号&gt; || fab fa-twitter</span><br><span class="line">FB Page: https://www.facebook.com/&lt;facebook账号&gt; || fab fa-facebook</span><br></pre></td></tr></table></figure></li>
<li>页脚和爱心动画-footer <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">since: 2022  # 建站时间</span><br><span class="line">animated: true  # 爱心动画</span><br><span class="line">powered: false  # 关掉powered</span><br></pre></td></tr></table></figure></li>
<li>博客设置-字数统计 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 依赖包 --&gt;</span><br><span class="line">cd /data/service/blog</span><br><span class="line">npm install hexo-symbols-count-time</span><br><span class="line">&lt;!-- 主题配置文件 --&gt;</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true  # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  item_text_post: true  # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_total: true  # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  awl: 4  # 平均字长</span><br><span class="line">  wpm: 275  # 每分钟阅读字数</span><br><span class="line">  suffix: &quot;mins.&quot;  # 单位后缀</span><br><span class="line">&lt;!-- 需要重新部署 --&gt;</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li>
<li>博客设置-打赏奖励 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  # If true, reward will be displayed in every article by default.</span><br><span class="line">  enable: true  # 打赏开关</span><br><span class="line">  animation: false</span><br><span class="line">  # 没有comment选项，修改其他 # 提示修改</span><br><span class="line">  # vim themes/next/languages/en.yml</span><br><span class="line">  # Buy me a coffee -&gt; 原创技术分享，您的支持将鼓励我继续创作</span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png  # 微信收款码</span><br><span class="line">  alipay: /images/alipay.png  # 支付宝收款码</span><br></pre></td></tr></table></figure></li>
<li>进度条-pace<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></li>
<li>评论-comments<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comments:</span><br><span class="line">  active: gitalk  # 评论</span><br><span class="line">gitalk:  #注册应用: https://github.com/settings/applications/new &quot;Homepage URL&quot;和&quot;Authorization callback URL&quot;填个人域名</span><br><span class="line">  enable: true  # 开启评论</span><br><span class="line">  github_id: &lt;USERNAME&gt;  # github账号</span><br><span class="line">  repo: blog  # github上博客仓库</span><br><span class="line">  client_id: [CLIENT_ID]</span><br><span class="line">  client_secret: [CLIENT_SECRET]</span><br><span class="line">  admin_user: &lt;USERNAME&gt;</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  language: zh-CN</span><br><span class="line">&lt;!-- 由于gitalk被墙没法获取token，需要代理 --&gt;</span><br><span class="line">proxy: https://strong-caramel-969805.netlify.app/github_access_token  # 替换网上找的代理</span><br></pre></td></tr></table></figure></li>
<li>人数浏览数统计-busuanzi_count<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true  # 启用不蒜子</span><br><span class="line">  total_visitors: true  # 网站总访客数</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true  # 网站总浏览数</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true # 文章浏览数</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure></li>
<li>本地搜索-local_search<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">   enable: true  # 激活</span><br><span class="line"> &lt;!-- 依赖包 --&gt;</span><br><span class="line"> cd /data/service/blog</span><br><span class="line"> npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure></li>
<li>github贡献日历-只在关于页面出现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim themes/next/layout/_layout.njk</span><br><span class="line">&#123;%- if page.type == &#x27;about&#x27; %&#125;</span><br><span class="line">&lt;div class=&quot;post-block animated fadeIn&quot;&gt;</span><br><span class="line">    &lt;h5 class=&quot;post-title&quot; itemprop=&quot;name headline&quot;&gt;</span><br><span class="line">        &lt;a href=&quot;https://github.com/&lt;USERNAME&gt;&quot; class=&quot;post-title-link&quot; itemprop=&quot;url&quot;&gt;Github Contribution Calendar&lt;/a&gt;</span><br><span class="line">    &lt;/h5&gt;</span><br><span class="line">    &lt;div class=&quot;post-body animated fadeInDown&quot; itemprop=&quot;articleBody&quot;&gt;</span><br><span class="line">        &lt;img style=&quot;width: 100%; margin-top: 30px;&quot; src=&quot;https://ghchart.rshah.org/00ff00/&lt;USERNAME&gt;&quot; alt=&quot;jesonlin&#x27;s Blue Github Chart&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li>代码块拷贝<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  copy_button:  # 代码块拷贝</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li>布局文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布局名   存放位置</span><br><span class="line">post    source/_posts   # 文章</span><br><span class="line">page    source          # 页面</span><br><span class="line">draft   source/_drafts  # 草稿</span><br></pre></td></tr></table></figure></li>
<li>草稿布局文件设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim scaffolds/draft.md</span><br><span class="line">&lt;!-- 填入如下内容 --&gt;</span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">urlname: &#123;&#123;title&#125;&#125;</span><br><span class="line">top: false</span><br><span class="line">categories:</span><br><span class="line">- uncategory</span><br><span class="line">tags:</span><br><span class="line">- untag</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">author: &#123;&#123; author &#125;&#125;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这里是摘要</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line"># 内容</span><br><span class="line"></span><br><span class="line">这里是内容</span><br></pre></td></tr></table></figure></li>
<li>文章布局文件设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim scaffolds/post.md</span><br><span class="line">&lt;!-- 填入如下内容 --&gt;</span><br><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">urlname: &#123;&#123;title&#125;&#125;</span><br><span class="line">top:</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">author: &#123;&#123; author &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li>
<li>菜单栏页面创建 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建关于页面 --&gt;</span><br><span class="line">hexo new page about</span><br><span class="line">&lt;!-- 创建分类页面 --&gt;</span><br><span class="line">hexo new page categories</span><br><span class="line">&lt;!-- 创建标签页面 --&gt;</span><br><span class="line">hexo new page tags</span><br><span class="line">&lt;!-- 创建资源页面 --&gt;</span><br><span class="line">hexo new page resources</span><br></pre></td></tr></table></figure></li>
<li>创建草稿 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexp new [layout] &lt;title&gt;</span><br><span class="line">hexo new draft xxx</span><br><span class="line">&lt;!-- 草稿默认不显示，通过参数--draft强制显示 --&gt;</span><br><span class="line">hexo clean &amp;&amp; hexo s --draft</span><br><span class="line">&lt;!-- 发布草稿到文章 --&gt;</span><br><span class="line">hexo publish &lt;title&gt;</span><br></pre></td></tr></table></figure></li>
<li>创建文章 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post xxx</span><br></pre></td></tr></table></figure></li>
<li>本地调试 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li>
<li>推送到github部署 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://hexo.io/zh-cn/">官方文档</a><br><a href="https://blog.csdn.net/as480133937/article/details/100138838">hexo-next主题配置</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>c++</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cplusplus/</url>
    <content><![CDATA[<p>C++是C语言的继承，是静态类型的、编译式的、通用的、大小写敏感的、不规则的面向对象的高级程序设计语言。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>C++ 完全支持面向对象的程序设计</p>
<ol>
<li>封装<br> 封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。</li>
<li>继承<br> 继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。</li>
<li>多态<br> 多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。</li>
<li>抽象<br> 抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。</li>
</ol>
</li>
<li><p>标准的 C++ 由三个重要部分组成</p>
<ol>
<li>核心语言，提供了所有构件块，包括变量、数据类型和常量等等。</li>
<li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li>
<li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li>
</ol>
</li>
<li><p>重要版本迭代<br> c++98 -&gt; c++03 -&gt; c++11 -&gt; c++14 -&gt; c++17</p>
</li>
</ol>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos7 自带 gcc 是4.8.5 不支持c++14、17</span></span><br><span class="line">yum install gcc gcc-c++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级 gcc 为5.4.0</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src</span><br><span class="line">wget https://ftp.gnu.org/gnu/gcc/gcc-5.4.0/gcc-5.4.0.tar.bz2</span><br><span class="line">yum install biz2</span><br><span class="line">tar -jxvf gcc-5.4.0.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> gcc-5.4.0</span><br><span class="line">./contrib/download_prerequisites</span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">../configure -prefix=/usr/local --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">gcc -v</span><br><span class="line"><span class="built_in">cd</span> /usr/bin/</span><br><span class="line"><span class="built_in">mv</span> gcc gcc_back</span><br><span class="line"><span class="built_in">mv</span> g++ g++_back</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/gcc gcc</span><br><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/g++ g++</span><br><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line">find / -name libstdc++.so.6*</span><br><span class="line"><span class="comment"># 结果中找最高版本，查看GLIBCXX是否满足要求</span></span><br><span class="line">strings /usr/local/lib64/libstdc++.so.6.0.21 | grep GLIBCXX</span><br><span class="line"><span class="built_in">cp</span> /usr/local/lib64/libstdc++.so.6.0.21 /usr/lib64/libstdc++.so.6.0.21</span><br><span class="line"><span class="built_in">rm</span> -f /usr/lib64/lib</span><br><span class="line"><span class="built_in">ln</span> -s /usr/lib64/libstdc++.so.6.0.21 /usr/lib64/libstdc++.so.6</span><br></pre></td></tr></table></figure>

<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;  // 头文件</span><br><span class="line">using namespace std;  // 命名空间</span><br><span class="line"></span><br><span class="line">// main()是程序入口</span><br><span class="line">int main() &#123;</span><br><span class="line">    /* 程序入口 </span><br><span class="line">    * 跨行</span><br><span class="line">    */</span><br><span class="line">    cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认生成可执行文件 a.out</span></span><br><span class="line">g++ helloworld.cpp</span><br><span class="line">./a.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行文件的文件名</span></span><br><span class="line">g++ helloworld.cpp -o helloworld</span><br><span class="line">./helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定编译器版本</span></span><br><span class="line"><span class="comment"># -g 生成调试信息。GNU 调试器可利用该信息。</span></span><br><span class="line"><span class="comment"># -Wall 生成所有警告信息。</span></span><br><span class="line">g++ -g -Wall -std=c++11 helloworld.cpp -o helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本</span></span><br><span class="line">gcc helloworld.cpp -lstdc++ -o helloworld</span><br></pre></td></tr></table></figure>


<h2 id="核心语言-amp-基本语法"><a href="#核心语言-amp-基本语法" class="headerlink" title="核心语言 &amp; 基本语法"></a>核心语言 &amp; 基本语法</h2><ol>
<li><p>常量</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 枚举名week，枚举变量wk，标识符monday，</span><br><span class="line">// 变量只能是枚举标识符</span><br><span class="line">enum week</span><br><span class="line">&#123;</span><br><span class="line">    MONDAY,     // 首个值为0</span><br><span class="line">    TUESDAY=5,  // 标识符对应值</span><br><span class="line">    WEDNESDAY,   // 默认为上一个值+1</span><br><span class="line"></span><br><span class="line">&#125; wk;  // 直接声明枚举变量</span><br><span class="line">// 也可以后声明</span><br><span class="line">// week wk2;</span><br><span class="line">// 声明加定义</span><br><span class="line">// week wk2=MONDAY;</span><br></pre></td></tr></table></figure></li>
<li><p>类型转换</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态类型转换</span></span><br><span class="line"><span class="comment">// 静态将float类型转换为int类型，不进行运行时类型检查</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态转换-基类指针或引用转换为派生类，运行时检查</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base * ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* prt_derived = <span class="built_in">dynamic_case</span>&lt;Derived*&gt;(ptr_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量转换</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_case</span>&lt;<span class="type">int</span>&amp;&gt;(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新解释转换</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="keyword">reinterpret_cast</span>&lt;&gt;<span class="type">float</span>&amp;(i)</span><br></pre></td></tr></table></figure></li>
<li><p>变量</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量种类</span></span><br><span class="line"><span class="type">bool</span> <span class="type">char</span> <span class="type">int</span> <span class="type">float</span> doble <span class="type">void</span> <span class="type">wchar_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量声明-在任何地方声明一个变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;</span><br><span class="line"><span class="comment">// 变量定义</span></span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="comment">// 变量初始化</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b= <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值：指向内存位置的表达式，可以出现在赋值号的左边或右边</span></span><br><span class="line"><span class="comment">// 右值：存储在内存中某些地址的数值，无法赋值，只能出现在赋值号的右边</span></span><br><span class="line"><span class="comment">// 变量是左值，数值型的字面值是右值</span></span><br></pre></td></tr></table></figure></li>
<li><p>常量</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数常量</span></span><br><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点常量</span></span><br><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的 </span></span><br><span class="line"><span class="number">314159E-5</span>L    <span class="comment">// 合法的 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔常量</span></span><br><span class="line"><span class="literal">true</span> / <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符常量</span></span><br><span class="line"><span class="string">L&#x27;x&#x27;</span>  <span class="comment">// 宽字符常量，存储在wchar_t类型</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>  <span class="comment">// 窄字符常量，存储在char类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串常量</span></span><br><span class="line">string aa = <span class="string">&quot;hello, \</span></span><br><span class="line"><span class="string">world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰符</span></span><br><span class="line"><span class="comment">// 数据类型修饰符</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> num1 = <span class="number">-10</span>; <span class="comment">// 定义有符号整型变量 num1，初始值为 -10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">20</span>; <span class="comment">// 定义无符号整型变量 num2，初始值为 20</span></span><br><span class="line"><span class="type">short</span> <span class="type">int</span> num1 = <span class="number">10</span>; <span class="comment">// 定义短整型变量 num1，初始值为 10</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num2 = <span class="number">100000</span>; <span class="comment">// 定义长整型变量 num2，初始值为 100000</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> num1 = <span class="number">10000000000</span>; <span class="comment">// 定义长长整型变量 num1，初始值为 10000000000</span></span><br><span class="line"><span class="type">float</span> num1 = <span class="number">3.14f</span>; <span class="comment">// 定义单精度浮点数变量 num1，初始值为 3.14</span></span><br><span class="line"><span class="type">double</span> num2 = <span class="number">2.71828</span>; <span class="comment">// 定义双精度浮点数变量 num2，初始值为 2.71828</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 定义布尔类型变量 flag，初始值为 true</span></span><br><span class="line"><span class="type">char</span> ch1 = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 定义字符类型变量 ch1，初始值为 &#x27;a&#x27;</span></span><br><span class="line"><span class="type">wchar_t</span> ch2 = <span class="string">L&#x27;你&#x27;</span>; <span class="comment">// 定义宽字符类型变量 ch2，初始值为 &#x27;你&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储类</span></span><br><span class="line"><span class="comment">// static </span></span><br><span class="line"><span class="comment">// 指示编译器在程序的生命周期内保持局部变量的存在</span></span><br><span class="line"><span class="comment">// 当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</span></span><br><span class="line"><span class="comment">// static只是表示修饰的值是静态的，更多是限制作用域，而值本身可修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extern 用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 &#x27;extern&#x27; 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</span></span><br></pre></td></tr></table></figure></li>
<li><p>运算符-优先级从高到底</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">运算符</th>
<th align="center">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">后缀</td>
<td align="center">() [] -&gt; . ++ - -</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">一元</td>
<td align="center">+ - ! ~ ++ - - (type)* &amp; sizeof</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">乘除</td>
<td align="center">* &#x2F; %</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">加减</td>
<td align="center">+ -</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">移位</td>
<td align="center">&lt;&lt; &gt;&gt;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">关系</td>
<td align="center">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">相等</td>
<td align="center">&#x3D;&#x3D; !&#x3D;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">位与</td>
<td align="center">AND  &amp;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">位异或</td>
<td align="center">XOR     ^</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">位或</td>
<td align="center">OR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">逻辑与</td>
<td align="center">AND     &amp;&amp;</td>
<td align="center">从左到右</td>
</tr>
<tr>
<td align="center">逻辑或</td>
<td align="center">OR</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">条件</td>
<td align="center">?:</td>
<td align="center">从右到左</td>
</tr>
<tr>
<td align="center">赋值</td>
<td align="center">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D;</td>
<td align="center">&#x3D;</td>
</tr>
<tr>
<td align="center">逗号</td>
<td align="center">,</td>
<td align="center">从左到右</td>
</tr>
</tbody></table>
</li>
<li><p>函数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名表达式</span></span><br><span class="line">[capture](参数) -&gt; return_type &#123;函数体&#125;</span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) &#123;<span class="keyword">return</span> x &lt; y;&#125;</span><br><span class="line">[]&#123;++global_x;&#125;</span><br><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;<span class="type">int</span> z = x + y; <span class="keyword">return</span> z;&#125;</span><br><span class="line"><span class="comment">// capture可以为如下</span></span><br><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</span></span><br><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abssort</span><span class="params">(<span class="type">float</span>* x, <span class="type">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(x, x + n,</span><br><span class="line">        <span class="comment">// Lambda expression begins</span></span><br><span class="line">        [](<span class="type">float</span> a, <span class="type">float</span> b) &#123;</span><br><span class="line">            <span class="built_in">return</span> (std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b));</span><br><span class="line">        &#125; <span class="comment">// end of lambda expression</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> x[] = &#123;<span class="number">1.1</span>, <span class="number">0.8</span>, <span class="number">0.2</span>, <span class="number">0.5</span>&#125;;</span><br><span class="line"><span class="built_in">abssort</span>(x, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>字符串</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c风格字符串实际上是使用 null 字符 \0 终止的一维字符数组。</span></span><br><span class="line"><span class="comment">// 一个以 null 结尾的字符串，包含了组成字符串的字符。</span></span><br><span class="line"><span class="comment">// 由于在数组的末尾存储了空字符，所以字符数组的大小比字符串本身字符数多一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include&lt;cstring&gt; 大量的函数用来操作以 null 结尾的字符串:</span></span><br><span class="line"><span class="built_in">strcpy</span>(s1, s2);  <span class="comment">// 复制字符串 s2 到字符串 s1。</span></span><br><span class="line"><span class="built_in">strcat</span>(s1, s2);  <span class="comment">// 连接字符串 s2 到字符串 s1 的末尾。</span></span><br><span class="line"><span class="built_in">strlen</span>(s1);  <span class="comment">// 返回字符串 s1 的长度。</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1, s2);  <span class="comment">// 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</span></span><br><span class="line"><span class="built_in">strchr</span>(s1, ch);  <span class="comment">// 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置</span></span><br><span class="line"><span class="built_in">strstr</span>(s1, s2);  <span class="comment">// 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;string&gt;</span></span><br><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str += <span class="string">&quot;, world&quot;</span>;</span><br><span class="line">str.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure></li>
<li><p>时间</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 10位时间戳</span><br><span class="line">time_t now = time(0);</span><br><span class="line">cout &lt;&lt; &quot;1970 到目前经过秒数:&quot; &lt;&lt; now &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">// tm结构</span><br><span class="line">tm *ltm = localtime(&amp;now);</span><br><span class="line"> </span><br><span class="line">// 输出 tm 结构的各个组成部分</span><br><span class="line">cout &lt;&lt; &quot;年: &quot;&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;月: &quot;&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;日: &quot;&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;时间: &quot;&lt;&lt; ltm-&gt;tm_hour &lt;&lt; &quot;:&quot;;</span><br><span class="line">cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; &quot;:&quot;;</span><br><span class="line">cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li><p>结构体</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; book;</span><br><span class="line"><span class="built_in">strcpy</span>(book.title, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">cout &lt;&lt; book.title &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="类-amp-对象"><a href="#类-amp-对象" class="headerlink" title="类 &amp; 对象"></a>类 &amp; 对象</h2><ol>
<li>类成员函数<br> 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。</li>
<li>类访问修饰符<br> 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private，类继承也有该修饰符，默认也是private。<ol>
<li>public<br> 公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值</li>
<li>private<br> 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。派生类也不能。默认情况下，类的所有成员都是私有的。</li>
<li>protect<br> protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。</li>
<li>在继承中的特点（分别以继承修饰符和基类各个修复符中的最严为准）<ol>
<li>public:<br> 基类：public&#x2F;protect&#x2F;private<br> 子类：public&#x2F;protect&#x2F;private</li>
<li>protect:<br> 基类：public&#x2F;protect&#x2F;private<br> 子类：protect&#x2F;protect&#x2F;protect            </li>
<li>private:<br> 基类：public&#x2F;protect&#x2F;private<br> 子类：private&#x2F;private&#x2F;private</li>
</ol>
</li>
</ol>
</li>
<li>构造函数 &amp; 析构函数<br> 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。</li>
<li>拷贝构造函数<br> 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。<ol>
<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>
<li>复制对象把它作为参数传递给函数。</li>
<li>复制对象，并从函数返回这个对象。</li>
</ol>
</li>
<li>友元函数<br> 友元函数可以访问类的 private 和 protected 成员。<ol>
<li>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元类整个类及其所有成员都是友元。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">double</span> width;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">double</span> length;</span><br><span class="line">        <span class="comment">// 友元函数</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>;</span><br><span class="line">        <span class="comment">// 友元类</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BigBox</span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">( <span class="type">double</span> wid )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>内联函数<ol>
<li>通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。</li>
<li>一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。</li>
<li>如果已定义的函数多于一行，编译器会忽略 inline 限定符。</li>
</ol>
</li>
<li>C++ 中的 this 指针<ol>
<li>每个对象都有一个特殊的指针 this，它指向对象本身。</li>
<li>this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</li>
<li>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</li>
</ol>
</li>
<li>C++ 中指向类的指针<br> 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。</li>
<li>C++ 类的静态成员<ol>
<li>类的数据成员和函数成员都可以被声明为静态的。</li>
<li>我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</li>
<li>静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。</li>
<li>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。</li>
<li>静态成员函数与普通成员函数的区别<ol>
<li>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>
<li>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="类特点"><a href="#类特点" class="headerlink" title="类特点"></a>类特点</h2><ol>
<li>封装-把数据和操作数据的函数捆绑在一起的机制<br> 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。</li>
<li>抽象-仅向用户暴露接口而把具体的实现细节隐藏起来的机制。<br> 好处  <ol>
<li>类的内部受到保护，不会因无意的用户级错误导致对象状态受损。</li>
<li>类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。</li>
</ol>
</li>
<li>继承<ol>
<li>继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</li>
<li>一个派生类继承了所有的基类方法，但下列情况除外：<ol>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数</li>
</ol>
</li>
<li>派生类在继承基类的成员变量时，会单独开辟一块内存保存基类的成员变量，因此派生类自己的成员变量即使和基类的成员变量重名，但是也不会引起冲突。</li>
</ol>
</li>
<li>重载<ol>
<li>在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</li>
<li>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</li>
<li>选择最合适的重载函数或重载运算符的过程，称为重载决策。</li>
<li>重载运算符 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一元重载 !obj、-obj、--obj、++obj、obj++</span></span><br><span class="line">CLASS_NAME <span class="keyword">operator</span>- () </span><br><span class="line"><span class="comment">// 二元重载 +、-、x、/</span></span><br><span class="line">CLASS_NAME <span class="keyword">operator</span>+(<span class="type">const</span> CLASS_NAME&amp; b)</span><br><span class="line"><span class="comment">// 关系运算符  &lt; 、 &gt; 、 &lt;= 、 &gt;= 、 ==</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> CLASS_NAME&amp; b)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>多态<ol>
<li>当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</li>
<li>基类指针执行派生类对象时，<ol>
<li>静态链接：基类指针调用基类方法获取基类数据。</li>
<li>动态链接：基类函数使用virtual声明，编译器根据指针指向的对象动态绑定到对象方法，获取对象数据。</li>
</ol>
</li>
<li>可以发现派生类的函数和数据与基类是不同空间。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> aa)</span> </span>&#123;a = aa;&#125;;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// void set(int aa) &#123;a = aa;&#125;;</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B bb;</span><br><span class="line">    bb.<span class="built_in">set</span>(<span class="number">1</span>);  <span class="comment">// 基类A的a=1</span></span><br><span class="line">    <span class="comment">// 派生类B的get方法覆盖了基类同名方法，返回派生类B的a初始化默认值0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bb.get()&quot;</span> &lt;&lt; bb.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>虚函数<br> 派生类中如果与基类同名，则放在不同空间，派生类中如果没有，则拷贝一份基类放在不同空间。理论上，基类和派生类只能调用各自的方法，但是基类指针指向派生类对象时，要想让基类指针调用派生类方法，需要在基类该方法前加virtual。</li>
<li>纯虚函数<ol>
<li>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的。</li>
<li>抽象类不能被用于实例化对象，它只能作为接口使用。</li>
<li>子类需要被实例化，则必须实现每个纯虚函数。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><ol>
<li>动态内存 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>* pvalue  = <span class="literal">NULL</span>; <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">double</span>;   <span class="comment">// 为变量请求内存</span></span><br><span class="line">*pvalue = <span class="number">29494.99</span>;     <span class="comment">// 在分配的地址存储值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Value of pvalue : &quot;</span> &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> pvalue;         <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pvalue  = <span class="literal">NULL</span>;   <span class="comment">// 初始化为 null 的指针</span></span><br><span class="line">pvalue  = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>]; <span class="comment">// 为变量请求内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维数组，动态分配,数组长度为 m</span></span><br><span class="line"><span class="type">int</span> *array = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="keyword">delete</span> [] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> **array = <span class="keyword">new</span> <span class="type">int</span> *[m];</span><br><span class="line"><span class="comment">// 动态分配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    array[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] array[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] array;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>模版<ol>
<li>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</li>
<li>可以使用模板来定义函数和类。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数模版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">Max</span><span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        vector&lt;T&gt; elems;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elems.<span class="built_in">empty</span>()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>();         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt;         intStack;  <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;string&gt; stringStack;    <span class="comment">// string 类型的栈 </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line">        cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">        cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (exception <span class="type">const</span>&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>预处理器<ol>
<li>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</li>
<li>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</li>
<li>define预处理器 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (a&lt;b ? a : b)     </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line">   i = <span class="number">100</span>;</span><br><span class="line">   j = <span class="number">30</span>;</span><br><span class="line">   cout &lt;&lt;<span class="string">&quot;较小的值为：&quot;</span> &lt;&lt; <span class="built_in">MIN</span>(i, j) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>条件编译 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">   不进行编译的代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   cerr &lt;&lt;<span class="string">&quot;Trace: Inside main function&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// # 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKSTR( x ) #x</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">MKSTR</span>(HELLO C++) &lt;&lt; endl;  <span class="comment">// 返回字符串 HELLO C++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> concat(a, b) a ## b</span></span><br><span class="line"><span class="type">int</span> xy = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">concat</span>(x, y);  <span class="comment">// 等价于cout &lt;&lt; xy;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>多线程 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// 必须的头文件</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS 5</span><br><span class="line"> </span><br><span class="line">// 线程的运行函数</span><br><span class="line">void* say_hello(void* args)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello Runoob！&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 定义线程的 id 变量，多个变量使用数组</span><br><span class="line">    pthread_t tids[NUM_THREADS];</span><br><span class="line">    for(int i = 0; i &lt; NUM_THREADS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span><br><span class="line">        int ret = pthread_create(&amp;tids[i], NULL, say_hello, NULL);</span><br><span class="line">        if (ret != 0)</span><br><span class="line">        &#123;</span><br><span class="line">           cout &lt;&lt; &quot;pthread_create error: error_code=&quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ 标准库</h2><h2 id="C-标准模版库"><a href="#C-标准模版库" class="headerlink" title="C++ 标准模版库"></a>C++ 标准模版库</h2><ol>
<li>C++ 标准模板库的核心包括以下三个组件：<ol>
<li>容器<br> 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</li>
<li>算法<br> 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</li>
<li>迭代器<br> 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</li>
</ol>
</li>
<li>容器<ol>
<li>vector-数组，又称变长数组， <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// 在GCC的实现中，vector扩容是2倍扩容的</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;  <span class="comment">// 定义一个vector，其中的元素为int类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];  <span class="comment">// 定义一个vector数组，其中有N个vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(len)</span></span>;  <span class="comment">// 定义一个长度为len的vector，初始化每个元素为0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(len, x)</span></span>;  <span class="comment">// 定义一个长度为len的vector，初始化每个元素为x</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;  <span class="comment">// 用v1给v2赋值，v1的类型为vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.begin() + <span class="number">3</span>)</span></span>;  <span class="comment">// 将v1中第0~2三个元素赋值给v2</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 初始化vector，v:&#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();  <span class="comment">// 定义vector的迭代器，指向begin()</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);  <span class="comment">// 在vector的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;</span></span><br><span class="line">v.<span class="built_in">pop_back</span>();  <span class="comment">// 删除vector的最后一个元素，v:&#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);  <span class="comment">// 返回第一个大于等于4的元素的迭代器</span></span><br><span class="line"><span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);  <span class="comment">// 返回第一个大于4的元素的迭代器</span></span><br><span class="line">v.<span class="built_in">front</span>();  <span class="comment">// 返回vector中的第一个元素</span></span><br><span class="line">v.<span class="built_in">back</span>();  <span class="comment">// 返回vector中的最后一个元素</span></span><br><span class="line">v.<span class="built_in">begin</span>();  <span class="comment">// 返回vector第一个元素的迭代器</span></span><br><span class="line">v.<span class="built_in">end</span>();  <span class="comment">// 返回vector最后一个元素后一个位置的迭代器</span></span><br><span class="line">v.<span class="built_in">size</span>();  <span class="comment">// 返回vector中元素的个数</span></span><br><span class="line">v.<span class="built_in">empty</span>();  <span class="comment">// 返回vector是否为空，若为空则返回true否则返回false</span></span><br><span class="line">v.<span class="built_in">clear</span>();  <span class="comment">// 清空vector</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());  <span class="comment">// 删除迭代器it所指向的元素，即删除第一个元素</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除区间[v.begin(), v.begin() + 2)的所有元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">1</span>);  <span class="comment">// 在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据下标进行遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// for_each遍历(C++11)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>stack-栈，后进先出 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">// 除了最顶端以外，没有任何方法可以存取，stack不允许有遍历行为</span></span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;  <span class="comment">// 定义一个stack，其中元素的类型为int</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk[N];  <span class="comment">// 定义一个stack数组，其中有N个stack</span></span><br><span class="line"></span><br><span class="line">stk.<span class="built_in">push</span>(x);  <span class="comment">// 在stack中插入元素x</span></span><br><span class="line">stk.<span class="built_in">pop</span>();  <span class="comment">// 弹出stack的栈顶元素</span></span><br><span class="line">stk.<span class="built_in">top</span>();  <span class="comment">// 返回stack的栈顶元素</span></span><br><span class="line">stk.<span class="built_in">size</span>();  <span class="comment">// 返回stack中元素的个数</span></span><br><span class="line">stk.<span class="built_in">empty</span>();  <span class="comment">// 返回stack是否为空，若为空则返回true否则返回false</span></span><br></pre></td></tr></table></figure></li>
<li>string-字符串 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// string和vector&lt;char&gt;在数据结构、内存管理等方面都是相同的</span></span><br><span class="line"><span class="comment">// string可以使用c_str()函数转换为C风格的字符串</span></span><br><span class="line"></span><br><span class="line">string str;  <span class="comment">// 定义一个空的字符串</span></span><br><span class="line">string str[N];  <span class="comment">// 定义一个string数组，其中有N个string</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">// 使用5个字符&#x27;a&#x27;初始化</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;  <span class="comment">// 使用字符串初始化</span></span><br><span class="line">string str = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;  <span class="comment">// 字符常量初始化，str=&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;d&#x27;</span>);  <span class="comment">// 在string尾部插入字符，&quot;abcabcd&quot;</span></span><br><span class="line">str.<span class="built_in">pop_back</span>();  <span class="comment">// 删除string尾部的字符，&quot;abcabc&quot;</span></span><br><span class="line">str.<span class="built_in">length</span>();  <span class="comment">// 返回string中字符的个数</span></span><br><span class="line">str.<span class="built_in">size</span>();  <span class="comment">// 作用与length()相同</span></span><br><span class="line">str.<span class="built_in">empty</span>();  <span class="comment">// 返回string是否为空，若为空返回true否则返回false</span></span><br><span class="line">str.<span class="built_in">substr</span>(<span class="number">1</span>);  <span class="comment">// 返回string中从下标为1开始至末尾的子串，&quot;bcabc&quot;</span></span><br><span class="line">str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>);  <span class="comment">// 返回string中从下标为0开始长度为2的子串，&quot;ab&quot;</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;x&#x27;</span>);  <span class="comment">// 在下标为1的字符前插入2个字符&#x27;x&#x27;，&quot;axxbcabc&quot;</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;yy&quot;</span>);  <span class="comment">// 在下标为1的字符前插入字符串&quot;yy&quot;，&quot;ayyxxbcabc&quot;</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">4</span>);  <span class="comment">// 删除从位置1开始的4个字符，&quot;abcabc&quot;</span></span><br><span class="line">str.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// 返回字符&#x27;b&#x27;在string中第一次出现的位置，返回1，若不存在则返回-1</span></span><br><span class="line">str.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);  <span class="comment">// 返回从位置2开始字符&#x27;b&#x27;在string中第一次出现的位置，返回4</span></span><br><span class="line">str.<span class="built_in">find</span>(<span class="string">&quot;bc&quot;</span>);  <span class="comment">// 同上，返回字符串第一次出现的位置，返回1，若不存在则返回-1</span></span><br><span class="line">str.<span class="built_in">find</span>(<span class="string">&quot;bc&quot;</span>, <span class="number">2</span>);  <span class="comment">// 返回4</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// 反向查找，原理同上，返回4，若不存在则返回-1</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>);  <span class="comment">// 返回1</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&quot;bc&quot;</span>);  <span class="comment">// 返回4，若不存在则返回-1</span></span><br><span class="line">str.<span class="built_in">rfind</span>(<span class="string">&quot;bc&quot;</span>, <span class="number">3</span>);  <span class="comment">// 返回1</span></span><br><span class="line"><span class="built_in">stoi</span>(str);  <span class="comment">// 返回str的整数形式</span></span><br><span class="line"><span class="built_in">to_string</span>(value);  <span class="comment">// 返回value的字符串形式，value为整型、浮点型等</span></span><br><span class="line">str[<span class="number">0</span>];  <span class="comment">// 用下标访问string中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string中erase()与remove()的用法</span></span><br><span class="line">string str1, str2, str3, str4, str5;</span><br><span class="line">str1 = str2 = str3 = str4 = str5 = <span class="string">&quot;I love AcWing! It&#x27;s very funny!&quot;</span>;</span><br><span class="line">str1.<span class="built_in">erase</span>(<span class="number">15</span>);  <span class="comment">// 删除[15,end())的所有元素，&quot;I love AcWing!&quot;</span></span><br><span class="line">str2.<span class="built_in">erase</span>(<span class="number">6</span>, <span class="number">11</span>);  <span class="comment">// 从第6个元素(包括)开始往后删除11个元素，&quot;I love&#x27;s very funny!&quot;</span></span><br><span class="line">str3.<span class="built_in">erase</span>(str3.<span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除迭代器所指的元素，&quot;I ove AcWing! It&#x27;s very funny!&quot;</span></span><br><span class="line">str4.<span class="built_in">erase</span>(str4.<span class="built_in">begin</span>() + <span class="number">7</span>, str4.<span class="built_in">end</span>() - <span class="number">11</span>);  <span class="comment">// 删除[str4.begin()+7,str4.end()-11)的所有元素，&quot;I love very funny!&quot;</span></span><br><span class="line">str5.<span class="built_in">erase</span>(<span class="built_in">remove</span>(str5.<span class="built_in">begin</span>(), str5.<span class="built_in">end</span>(), <span class="string">&#x27;n&#x27;</span>), str5.<span class="built_in">end</span>());  <span class="comment">// 删除[str5.begin(),str5.end())中所有字符&#x27;n&#x27;，&quot;I love AcWig! It&#x27;s very fuy!&quot;</span></span><br><span class="line"><span class="comment">// remove是algorithm里的</span></span><br></pre></td></tr></table></figure></li>
<li>queue&#x2F;priirity_queue-队列&#x2F;优先队列 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">// queue 又称队列，是一种先进先出（First In First Out，FIFO）的数据结构</span></span><br><span class="line"><span class="comment">// priority_queue又称优先队列，同样定义在&lt;queue&gt;头文件中，与queue不同的地方在于我们可以自定义其中数据的优先级，优先级高的排在队列前面，优先出队。</span></span><br><span class="line"><span class="comment">// priority_queue的本质是用堆实现的，默认是大根堆。</span></span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;  <span class="comment">// 定义一个queue，其中元素的类型为int</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que[N];  <span class="comment">// 定义一个queue数组，其中有N个queue</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; bigHeap;  <span class="comment">// 定义一个大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; bigHeap;  <span class="comment">// 定义一个大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; smallHeap;  <span class="comment">// 定义一个小根堆</span></span><br><span class="line"></span><br><span class="line">que.<span class="built_in">push</span>(x);  <span class="comment">// 在queue的队尾插入元素x</span></span><br><span class="line">que.<span class="built_in">pop</span>();  <span class="comment">// 出队queue的队头元素</span></span><br><span class="line">que.<span class="built_in">front</span>();  <span class="comment">// 返回queue的队头元素</span></span><br><span class="line">que.<span class="built_in">back</span>();  <span class="comment">// 返回queue的队尾元素</span></span><br><span class="line">que.<span class="built_in">size</span>();  <span class="comment">// 返回queue中元素的个数</span></span><br><span class="line">que.<span class="built_in">empty</span>();  <span class="comment">// 返回queue是否为空，若为空则返回true否则返回false</span></span><br><span class="line">bigHeap.<span class="built_in">top</span>();  <span class="comment">// 返回priority_queue的队头元素</span></span><br></pre></td></tr></table></figure></li>
<li>deque-双端队列 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">// vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。</span></span><br><span class="line"><span class="comment">// vector也可以在头尾两端插入元素，但是在其头部进行插入操作效率很低。</span></span><br><span class="line"><span class="comment">// vector最大的差异一是在于deque允许使用常数项时间在头部进行元素的插入和删除操作，二是在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq;  <span class="comment">// 定义一个deque，其中的元素为int类型</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq[N];  <span class="comment">// 定义一个deque数组，其中有N个deque</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq</span><span class="params">(len)</span></span>;  <span class="comment">// 定义一个长度为len的deque</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq</span><span class="params">(len, x)</span></span>;  <span class="comment">// 定义一个长度为len的deque，初始化每个元素为x</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq2</span><span class="params">(deq1)</span></span>;  <span class="comment">// 用deq1给v2赋值，deq2的类型为deque</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deq2</span><span class="params">(deq1.begin(), deq1.begin() + <span class="number">3</span>)</span></span>;  <span class="comment">// 将deq1中第0~2三个元素赋值给deq2</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">// 初始化vector，v:&#123;1, 2, 3&#125;</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;::iterator it = deq.<span class="built_in">begin</span>();  <span class="comment">// 定义vector的迭代器，指向begin()</span></span><br><span class="line">deq.<span class="built_in">push_back</span>(<span class="number">4</span>);  <span class="comment">// 在deque的尾部插入元素4，v:&#123;1, 2, 3, 4&#125;</span></span><br><span class="line">deq.<span class="built_in">pop_back</span>();  <span class="comment">// 删除deque的尾部元素，v:&#123;1, 2, 3&#125;</span></span><br><span class="line">deq.<span class="built_in">push_front</span>(<span class="number">4</span>);  <span class="comment">// 在deque的头部插入元素4，v:&#123;4, 1, 2, 3&#125;</span></span><br><span class="line">deq.<span class="built_in">pop_front</span>();  <span class="comment">// 删除deque的头部元素，v:&#123;1, 2, 3&#125;</span></span><br><span class="line">deq.<span class="built_in">size</span>();  <span class="comment">// 返回deque中元素的个数</span></span><br><span class="line">deq.<span class="built_in">empty</span>();  <span class="comment">// 返回deque是否为空，若为空则返回true否则返回false</span></span><br><span class="line">deq.<span class="built_in">front</span>();  <span class="comment">// 返回deque中的第一个元素</span></span><br><span class="line">deq.<span class="built_in">back</span>();  <span class="comment">// 返回deque中的最后一个元素</span></span><br><span class="line">deq.<span class="built_in">begin</span>();  <span class="comment">// 返回deque第一个元素的迭代器</span></span><br><span class="line">deq.<span class="built_in">end</span>();  <span class="comment">// 返回deque最后一个元素后一个位置的迭代器</span></span><br><span class="line">deq.<span class="built_in">clear</span>();  <span class="comment">// 清空deque</span></span><br><span class="line">deq.<span class="built_in">erase</span>(deq.<span class="built_in">begin</span>());  <span class="comment">// 删除迭代器it所指向的元素，即删除第一个元素</span></span><br><span class="line">deq.<span class="built_in">erase</span>(deq.<span class="built_in">begin</span>(), deq.<span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除区间[v.begin(), v.begin() + 2)的所有元素</span></span><br><span class="line">deq.<span class="built_in">insert</span>(deq.<span class="built_in">begin</span>(), <span class="number">1</span>);  <span class="comment">// 在迭代器it所指向的位置前插入元素1，返回插入元素的迭代器</span></span><br></pre></td></tr></table></figure></li>
<li>map&#x2F;multimap <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>      <span class="comment">// std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">// map和multimap的底层实现机制都是红黑树。</span></span><br><span class="line"><span class="comment">// map所有的元素都是pair，同时拥有键值和实值（即(key, value)对），</span></span><br><span class="line"><span class="comment">// 所有的元素都会根据元素的键值自动排序。</span></span><br><span class="line"><span class="comment">// map不允许两个元素有相同的键值。multimap和map的操作类似，唯一区别是multimap的键值允许重复。</span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;  <span class="comment">// 定义一个将string映射成int的map</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp[N];  <span class="comment">// 定义一个map数组，其中有N个map</span></span><br><span class="line">multimap&lt;string, <span class="type">int</span>&gt; mulmp;  <span class="comment">// 定义一个将string映射成int的multimap</span></span><br><span class="line">multimap&lt;string, <span class="type">int</span>&gt; mulmp[N];  <span class="comment">// 定义一个multimap数组，其中有N个multimap</span></span><br><span class="line"><span class="comment">// multimap由于可以存在相同key，所有没有[]取key对应value值的方法</span></span><br><span class="line"></span><br><span class="line">mp[<span class="string">&quot;abc&quot;</span>] = <span class="number">3</span>;  <span class="comment">// 将&quot;abc&quot;映射到3</span></span><br><span class="line">mp[<span class="string">&quot;ab&quot;</span>]++;  <span class="comment">// 将&quot;ab&quot;所映射的整数++</span></span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;cd&quot;</span>, <span class="number">2</span>));  <span class="comment">// 插入元素</span></span><br><span class="line">mp.<span class="built_in">insert</span>(&#123; <span class="string">&quot;ef&quot;</span>, <span class="number">5</span> &#125;);  <span class="comment">// 同上</span></span><br><span class="line">mp.<span class="built_in">size</span>();  <span class="comment">// 返回map中元素的个数</span></span><br><span class="line">mp.<span class="built_in">empty</span>();  <span class="comment">// 返回map是否为空，若为空返回true否则返回false</span></span><br><span class="line">mp.<span class="built_in">clear</span>();  <span class="comment">// 清空map</span></span><br><span class="line">mp.<span class="built_in">erase</span>(<span class="string">&quot;ef&quot;</span>);  <span class="comment">// 清除元素&#123;&quot;ef&quot;, 5&#125;</span></span><br><span class="line">mp[<span class="string">&quot;abc&quot;</span>];  <span class="comment">// 返回&quot;abc&quot;映射的值</span></span><br><span class="line">mp.<span class="built_in">begin</span>();  <span class="comment">// 返回map第一个元素的迭代器</span></span><br><span class="line">mp.<span class="built_in">end</span>();  <span class="comment">// 返回map最后一个元素后一个位置的迭代器</span></span><br><span class="line">mp.<span class="built_in">find</span>(<span class="string">&quot;ab&quot;</span>);  <span class="comment">// 返回第一个键值为&quot;ab&quot;的迭代器，若不存在则返回mp.end()</span></span><br><span class="line">mp.<span class="built_in">find</span>(&#123; <span class="string">&quot;abc&quot;</span>, <span class="number">3</span> &#125;);  <span class="comment">// 返回元素&#123;&quot;abc&quot;, 3&#125;的迭代器，若不存在则返回mp.end()</span></span><br><span class="line">mp.<span class="built_in">count</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 返回第一个键值为&quot;abc&quot;的元素数量1，由于map元素不能重复因此count返回值只有0或1</span></span><br><span class="line">mp.<span class="built_in">count</span>(&#123; <span class="string">&quot;abc&quot;</span>, <span class="number">2</span> &#125;);  <span class="comment">// 返回第一个键值为&quot;abc&quot;的元素数量1，注意和find不一样，count只判断第一个键值</span></span><br><span class="line">mp.<span class="built_in">lower_bound</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 返回第一个键值大于等于&quot;abc&quot;的元素的迭代器，&#123;&quot;abc&quot;, 3&#125;</span></span><br><span class="line">mp.<span class="built_in">upper_bound</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 返回第一个键值大于&quot;abc&quot;的元素的迭代器，&#123;&quot;cd&quot;, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;string, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; (*it).first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// for_each遍历(C++11)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : mp)</span><br><span class="line">    cout &lt;&lt; x.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 扩展推断范围的for_each遍历(C++17)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
<li>set&#x2F;mutiset-集合 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">// 元素是有序且不重复的。</span></span><br><span class="line"><span class="comment">// multiset允许有重复元素。</span></span><br><span class="line"><span class="comment">// set和multiset的底层实现都是红黑树。</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;  <span class="comment">// 定义一个set，其中的元素类型为int</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; st[N];  <span class="comment">// 定义一个set数组，其中有N个set</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mulst;  <span class="comment">// 定义一个multiset</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mulst[N];  <span class="comment">// 定义一个multiset数组，其中有N个multiset</span></span><br><span class="line"></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);  <span class="comment">// 插入元素5</span></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">6</span>);  <span class="comment">// 同上</span></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">7</span>);  <span class="comment">// 同上</span></span><br><span class="line">st.<span class="built_in">size</span>();  <span class="comment">// 返回set中元素的个数</span></span><br><span class="line">st.<span class="built_in">empty</span>();  <span class="comment">// 返回set是否为空，若为空返回true否则返回false</span></span><br><span class="line">st.<span class="built_in">erase</span>(<span class="number">6</span>);  <span class="comment">// 清除元素6</span></span><br><span class="line">st.<span class="built_in">begin</span>();  <span class="comment">// 返回set第一个元素的迭代器</span></span><br><span class="line">st.<span class="built_in">end</span>();  <span class="comment">// 返回set最后一个元素后一个位置的迭代器</span></span><br><span class="line">st.<span class="built_in">clear</span>();  <span class="comment">// 清空set</span></span><br><span class="line">st.<span class="built_in">find</span>(<span class="number">5</span>);  <span class="comment">// 返回元素5的迭代器，若不存在则返回st.end()</span></span><br><span class="line">st.<span class="built_in">count</span>(<span class="number">5</span>);  <span class="comment">// 返回元素5的个数1，由于set元素不会重复，因此count返回值只有0或1</span></span><br><span class="line">st.<span class="built_in">lower_bound</span>(<span class="number">5</span>);  <span class="comment">// 返回第一个键值大于等于5的元素的迭代器，返回元素5的迭代器</span></span><br><span class="line">st.<span class="built_in">upper_bound</span>(<span class="number">5</span>);  <span class="comment">// 返回第一个键值大于5的元素的迭代器，返回元素7的迭代器</span></span><br></pre></td></tr></table></figure></li>
<li>unordered_map&#x2F;unordered_set <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无序，采用的是hash表结构，拥有快速检索的功能。</span></span><br><span class="line"><span class="comment">// unordered_map/unordered_set 增删改查的时间复杂度为O(1)</span></span><br><span class="line"><span class="comment">// 不支持lower_bound()/upper_bound()函数</span></span><br><span class="line"><span class="comment">// map/set增删改查的时间复杂度为O(logn)</span></span><br><span class="line"></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; st;  <span class="comment">// 定义一个unordered_set，其中的元素类型为int</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; st[N];  <span class="comment">// 定义一个unordered_set数组，其中有N个unordered_set</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;  <span class="comment">// 定义一个unordered_map</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp[N];  <span class="comment">// 定义一个unordered_map数组，其中有N个unordered_map</span></span><br><span class="line"></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);  <span class="comment">// 插入元素5</span></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">6</span>);  <span class="comment">// 同上</span></span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">7</span>);  <span class="comment">// 同上</span></span><br><span class="line">st.<span class="built_in">size</span>();  <span class="comment">// 返回unordered_set中元素的个数</span></span><br><span class="line">st.<span class="built_in">empty</span>();  <span class="comment">// 返回unordered_set是否为空，若为空返回true否则返回false</span></span><br><span class="line">st.<span class="built_in">erase</span>(<span class="number">6</span>);  <span class="comment">// 清除元素6</span></span><br><span class="line">st.<span class="built_in">find</span>(<span class="number">5</span>);  <span class="comment">// 返回元素5的迭代器，若不存在则返回st.end()</span></span><br><span class="line">st.<span class="built_in">count</span>(<span class="number">5</span>);  <span class="comment">// 返回元素5的个数，由于unordered_set元素不会重复，因此count返回值只有0或1</span></span><br><span class="line">st.<span class="built_in">begin</span>();  <span class="comment">// 返回unordered_set第一个元素的迭代器</span></span><br><span class="line">st.<span class="built_in">end</span>();  <span class="comment">// 返回unordered_set最后一个元素后一个位置的迭代器</span></span><br><span class="line">st.<span class="built_in">clear</span>();  <span class="comment">// 清空unordered_set</span></span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 插入元素&#123;1, 2&#125;</span></span><br><span class="line">mp.<span class="built_in">insert</span>(&#123; <span class="number">3</span>, <span class="number">4</span> &#125;);  <span class="comment">// 同上</span></span><br><span class="line">mp.<span class="built_in">size</span>();  <span class="comment">// 返回unordered_map中元素的个数</span></span><br><span class="line">mp.<span class="built_in">empty</span>();  <span class="comment">// 返回unordered_map是否为空，若为空返回true否则返回false</span></span><br><span class="line">mp.<span class="built_in">erase</span>(<span class="number">3</span>);  <span class="comment">// 清除元素&#123;3, 4&#125;</span></span><br><span class="line">mp.<span class="built_in">find</span>(<span class="number">1</span>);  <span class="comment">// 返回第一个键值为1的迭代器，若不存在则返回mp.end()</span></span><br><span class="line">mp.<span class="built_in">count</span>(<span class="number">1</span>);  <span class="comment">// 返回第一个键值为1的元素数量，由于unordered_map元素不能重复因此count返回值只有0或1</span></span><br><span class="line">mp.<span class="built_in">begin</span>();  <span class="comment">// 返回unordered_map第一个元素的迭代器</span></span><br><span class="line">mp.<span class="built_in">end</span>();  <span class="comment">// 返回unordered_map最后一个元素后一个位置的迭代器</span></span><br><span class="line">mp.<span class="built_in">clear</span>();  <span class="comment">// 清空unordered_map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (unordered_set&lt;<span class="type">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; (*it) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">// for_each遍历(C++11)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : st)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">    cout &lt;&lt; (*it).first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (*it).second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// for_each遍历(C++11)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : mp)</span><br><span class="line">    cout &lt;&lt; x.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 扩展推断范围的for_each遍历(C++17)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[k, v] : mp)</span><br><span class="line">    cout &lt;&lt; k &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="STL-算法"><a href="#STL-算法" class="headerlink" title="STL 算法"></a>STL 算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序算法</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">5</span>);  <span class="comment">// 将区间[0, 5)内元素按字典序从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">5</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// 将区间[0, 5)内元素按字典序从大到小排序</span></span><br><span class="line"><span class="built_in">reverse</span>(a, a + <span class="number">5</span>);  <span class="comment">// 将区间[0, 5)内元素翻转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找与统计算法</span></span><br><span class="line"><span class="built_in">find</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 在区间[0, 5)内查找等于3的元素，返回迭代器，若不存在则返回end()</span></span><br><span class="line"><span class="built_in">binary_search</span>(a, a + <span class="number">5</span>, <span class="number">2</span>);  <span class="comment">// 二分查找区间[0, 5)内是否存在元素2，若存在返回true否则返回false</span></span><br><span class="line"><span class="built_in">count</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 返回区间[0, 5)内元素3的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变序列算法</span></span><br><span class="line"><span class="built_in">copy</span>(a, a + <span class="number">2</span>, a + <span class="number">3</span>);  <span class="comment">// 将区间[0, 2)的元素复制到以a+3开始的区间，即[3, 5)</span></span><br><span class="line"><span class="built_in">replace</span>(a, a + <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 将区间[0, 5)内等于3的元素替换为4</span></span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">5</span>, <span class="number">1</span>);  <span class="comment">// 将1写入区间[0, 5)中(初始化数组函数)</span></span><br><span class="line"><span class="type">int</span>* pend = <span class="built_in">unique</span>(a, a + <span class="number">4</span>);  <span class="comment">// 将相邻元素间的重复元素全部移动至末端，返回去重之后数组最后一个元素之后的地址</span></span><br><span class="line"><span class="type">int</span>* pend = <span class="built_in">remove</span>(a, a + <span class="number">4</span>, <span class="number">3</span>);  <span class="comment">// 将区间[0, 5)中的元素3移至末端，返回新数组最后一个元素之后的地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>* p = c; p != pend; p++)</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://cplusplus.com/">官网</a><br><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html">菜鸟教程-c++</a><br><a href="https://www.acwing.com/blog/content/10558/">算法竞赛C++ STL容器、算法、迭代器详解</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>django</title>
    <url>/%E6%A1%86%E6%9E%B6/django/</url>
    <content><![CDATA[<p>Django是一个由Python编写的具有完整架站能力的开源Web框架。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>web 框架架构 <img src="/%E6%A1%86%E6%9E%B6/django/web_frame.png" class="" title="web 框架架构"></li>
<li>django 架构<ol>
<li>Django本身基于MVC架构，即Model（模型）+View（视图）+ Controller（控制器）设计模式，因此天然具有MVC的出色基因：开发快捷、部署方便、可重用性高、维护成本低等优点。</li>
<li>Django是一个全栈Web框架。所谓全栈框架，是指除了封装网络和线程操作，还提供HTTP请求和响应、数据库读写管理、HTML模板渲染等一系列功能的框架。</li>
<li>强大的数据库访问API。Django的Model层自带数据库ORM组件。</li>
<li>丰富的Template模板功能：Django自带类似jinjia的模板语言，不但原生功能丰富，还可以自定义模板标签和过滤器。并且以类似Python的调用机制和视图默契配合。</li>
<li>自带后台管理应用admin：只需要通过简单的几行配置和代码就可以实现一个完整的后台数据管理控制平台。这是Django最受欢迎的功能。</li>
</ol>
</li>
<li>MVC设计模式：<ol>
<li>模型(Model)：用于封装与应用程序的业务逻辑相关的数据及对数据的处理方法，是Web应用程序中用于处理应用程序的数据逻辑的部分，Model只提供功能性的接口，通过这些接口可以获取Model的所有功能。白话说，这个模块就是业务逻辑和数据库的交互层，定义了数据表。</li>
<li>视图(View)：负责数据的显示和呈现，是对用户的直接输出。</li>
<li>控制器(Controller)：负责从用户端收集用户的输入，可以看成提供View的反向功能。</li>
</ol>
</li>
<li>MTV设计模式<ol>
<li>模型(Model)：和MVC中的定义一样  </li>
<li>模板(Template)：将模型数据与HTML页面结合起来的引擎  </li>
<li>视图(View)：负责实际的业务逻辑实现</li>
</ol>
</li>
<li>Django对传统的MVC设计模式进行了修改<br> 将视图分成View模块和Template模块两部分，将动态的逻辑处理与静态的页面展示分离开。而Model采用了ORM技术，将关系型数据库表抽象成面向对象的Python类，将数据库的表操作转换成Python的类操作，避免了编写复杂的SQL语句。 <img src="/%E6%A1%86%E6%9E%B6/django/MTV.png" class="" title="web 框架架构"></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">python3 -m pip install Django</span><br><span class="line"># 或者</span><br><span class="line">pip3 install Django</span><br><span class="line"></span><br><span class="line"># 查看版本</span><br><span class="line">python -m django --version</span><br></pre></td></tr></table></figure>


<h1 id="创建项目过程"><a href="#创建项目过程" class="headerlink" title="创建项目过程"></a>创建项目过程</h1><ol>
<li>创建项目 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建项目目录</span><br><span class="line">mkdir -p /data/service/mysite</span><br><span class="line">cd /data/service/mysite</span><br><span class="line"></span><br><span class="line"># 创建虚拟环境</span><br><span class="line">virtualenv venv</span><br><span class="line"># 如果没有virtualenv则按照</span><br><span class="line">python3 -m pip install virtualenv</span><br><span class="line"># 激活虚拟环境</span><br><span class="line">source venv/bin/activate </span><br><span class="line"></span><br><span class="line"># 安装django</span><br><span class="line">python3 -m pip install Django</span><br><span class="line"></span><br><span class="line"># 当前目录下生成django项目</span><br><span class="line">django-admin startproject mysite .</span><br><span class="line"># 生成如下结构</span><br><span class="line">mysite/</span><br><span class="line">├── manage.py</span><br><span class="line">├── mysite</span><br><span class="line">│   ├── asgi.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── settings.py</span><br><span class="line">│   ├── urls.py</span><br><span class="line">│   └── wsgi.py</span><br><span class="line">└── venv</span><br><span class="line">    ├── bin</span><br><span class="line">    ├── lib</span><br><span class="line">    ├── lib64</span><br><span class="line">    └── pyvenv.cfg</span><br></pre></td></tr></table></figure></li>
<li>更新sqlite3(如果需要) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https://www.sqlite.org/2023/sqlite-autoconf-3410200.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压编译</span><br><span class="line">tar zxvf sqlite-autoconf-3410200.tar.gz</span><br><span class="line">cd sqlite-autoconf-3410200/</span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"># 删除旧的，关联新的</span><br><span class="line">mv /usr/bin/sqlite3 /usr/bin/sqlite3_old</span><br><span class="line">ln -s /usr/local/bin/sqlite3 /usr/bin/sqlite3</span><br><span class="line">echo &#x27;/usr/local/lib&#x27; &gt; /etc/ld.so.conf.d/sqlite3.conf</span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line"># 查看版本</span><br><span class="line">sqlite3 -version</span><br></pre></td></tr></table></figure></li>
<li>运行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加远程主机，防火墙也要放开监听端口通过</span><br><span class="line">vim mysite/settings.py </span><br><span class="line">ALLOWED_HOSTS = [&#x27;云主机IP&#x27;]</span><br><span class="line"></span><br><span class="line"># 仅本机浏览器查看，以127.0.0.1:8000这个默认配置启动开发服务器。</span><br><span class="line">python3 manage.py runserver</span><br><span class="line"></span><br><span class="line"># 远程云主机浏览器也能查看</span><br><span class="line">python3 manage.py runserver 0:8000</span><br><span class="line"></span><br><span class="line"># 浏览器查看</span><br><span class="line">http://&lt;服务器IP&gt;:8000</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="创建投票项目应用"><a href="#创建投票项目应用" class="headerlink" title="创建投票项目应用"></a>创建投票项目应用</h2><ol start="0">
<li>项目内容<br> 一个可以让公众用户进行投票和查看投票结果的站点<br> 一个可以进行增、删、改、查的后台管理界面，也就是我们常说的admin站点</li>
<li>请求和响应<ol>
<li>创建应用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py startapp polls</span><br><span class="line"></span><br><span class="line"># 结构如下</span><br><span class="line">polls/</span><br><span class="line">├── admin.py</span><br><span class="line">├── apps.py</span><br><span class="line">├── __init__.py</span><br><span class="line">├── migrations</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── models.py</span><br><span class="line">├── tests.py</span><br><span class="line">└── views.py</span><br></pre></td></tr></table></figure></li>
<li>修改<ol>
<li><p>根路由：vim mysite&#x2F;urls.py</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    # include语法相当于多级路由，它把接收到的url地址去除与此项匹配的部分</span><br><span class="line">    path(&#x27;polls/&#x27;, include(&#x27;polls.urls&#x27;)),</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>应用app路由：vim polls&#x2F;urls.py</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line"># 应用名，模版中防止不同应用相同路由</span><br><span class="line">app_name = &#x27;polls&#x27;</span><br><span class="line">urlpatterns = [</span><br><span class="line">    # ex: /polls/</span><br><span class="line">    path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;),</span><br><span class="line"></span><br><span class="line">    # ex: /polls/5/</span><br><span class="line">    path(&#x27;&lt;int:question_id&gt;/&#x27;, views.detail, name=&#x27;detail&#x27;),</span><br><span class="line"></span><br><span class="line">    # ex: /polls/5/results/</span><br><span class="line">    path(&#x27;&lt;int:question_id&gt;/results/&#x27;, views.results, name=&#x27;results&#x27;),</span><br><span class="line"></span><br><span class="line">    # ex: /polls/5/vote/</span><br><span class="line">    path(&#x27;&lt;int:question_id&gt;/vote/&#x27;, views.vote, name=&#x27;vote&#x27;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>模版文件：vim polls&#x2F;templates&#x2F;polls&#x2F;xxx.html</p>
<ol>
<li>展示最近5个问题：index.html <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&#123;% if latest_question_list %&#125;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &#123;% for question in latest_question_list %&#125;</span><br><span class="line">        &lt;li&gt;&lt;a href=&quot;&#123;%url &#x27;polls:detail&#x27; question.id %&#125;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;p&gt;No polls are available.&lt;/p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li>展示某个问题详情包括问题本身和投票项目 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;&#123;% url &#x27;polls:vote&#x27; question.id %&#125;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">    &lt;legend&gt;&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;/legend&gt;</span><br><span class="line">    &#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;</span><br><span class="line">    &#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">        &lt;input type=&quot;radio&quot; name=&quot;choice&quot; id=&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot; value=&quot;&#123;&#123; choice.id &#125;&#125;&quot;&gt;       &lt;label for=&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot;&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Vote&quot;&gt;</span><br><span class="line">&lt;/form&gt;               </span><br></pre></td></tr></table></figure></li>
<li>展示某个问题投票后结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for choice in question.choice_set.all %&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125; -- &#123;&#123; choice.votes &#125;&#125; vote&#123;&#123; choice.votes|pluralize &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;&#123;% url &#x27;polls:detail&#x27; question.id %&#125;&quot;&gt;Vote again?&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>视图函数：vim polls&#x2F;views.py</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, get_object_or_404</span><br><span class="line">from django.http import HttpResponse, HttpResponseRedirect, Http404</span><br><span class="line">from .models import Question</span><br><span class="line">from django.urls import reverse</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    &quot;&quot;&quot;展示最近5个问题&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    latest_question_list = Question.objects.order_by(&#x27;-pub_date&#x27;)[:5]</span><br><span class="line">    context = &#123;</span><br><span class="line">        &#x27;latest_question_list&#x27;: latest_question_list,</span><br><span class="line">    &#125;</span><br><span class="line">    return render(request, &#x27;polls/index.html&#x27;, context)</span><br><span class="line">    # return HttpResponse(template.render(context, request))</span><br><span class="line">    # return HttpResponse(&quot;hello, world. You&#x27;re at the polls index.&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def detail(request, question_id):</span><br><span class="line">    &quot;&quot;&quot;展示每个问题详情&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # try:</span><br><span class="line">    #     question = Question.objects.get(pk=question_id)</span><br><span class="line">    # except Question.DoesNotExist:</span><br><span class="line">    #     raise Http404(&quot;Question does not exist&quot;)</span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    return render(request, &#x27;polls/detail.html&#x27;, &#123;&#x27;question&#x27;: question&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def results(request, question_id):</span><br><span class="line">    &quot;&quot;&quot;投票结果&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    return render(request, &#x27;polls/results.html&#x27;, &#123;&#x27;question&#x27;: question&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def vote(request, question_id):</span><br><span class="line">    &quot;&quot;&quot;投票&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    question = get_object_or_404(Question, pk=question_id)</span><br><span class="line">    try:</span><br><span class="line">        selected_choice = question.choice_set.get(pk=request.POST[&#x27;choice&#x27;])</span><br><span class="line">    except (KeyError, Choice.DoesNotExist):</span><br><span class="line">        # 投票选项不存在,返回详情页</span><br><span class="line">        return render(request, &#x27;polls/detail.html&#x27;, &#123;</span><br><span class="line">            &#x27;question&#x27;: question,</span><br><span class="line">            &#x27;error_message&#x27;: &quot;You didn&#x27;t select a choice.&quot;,</span><br><span class="line">        &#125;)</span><br><span class="line">    else:</span><br><span class="line">        # 投票选项存在,增加该选项值,返回投票结果页</span><br><span class="line">        selected_choice.votes += 1</span><br><span class="line">        selected_choice.save()</span><br><span class="line">        return HttpResponseRedirect(reverse(&#x27;polls:results&#x27;, args=(question.id,)))</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 浏览器输入</span><br><span class="line">http://&lt;服务器IP&gt;:8000/polls/</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>模型和数据库<ol>
<li>默认数据库sqlite3切换为mysql<br> vim mysite&#x2F;settings.py <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;mysite&#x27;,</span><br><span class="line">        &#x27;USER&#x27;: &#x27;root&#x27;,</span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;jesonlin&#x27;,</span><br><span class="line">        &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">        &#x27;OPTIONS&#x27;: &#123;&#x27;init_command&#x27;: &#x27;set names utf8mb4;&#x27;, &#x27;charset&#x27;: &#x27;utf8mb4&#x27;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 需要依赖包</span><br><span class="line">yum install mysql-devel</span><br><span class="line">yum install python3-devel</span><br><span class="line">yum install gcc</span><br><span class="line">pip3 install mysqlclient</span><br><span class="line"></span><br><span class="line"># 为 INSTALLED_APPS 默认应用创建表</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></li>
<li>其他设置<br> vim mysite&#x2F;settings.py <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TIME_ZONE = &#x27;Asia/Shanghai&#x27;</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...,</span><br><span class="line">    &#x27;polls&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>创建模型 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># polls/models.py</span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Question(models.Model):</span><br><span class="line">    question_text = models.CharField(max_length=200)</span><br><span class="line">    pub_date = models.DateTimeField(&#x27;date published&#x27;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.question_text</span><br><span class="line">    def was_published_recently(self):</span><br><span class="line">        return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1)</span><br><span class="line"></span><br><span class="line">class Choice(models.Model):</span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    choice_text = models.CharField(max_length=200)</span><br><span class="line">    votes = models.IntegerField(default=0)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.choice_text       </span><br></pre></td></tr></table></figure></li>
<li>将模型生效到数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成迁移文件</span><br><span class="line">python manage.py makemigrations polls</span><br><span class="line"># 查看具体sql语句</span><br><span class="line">python manage.py sqlmigrate polls 0001</span><br><span class="line"># 执行sql语句</span><br><span class="line">python manage.py migrate polls</span><br><span class="line"># 有多个数据库时候路由</span><br><span class="line"># python manage.py migrate polls --database config</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>django的python交互式命令行<ol>
<li>启动交互式命令行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># manage.py 会设置 DJANGO_SETTINGS_MODULE 环境变量</span><br><span class="line"># 这个变量会让 Django 根据 mysite/settings.py 文件来设置 Python 包的导入路径。</span><br><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure></li>
<li>通过orm插入DB数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from polls.models import Choice, Question</span><br><span class="line">&gt;&gt;&gt; Question.objects.all()</span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; from django.utils import timezone</span><br><span class="line">&gt;&gt;&gt; q = Question(question_text=&quot;What&#x27;s new?&quot;, pub_date=timezone.now())</span><br><span class="line">&gt;&gt;&gt; q.save()</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; q.id</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; q.question_text</span><br><span class="line">&quot;What&#x27;s new?&quot;</span><br><span class="line">&gt;&gt;&gt; q.pub_date</span><br><span class="line">datetime.datetime(2023, 4, 11, 13, 12, 18, 914351, tzinfo=&lt;UTC&gt;)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; q.question_text = &quot;What&#x27;s up?&quot;</span><br><span class="line">&gt;&gt;&gt; q.save()</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; Question.objects.all()</span><br><span class="line">&lt;QuerySet [&lt;Question: What&#x27;s up?&gt;]&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; current_year = timezone.now().year</span><br><span class="line">&gt;&gt;&gt; Question.objects.get(pub_date__year=current_year)</span><br><span class="line">&lt;Question: What&#x27;s up?&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"># pk 是primary key的简写</span><br><span class="line">&gt;&gt;&gt; q = Question.objects.get(pk=1)</span><br><span class="line">&gt;&gt;&gt; q.was_published_recently()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.all()</span><br><span class="line">&lt;QuerySet []&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"># 插入外键关联的数据</span><br><span class="line">&gt;&gt;&gt; q.choice_set.create(choice_text=&#x27;Not much&#x27;, votes=0)</span><br><span class="line">&lt;Choice: Not much&gt;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.create(choice_text=&#x27;The sky&#x27;, votes=0)</span><br><span class="line">&lt;Choice: The sky&gt;</span><br><span class="line">&gt;&gt;&gt; c = q.choice_set.create(choice_text=&#x27;Just hacking again&#x27;, votes=0)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"># 被外键关联，查看所有关联项目</span><br><span class="line">&gt;&gt;&gt; q.choice_set.all()</span><br><span class="line">&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;</span><br><span class="line">&gt;&gt;&gt; q.choice_set.count()</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>amdin 管理页面<ol start="0">
<li>管理页面 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://&lt;服务器IP&gt;:8000/admin/</span><br></pre></td></tr></table></figure></li>
<li>创建登录管理页面的超级用户 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line"># 按提示输入超级用户信息</span><br><span class="line"># 此时数据表auth_user就会插入一条用户信息</span><br></pre></td></tr></table></figure></li>
<li>向管理页面添加投票应用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># polls/admin.py</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from .models import Question</span><br><span class="line"># Register your models here.</span><br><span class="line"></span><br><span class="line">admin.site.register(Question)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>模版<ol start="0">
<li>配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysite/setting.py</span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        &#x27;APP_DIRS&#x27;: True, # 表示优先找每个app下的templates文件夹</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><pre><code>商品管理和展示（待实践）
</code></pre>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.djangoproject.com/">官网</a><br><a href="https://www.liujiangblog.com/course/django/">刘江-django教程</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch</title>
    <url>/%E5%AD%98%E5%82%A8/elasticsearch/</url>
    <content><![CDATA[<p>Elasticsearch 是一个分布式、高扩展、高实时的搜索与数据分析引擎。</p>
<span id="more"></span>

<p>待补充</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">全文搜索引擎 Elasticsearch 入门教程</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>flask</title>
    <url>/%E6%A1%86%E6%9E%B6/flask/</url>
    <content><![CDATA[<p>Flask 是一款针对Python的“微型框架”，它是构建更小应用、API和web服务的极佳选择。 Flask是任何不适用Django的Python web应用的默认选择。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>使用Flask构建应用，除了一些函数附上路由，它和写标准Python模块很相似。它真的很赞。</li>
<li>Flask不会提供一切您可能需要的内容，而是实现了web应用框架中最常用的核心组件，比如说URL路由、请求和响应对象和模板等。</li>
<li>作为Flask的用户，由您来决定选择和集成其他您可能用到的组件。比如说数据库访问或者表单生成和验证就不是Flask内置的功能。</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://flask.palletsprojects.com/en/2.2.x/">官网</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/%E5%B7%A5%E5%85%B7/git/</url>
    <content><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统，所有的版本控制系统，只能跟踪文本文件的改动，而无法跟踪二进制文件的改变。</p>
<span id="more"></span>

<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><ol>
<li>安装（cetos7为例） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install git</span><br><span class="line">&lt;!-- 验证 --&gt;</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure></li>
<li>配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 账号和邮箱 --&gt;</span><br><span class="line">git config --global user.name &quot;jesonlin&quot;</span><br><span class="line">git config --global user.email &quot;jesonlin@outlook.com&quot;</span><br><span class="line"></span><br><span class="line">&lt;!-- 颜色 --&gt;</span><br><span class="line">git config --global color.ui true</span><br><span class="line"></span><br><span class="line">&lt;!-- 设置别名 --&gt;</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">&lt;!-- 撤销暂存区git reset HEAD file --&gt;</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD&#x27;</span><br><span class="line">git config --global alias.last &#x27;log -1&#x27;</span><br><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure></li>
<li>查看配置信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">&lt;!-- 每个仓库下的配置位置 --&gt;</span><br><span class="line">.git/config</span><br><span class="line"></span><br><span class="line">&lt;!-- 全局配置位置 --&gt;</span><br><span class="line">~/.gitconfig</span><br></pre></td></tr></table></figure></li>
<li>忽略特殊文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line"></span><br><span class="line">&lt;!-- 官方提供各类忽略文件模版 --&gt;</span><br><span class="line">https://github.com/github/gitignore</span><br><span class="line"></span><br><span class="line">&lt;!-- 在线生成.gitignore --&gt;</span><br><span class="line">https://gitignore.itranswarp.com/</span><br><span class="line"></span><br><span class="line">&lt;!-- 检查某个文件被哪条规则忽略 --&gt;</span><br><span class="line">git check-ignore -v &lt;文件名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 被忽略情况下强制提交 --&gt;</span><br><span class="line">git add -f &lt;文件名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 不排除某些文件 --&gt;</span><br><span class="line">vim .gitignore</span><br><span class="line">!.gitignore</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol start="0">
<li>版本库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工作区：就是你在电脑里能看到的目录。</span><br><span class="line">暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</span><br><span class="line">版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</span><br></pre></td></tr></table></figure>
 <img src="/%E5%B7%A5%E5%85%B7/git/repository.jpg" class="" title="版本库">
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 针对工作区的修改</span><br><span class="line">1. git add: 将工作区修改添加到暂存区</span><br><span class="line">    &lt;!-- 添加/删除指定文件 --&gt;</span><br><span class="line">    git add/rm &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 添加新文件/修改过的文件，不包括删除文件 --&gt;</span><br><span class="line">    git add .</span><br><span class="line"></span><br><span class="line">    &lt;!-- --update update tracked files 添加有更新变化的被追踪的文件，不包括新添加的文件 --&gt;</span><br><span class="line">    git add -u</span><br><span class="line"></span><br><span class="line">    &lt;!-- --all，添加所有修改和新增的文件 --&gt;</span><br><span class="line">    git add -A . </span><br><span class="line">2. git checkout: 撤销工作区修改，将暂存区覆盖工作区</span><br><span class="line">    &lt;!-- 撤销工作区指定文件修改，用暂存区相应内容替换工作区内容 --&gt;</span><br><span class="line">    git checkout -- &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 撤销工作区所有修改，用暂存区替换工作区，不影响新增 --&gt;</span><br><span class="line">    git checkout .</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 针对暂存区的修改</span><br><span class="line">3. git commit: 将暂存区修改添加到版本库</span><br><span class="line">    git commit -m &quot;初始化&quot;</span><br><span class="line">4. git reset: 撤销暂存区修改，将版本库覆盖暂存区</span><br><span class="line">    &lt;!-- 版本库覆盖暂存区&lt;文件&gt; --&gt;</span><br><span class="line">    git reset HEAD &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 版本库覆盖暂存区和工作区&lt;文件&gt; --&gt;</span><br><span class="line">    git reset --hard HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></li>
<li>查看提交日志&#x2F;命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 提交日志 --&gt;</span><br><span class="line">git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">&lt;!-- 所有命令（包含回退/前进） --&gt;</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure></li>
<li>版本回退&#x2F;前进 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- --hard 表示工作区和暂存存都重置，无则表示只重置暂存区 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 回退上个版本 --&gt;</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line">&lt;!-- 回退上个版本，保留修改 --&gt;</span><br><span class="line">git reset --soft HEAD^</span><br><span class="line"></span><br><span class="line">&lt;!-- 回退前10个版本 --&gt;</span><br><span class="line">git reset --hard HEAD~10</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转到指定版本（包括回退和前进，只要记得commit的id） --&gt;</span><br><span class="line">git reset --hard 【COMMIT_ID】</span><br></pre></td></tr></table></figure></li>
<li>比较差异 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 比较工作区和暂存区的修改 --&gt;</span><br><span class="line">git diff &lt;文件名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 比较工作区和上一次commit后的修改 --&gt;</span><br><span class="line">git diff HEAD &lt;文件名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 比较暂存区和上一次commit后的修改 --&gt;</span><br><span class="line">git diff --cached &lt;文件名&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ol start="0">
<li>查看分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查看分支(-a 包括远端分支) --&gt;</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure></li>
<li>创建分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 创建分支 --&gt;</span><br><span class="line">git branch &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 切换分支 --&gt;</span><br><span class="line">git checkout &lt;新分支名&gt;</span><br><span class="line">git switch &lt;新分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 创建并切换到分支 --&gt;</span><br><span class="line">git checkout -b &lt;新分支名&gt;</span><br><span class="line">git switch -c &lt;新分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>推送分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin &lt;本地分支名&gt;:&lt;远端分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>删除分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 删除本地分支 --&gt;</span><br><span class="line">git branch -d &lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 删除远端分支 --&gt;</span><br><span class="line">git push origin :&lt;远端分支名&gt;</span><br><span class="line">git push origin --delete &lt;远端分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>合并分支 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 默认使用Fast forward，看不出来曾经做过合并 --&gt;</span><br><span class="line">git merge &lt;待合并的分支名&gt;</span><br><span class="line">&lt;!-- 使用普通模式，可以看出曾经合并过 --&gt;</span><br><span class="line">git merge --no-ff -m &quot;&quot; &lt;待合并分支名&gt;</span><br></pre></td></tr></table></figure>
 <img src="/%E5%B7%A5%E5%85%B7/git/merge-no-ff.png" class="" title="普通模式合并分支"></li>
<li>分支冲突 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 --&gt;</span><br><span class="line">&lt;!-- 手动修改后提交 --&gt;</span><br><span class="line">git add</span><br><span class="line">git commit -m </span><br><span class="line">&lt;!-- 查看提交日志 --&gt;</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure></li>
<li>分支策略<ol>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 <img src="/%E5%B7%A5%E5%85%B7/git/merge-strategy.png" class="" title="分支策略"></li>
</ol>
</li>
</ol>
<h2 id="实际开发（分支、多人开发冲突）"><a href="#实际开发（分支、多人开发冲突）" class="headerlink" title="实际开发（分支、多人开发冲突）"></a>实际开发（分支、多人开发冲突）</h2><ol start="0">
<li>分支基本情况<br> master<br> dev（当前已有修改）</li>
<li>stash (保存现场）<br> 临时需要修复bug <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 保存dev现场 --&gt;</span><br><span class="line">    git stash</span><br><span class="line"></span><br><span class="line">&lt;!-- 2. 切换到master分支 --&gt;</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">&lt;!-- 创建临时修复bug分支 --&gt;</span><br><span class="line">git checkout -b issue-101</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交修改 --&gt;</span><br><span class="line">git add -A .</span><br><span class="line">git commit -m &quot;fix buf 101&quot;</span><br><span class="line"></span><br><span class="line">&lt;!-- 切换到master分支 --&gt;</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">&lt;!-- 合并bug分支 --&gt;</span><br><span class="line">git merge --no-ff -m &quot;merge bug fix 101&quot; issue-101</span><br><span class="line"></span><br><span class="line">&lt;!-- 切换回dev分支 --&gt;</span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line">&lt;!-- 查看之前保存的现场 --&gt;</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line">&lt;!-- 还原旧的现场 --&gt;</span><br><span class="line">git stash apply</span><br><span class="line">&lt;!-- 还原旧的指定现场 --&gt;</span><br><span class="line">git stash apply stash@&#123;0&#125;</span><br><span class="line">&lt;!-- 删除旧的现场 --&gt;</span><br><span class="line">git stash drop</span><br><span class="line">&lt;!-- 还原并删除 --&gt;</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li>
<li>cherry-pick (重放bug修复到dev分支) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- dev 提交bug修复的提交id --&gt;</span><br><span class="line">git cherry-pick &lt;bug分支上修复bug的commit_id&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- cherry-pick 重放指定提交 --&gt;</span><br><span class="line">a - b - c -d    master</span><br><span class="line">    |</span><br><span class="line">    e - f - g   dev</span><br><span class="line">git checkout master</span><br><span class="line">git cherry-pick f</span><br><span class="line">&lt;!-- 将dev的f提交重放到master分支 --&gt;</span><br><span class="line">a - b - c -d - f   master</span><br><span class="line">    |</span><br><span class="line">    e - f - g   dev    </span><br><span class="line"></span><br><span class="line">&lt;!-- cherry-pick 重放指定多个提交 --&gt;</span><br><span class="line">git cherry-pick &lt;A-commit_id&gt; &lt;B-commit_id&gt;</span><br><span class="line">&lt;!-- cherry-pick 重放指定多个连续提交(A,B] --&gt;</span><br><span class="line">git cherry-pick &lt;A-commit_id&gt;..&lt;B-commit_id&gt;</span><br><span class="line">&lt;!-- cherry-pick 重放指定多个连续提交[A,B] --&gt;</span><br><span class="line">git cherry-pick &lt;A-commit_id&gt;^..&lt;B-commit_id&gt;</span><br></pre></td></tr></table></figure></li>
<li>多人协作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1. 试图推送自己的修改 --&gt;</span><br><span class="line">git push origin &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2. 如果推送失败，使用pull试图合并 --&gt;</span><br><span class="line">git pull</span><br><span class="line">&lt;!-- 如果pull提示没有tracking，则关联本地和远程分支名 --&gt;</span><br><span class="line">git branch --set-upstream-to &lt;本地分支名&gt; origin/&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 3. 如果合并有冲突，解决冲突并提交 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 4. 没有冲突或者冲突解决后，推送 --&gt;</span><br><span class="line">git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>rebase (变基操作把本地未push的分叉提交历史整理成直线) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">origin/master    a - b - c</span><br><span class="line">                     |</span><br><span class="line">local/master         d - e</span><br><span class="line">&lt;!-- 1. 本地已有1+未push得提交 --&gt;</span><br><span class="line">（d 和 e）</span><br><span class="line"></span><br><span class="line">&lt;!-- 2. 直接提交会报冲突 --&gt;</span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">&lt;!-- 3. 先把c拉取到本地 --&gt;</span><br><span class="line">git pull </span><br><span class="line"></span><br><span class="line">&lt;!-- 4. 此时本地提交比远程超前3个提交 --&gt;</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">&lt;!-- 5. 变基，改变本地两个未提交和远程新提交顺序--&gt;</span><br><span class="line">git rebase</span><br><span class="line"></span><br><span class="line">原本分叉的提交现在变成一条直线了，Git把我们本地的提交“挪动”了位置，放到远程新提交的后面，符合整体变更顺序。</span><br></pre></td></tr></table></figure>
 <img src="/%E5%B7%A5%E5%85%B7/git/rebase-1.jpg" class="" title="变基前本地提交记录">
 <img src="/%E5%B7%A5%E5%85%B7/git/rebase-2.jpg" class="" title="变基后本地提交记录"></li>
</ol>
<h2 id="标签（版本库快照。）"><a href="#标签（版本库快照。）" class="headerlink" title="标签（版本库快照。）"></a>标签（版本库快照。）</h2><ol>
<li>标签 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查看标签列表 --&gt;</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">&lt;!-- 查看标签 --&gt;</span><br><span class="line">git show &lt;标签名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 打标签 --&gt;</span><br><span class="line">git tag -a &lt;标签名&gt; -m &quot;xxx&quot; &lt;commit_id&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 推送指定/所有标签 --&gt;</span><br><span class="line">git push origin &lt;标签名&gt;</span><br><span class="line">git pusH origin --tags</span><br><span class="line"></span><br><span class="line">&lt;!-- 删除本地标签 --&gt;</span><br><span class="line">git tag -d &lt;标签名&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 删除远程标签 --&gt;</span><br><span class="line">git push origin :refs/tags/&lt;标签名&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><ol>
<li>创建本地仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir project</span><br><span class="line">cd project</span><br><span class="line">git init</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;init git&quot;</span><br></pre></td></tr></table></figure></li>
<li>远程仓库<ol>
<li>本地仓库关联远程仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 本地仓库关联远程仓库 --&gt;</span><br><span class="line">git remote add origin git@github.com:linjinzhong/blog.git</span><br><span class="line"></span><br><span class="line">&lt;!-- 解除关联 --&gt;</span><br><span class="line">$ git remote rm origin</span><br><span class="line"></span><br><span class="line">&lt;!-- 推送 --&gt;</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure></li>
<li>克隆远程仓库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 克隆远程仓库，默认只有master分钟 --&gt;</span><br><span class="line">git clone git@github.com:linjinzhong/blog.git</span><br><span class="line">&lt;!-- 克隆后希望拉取非master分支 --&gt;</span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">&lt;!-- 直接克隆非master分钟 --&gt;</span><br><span class="line">git clone -b ac git@gitlab.yopoint.vip:ac/YoPointSwift.git</span><br></pre></td></tr></table></figure></li>
<li>权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">&lt;!-- 一路回车 --&gt;</span><br><span class="line">ll /root/.ssh/</span><br><span class="line"></span><br><span class="line">&lt;!-- 将/root/.ssh/id_rsa.pub内容拷贝到git上 --&gt;</span><br><span class="line">cat /root/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">&lt;!-- git ssh地址 --&gt;</span><br><span class="line">https://github.com/settings/keys</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://git-scm.com/">git-官网</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰-Git教程</a><br><a href="https://www.runoob.com/git/git-tutorial.html">菜鸟-Git教程</a><br><a href="https://github.com/linjinzhong/blog/blob/source/source/_posts/git/git-cheat-sheet.pdf">Git-Cheat-Sheet</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>go</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/</url>
    <content><![CDATA[<p>Go 是由谷歌工程师 Robert Griesemer、Rob Pike 和 Ken Thompson 设计的。它是一种静态类型的、编译的语言。</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>centos-yum <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install golang</span><br></pre></td></tr></table></figure></li>
<li>centos-tar <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 下载 --&gt;</span><br><span class="line">https://go.dev/doc/install</span><br><span class="line">&lt;!-- 解压 --&gt;</span><br><span class="line">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.4.linux-amd64.tar.gz</span><br><span class="line">&lt;!-- 添加环境变量 --&gt;</span><br><span class="line">vim /etc/profile</span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br><span class="line">&lt;!-- 重启终端查看go版本 --&gt;</span><br><span class="line">go version</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="hello-word"><a href="#hello-word" class="headerlink" title="hello, word"></a>hello, word</h2><ol>
<li>Go 是由 packages（包）组成的。<br> vim main.go   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main  # 程序入口点，package main 告诉 Go 编译器，该程序被编译为可执行文件，而不是共享库。</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">  fmt.Println(&quot;Hello World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go build main.go</span><br><span class="line">./main</span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li>变量<br> Go 中的变量是明确声明的。Go 是一种静态类型的语言。这意味着在声明变量的时候会检查变量的类型。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a int  // 声明a为int型，并附初始值0</span><br><span class="line">var a = 1  // 等价于 var a int = 1 </span><br><span class="line">var a, b int = 1, 2</span><br><span class="line">a := 1  // 只能在函数内部</span><br></pre></td></tr></table></figure></li>
<li>整型、浮点型、无符号整型、字符串、布尔<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var e int = 1  // 整型：int, int8, int16, int32, int64</span><br><span class="line">var d float32 = 3.14  // 浮点数：float32 和 float64</span><br><span class="line">var c uint = 1  //无符号整型：uint, uint8, uint16, uint32, uint64, uintptr</span><br><span class="line">var b string = &#x27;hello&#x27;  // 字符串：string</span><br><span class="line">var a bool = true  // 布尔：bool</span><br></pre></td></tr></table></figure></li>
<li>数组、切片、maps <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a [5]int  // 一维数组</span><br><span class="line">var multiA [2][3]int  // 二维数组</span><br><span class="line"></span><br><span class="line">var b []int  // 切片容量为 0、长度为 0 的切片。</span><br><span class="line">numbers := make([]int, 5, 10)  // 初始长度为 5，容量为 10。</span><br><span class="line">numbers = append(numbers, 1, 2, 3, 4)  // append 函数将值添加到数组的末端</span><br></pre></td></tr></table></figure></li>
<li>maps <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var m map[string]int</span><br><span class="line">m[&#x27;xx&#x27;] = 2</span><br></pre></td></tr></table></figure></li>
<li>类型转换 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := 1.1</span><br><span class="line">b := int(a)</span><br></pre></td></tr></table></figure></li>
<li>条件语句<ol>
<li>if else <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if num := 9; num &lt; 0 &#123;</span><br><span class="line">    fmt.Println(num, &quot;is negative&quot;)</span><br><span class="line">&#125; else if num &lt; 10 &#123;</span><br><span class="line">    fmt.Println(num, &quot;has 1 digit&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    fmt.Println(num, &quot;has multiple digits&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>switch case <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 2</span><br><span class="line">switch i &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        fmt.Println(&quot;one&quot;)</span><br><span class="line">    case 2:</span><br><span class="line">        fmt.Println(&quot;two&quot;)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(&quot;none&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>循环 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i := 0</span><br><span class="line">sum := 0</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;  // 三个条件都可以去掉</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br></pre></td></tr></table></figure></li>
<li>指针<br> 在传递结构体作为参数时，或者在为定义的类型声明方法时，通常倾向于使用指针。<br> 传递值时，实际上是在复制值，这意味着更多的内存。<br> 通过指针，函数改变的值会反映在 方法&#x2F;函数 调用者身上。   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a := 12</span><br><span class="line">var ap *int</span><br><span class="line">ap = &amp;a</span><br><span class="line">var ap *int = &amp;a</span><br></pre></td></tr></table></figure></li>
<li>函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func add(a int, b int ) (c int, s string) &#123;</span><br><span class="line">    c = a + b</span><br><span class="line">    s = &quot;succ&quot;</span><br><span class="line">    return  // return c, s</span><br><span class="line">&#125;</span><br><span class="line">func add(a int, b int ) (int, string) &#123;  // 同时有或者没有变量名</span><br><span class="line">    c := a + b</span><br><span class="line">    s := &quot;succ&quot;</span><br><span class="line">    return  return c, s</span><br><span class="line">&#125;</span><br><span class="line">funcmain() &#123;</span><br><span class="line">    sum, msg := add(2, 1)</span><br><span class="line">    fmt.Println(sum, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>结构体、方法、接口<br>Go并不是一种完全面向对象的语言，但通过结构体（Struct）、接口（Interface）和方法（Method），它有很多面向对象的支持和感觉。  <ol>
<li>结构体：结构体是一种类型化的、不同字段的集合。结构体用于将数据分组 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 定义 --&gt;</span><br><span class="line">type person struct &#123;  // 有序</span><br><span class="line">    name string</span><br><span class="line">    age int</span><br><span class="line">    gender string</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 创建 --&gt;</span><br><span class="line">p := person&#123;name: &quot;Bob&quot;, age: 12, gender: &quot;Male&quot;&#125;</span><br><span class="line">p := person&#123;&quot;Bob&quot;, 12, &quot;Male&quot;&#125;</span><br><span class="line">&lt;!-- 访问 --&gt;</span><br><span class="line">fmt.Println(p.name, p.age, p.gender)</span><br><span class="line">&lt;!-- 指针访问 --&gt;</span><br><span class="line">p := &amp;person&#123;name: &quot;Bob&quot;, age: 12, gender: &quot;Male&quot;&#125;</span><br><span class="line">fmt.Println(p.name, p.age, p.gender)</span><br></pre></td></tr></table></figure></li>
<li>方法：方法（Method）是一种特殊的函数类型，它有一个 receiver 。receiver 可以是一个值或一个指针。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (p *person) describe() &#123;</span><br><span class="line">    fmt.Printf(&quot;%v is %v years old.\n&quot;, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line">func (p *person) setAge(age int) &#123;</span><br><span class="line">    p.age = age</span><br><span class="line">&#125;</span><br><span class="line">func (p person) setName(name string) &#123;  // receiver是结构体值，并不是指针，所以是拷贝修改，不影响调用体</span><br><span class="line">    p.name = name</span><br><span class="line">&#125;</span><br><span class="line">p := &amp;person&#123;name: &quot;Bob&quot;, age: 12, gender: &quot;Male&quot;&#125;</span><br><span class="line">p.describe()</span><br><span class="line">p.setAge(66)</span><br><span class="line">fmt.Println(p.age)</span><br><span class="line">p.setName(&quot;jesonlin&quot;)</span><br><span class="line">fmt.Println(p.name)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://golang.org/">go官网</a><br><a href="https://go.dev/play/">go在线运行</a><br><a href="https://www.freecodecamp.org/chinese/news/learning-go-from-zero-to-hero/">从 0 到 1 学习 Golang</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/%E5%B7%A5%E5%85%B7/hexo/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is quick start post. Check <a href="https://hexo.io/docs/">documentation</a> for more info.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-draft"><a href="#Create-a-new-draft" class="headerlink" title="Create a new draft"></a>Create a new draft</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft <span class="string">&quot;My New Draft&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Publish-a-new-draft"><a href="#Publish-a-new-draft" class="headerlink" title="Publish a new draft"></a>Publish a new draft</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish <span class="string">&quot;My New Draft&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new post <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mac-设置</title>
    <url>/%E5%B7%A5%E5%85%B7/mac-%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>记录下windows多年老用户切换到mac系统后更趁手的设置。</p>
<span id="more"></span>

<h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><ol>
<li>触控板选项-轻点省力  <ol>
<li>【系统偏好设置】-》【触控板】-》勾选【轻点来点按】  </li>
<li>触控板有很多好用的手势，可以实时学习</li>
</ol>
</li>
<li>三指拖移-拖拽超级好用<br> 【系统偏好设置】-》【辅助功能】-》【指针控制】-》【触控板选项】-》【启用拖移】三指拖移</li>
<li>访达偏好设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【桌面】-》左上角【访达】-》【偏好设置】-》 【边栏】-》勾上所需</span><br></pre></td></tr></table></figure></li>
<li>底部程序坞设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">鼠标置于程序坞-》双指按压-》程序坞偏好设置-》置于屏幕底部/自动隐藏</span><br></pre></td></tr></table></figure></li>
<li>顶部图标栏 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按住【cmd】键，三指拖拽顶部图标下拉，有出现删除标记可以删除</span><br></pre></td></tr></table></figure></li>
<li>文件显示 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序坞打开【访达】-》按住【cmd】+[up]键直到最顶层 -》点击左上角显示-》</span><br><span class="line">选择【为列表】</span><br><span class="line">选择【显示标签页栏】</span><br><span class="line">选择【显示路径栏】</span><br><span class="line">选择【显示状态栏】</span><br><span class="line">选择【查看选项】-》勾选【始终以列表】-》排序方式【修改日期】-》选中【用作默认】</span><br></pre></td></tr></table></figure></li>
<li>触发角 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【系统偏好设置】-》【桌面与屏幕保护程序】-》【触发角】</span><br><span class="line">【左上角】-》【将显示器置于休眠状态】</span><br><span class="line">【左下角】-》【启动屏幕保护程序】</span><br><span class="line">【右上角】-》【调度中心】</span><br><span class="line">【右下角】-》【桌面】</span><br></pre></td></tr></table></figure></li>
<li>终端设置<ol>
<li>窗口设置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开终端偏好设置-》样式选中【homebrew】-》字体大小选中【18】-》窗口选中列数100行数36</span><br></pre></td></tr></table></figure></li>
<li>brew <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27; &gt;&gt; /Users/XXXX/.zshrc</span><br><span class="line">echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27; &gt;&gt; /Users/jesonlin/.zshrc</span><br></pre></td></tr></table></figure></li>
<li>zsh  <ol>
<li>安装   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li>
<li>显示当前目录绝对路径   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.oh-my-zsh/themes/robbyrussell.zsh-theme</span><br><span class="line">PROMPT+=&#x27; %&#123;$fg[cyan]%&#125;%d%&#123;$reset_color%&#125; $(git_prompt_info)&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>别名的快捷操作 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line">export PATH=$HOME/bin:/usr/local/bin:/usr/bin:$PATH</span><br><span class="line">alias ll=&#x27;ls -alhF&#x27;</span><br><span class="line">alias subl=&quot;/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl&quot;</span><br><span class="line">alias -s py=subl</span><br><span class="line">eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Python环境<ol>
<li>安装pyenv   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</span><br><span class="line">vim ~/.zshrc</span><br><span class="line">export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;   </span><br></pre></td></tr></table></figure></li>
<li>查看看着Python版本 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv install -l</span><br></pre></td></tr></table></figure></li>
<li>安装python指定版本（m1 pro有问题） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv install 3.6.8</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>SMB共享的网络磁盘上DS_Store文件的阻止生成方案<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【终端】-》defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol start="0">
<li>复制&#x3D;&#x3D;拷贝+粘贴   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+ 【d】</span><br></pre></td></tr></table></figure></li>
<li>拷贝 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【c】</span><br></pre></td></tr></table></figure></li>
<li>粘贴  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【v】</span><br></pre></td></tr></table></figure></li>
<li>剪切（文本）   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【x】</span><br></pre></td></tr></table></figure></li>
<li>剪切（文件）   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【c】, 【cmd】 + 【opt】 + 【v】</span><br></pre></td></tr></table></figure></li>
<li>关闭软件   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【q】</span><br></pre></td></tr></table></figure></li>
<li>任务管理器   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【opt】 + 【esc】</span><br></pre></td></tr></table></figure></li>
<li>预览  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单击中 + 空格  / 三指单击</span><br></pre></td></tr></table></figure></li>
<li>数据查询和英文翻译   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三指单击</span><br></pre></td></tr></table></figure></li>
<li>截图  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全屏：【shift】 +【cmd】 + 【3】  </span><br><span class="line">指定区域：【shift】 + 【cmd】 + 【4】  </span><br><span class="line">特定窗口：【shift】 + 【cmd】 + 【4】 + 【space】  </span><br></pre></td></tr></table></figure></li>
<li>录屏<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【shift】 + 【cmd】 + 【5】</span><br></pre></td></tr></table></figure></li>
<li>聚焦搜索(升级为Alfred)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 + 【space】</span><br></pre></td></tr></table></figure></li>
<li>调出访达搜索<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【opt】+【space】</span><br></pre></td></tr></table></figure></li>
<li>delete<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【fn】+【backpace】</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><ol>
<li><p>连接服务器</p>
<ol>
<li>连接服务器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【桌面】-》【前往】-》【连接服务器】（【cmd】+【k】）</span><br><span class="line">smb://XXX.XXX.XXX.XXX/文件夹路径</span><br></pre></td></tr></table></figure></li>
<li>连接远程服务器<ol>
<li>安装smb服务 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install samba</span><br></pre></td></tr></table></figure></li>
<li>选择要共享的文件夹，添加权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /root</span><br></pre></td></tr></table></figure></li>
<li>打开smb配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br><span class="line">// 在global下面添加一行访问端口，因为运营商常把445端口拦截了</span><br><span class="line">[global]</span><br><span class="line">        smb ports = 1315 1314</span><br><span class="line">// 文件末尾添加访问名及其对应共享文件夹</span><br><span class="line">[share]</span><br><span class="line">    comment = Share Directories</span><br><span class="line">    path=/root</span><br><span class="line">    public = yes</span><br><span class="line">    browseable = yes</span><br><span class="line">    writable = yes</span><br><span class="line">    create mask = 0777</span><br><span class="line">    directory mask = 0777</span><br></pre></td></tr></table></figure></li>
<li>创建smb登录用户名 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch /etc/samba/smbpasswd #新建文件</span><br><span class="line">smbpasswd -a root</span><br></pre></td></tr></table></figure></li>
<li>并且将smb设置为开机自启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig --level 3 smb on</span><br></pre></td></tr></table></figure></li>
<li>重新启动smb <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service smb start</span><br></pre></td></tr></table></figure></li>
<li>腾讯云服务器-》防火墙-》开启1314 1315端口</li>
</ol>
</li>
</ol>
</li>
<li><p>键位映射-karabiner-elements-神器-模拟filco键盘键位  </p>
<ol>
<li>【系统偏好设置】-》【键盘】-》【按下地球仪fn键时】-》选中不做任何操作 </li>
<li>mac键位映射-》打开karabiner-elements<ol>
<li>【Profiles】  <ol>
<li>删除所有，保留一个默认的’default’</li>
<li>新建一个’mac’，这些配置会出现在【菜单栏karabiner-elements的下拉列表】</li>
<li>将配置文件mac.json放在【~&#x2F;.config&#x2F;karabiner&#x2F;assets&#x2F;complex_modifications】</li>
<li>文件路径也可在【Misc】-》【Export &amp; Import】双击打开</li>
</ol>
</li>
<li>【Device】选择【Apple Internal Keyboard】</li>
<li>【Simple modifications】-》【Apple Internal Keyboard】: 简单的键位映射 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn -&gt; caps lock</span><br><span class="line">caps lock -&gt; left_command</span><br><span class="line">left_command -&gt; fn</span><br></pre></td></tr></table></figure></li>
<li>【Complex modifications】-》【Apple Internal Keyboard】：复杂的组合映射<ol>
<li>【Add rule】</li>
<li>选择刚才mac.json中的四条映射规则<ol>
<li>fn + aesdfg &#x3D; head&#x2F;上&#x2F;左&#x2F;下&#x2F;右&#x2F;tail</li>
<li>right_command + k&#x2F;&lt; &#x3D; home&#x2F;end</li>
<li>right_command + l&#x2F;&gt; &#x3D; page_up&#x2F;page_down</li>
<li>绑定fn + tab &#x3D; left_command + tab</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>filco-minila-air键位映射-》打开karabiner-elements<ol>
<li>新建一个’filco’,会生成对应filco.json文件放在指定路径。</li>
<li>【Device】选中连接的filco蓝牙键盘</li>
<li>【Simple modifications】-》【FILCO XXX】: 简单的键位映射<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left_control -&gt; caps lock</span><br><span class="line">caps lock -&gt; left_command</span><br><span class="line">left_command -&gt; left_control</span><br></pre></td></tr></table></figure></li>
<li>【Function keys】-》【FILCO XXX】：功能键映射，将Fx键映射本身而不是mac上的功能。</li>
<li>【Complex modifications】-》【FILCO XXX】：复杂的组合映射<ol>
<li>【Add rule】</li>
<li>选择刚才filco.json中的两条映射规则<ol>
<li>left_option + esdfag &#x3D; head&#x2F;上&#x2F;左&#x2F;下&#x2F;右&#x2F;tail</li>
<li>left_option + tab &#x3D; left_command + tab</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h2><ol>
<li>屏保 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://fliqlo.com/</span><br></pre></td></tr></table></figure></li>
<li>搜狗输入法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://pinyin.sogou.com/mac/</span><br></pre></td></tr></table></figure></li>
<li>谷歌浏览器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.google.com/intl/zh-CN/chrome/</span><br><span class="line"># 插件</span><br><span class="line">https://chrome.google.com/webstore/category/extensions?hl=zh-CN</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. iTab新标签页（丰富的标签页）</span><br><span class="line">2. DJSON. JSON Viewer &amp; Formatter（json格式化）</span><br><span class="line">3. Markdown Preview Plus（可以用sublime打开md文件编辑，同时用chrome打开该文件实时刷新预览）</span><br><span class="line">4. 有道词典Chrome划词插件（翻译插件）</span><br><span class="line">5. Talend API Tester - Free Edition（发包工具）</span><br></pre></td></tr></table></figure></li>
<li>sublime <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.sublimetext.com</span><br></pre></td></tr></table></figure></li>
<li>xmind <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.xmind.cn/</span><br></pre></td></tr></table></figure></li>
<li>Alfred <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过一个输入框快速完成文件搜索、自定义动作</span><br><span class="line">https://www.alfredapp.com/</span><br><span class="line"># 先取消原有聚焦搜索快捷键</span><br><span class="line">【系统偏好设置】-》【键盘】-》【快捷键】-》【聚焦搜索】</span><br><span class="line"># 设置Alfred快捷键</span><br><span class="line">【cmd】+【space】</span><br><span class="line"># 其他设置待摸索</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://github.com/linjinzhong/Software/blob/master/filco.json">filco.json</a><br><a href="https://github.com/linjinzhong/Software/blob/master/mac.json">mac.json</a> </p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mac设置</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-事务</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。</p>
<span id="more"></span>

<h2 id="事务有哪些特性？-acid"><a href="#事务有哪些特性？-acid" class="headerlink" title="事务有哪些特性？ - acid"></a>事务有哪些特性？ - acid</h2><ol>
<li><p>原子性（atomicity）<br> 一个事务中的所有操作，要么全部完成，要么全部不完成。</p>
</li>
<li><p>一致性（consistency）<br> 事务操作前后，数据满足完整性约束，数据库保持一致性状态。</p>
</li>
<li><p>隔离性（isolation）<br> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</p>
</li>
<li><p>持久性（durability）<br> 事务处理结束后，对数据的修改是永久的，即便系统故障也不会丢失。</p>
</li>
</ol>
<h2 id="InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？"><a href="#InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？" class="headerlink" title="InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？"></a>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</h2><ol>
<li>原子性-通过 uodo log(回滚日志)来保证。</li>
<li>一致性-通过持久性+原子性+隔离性来保证。</li>
<li>隔离性-通过MVCC（多版本并发控制）或锁机制来保证。</li>
<li>持久性-通过 redo log（重放日志）来保证。</li>
</ol>
<h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。那么在同时处理多个事务的时候，可能出现如下问题</p>
<p>严重性排序如下：</p>
<img src="./并行事务引发的问题.webp" width = "50%" height = "50%" alt="并行事务引发的问题" align=center />

<ol>
<li><p>脏读 - 读到其他事务未提交的数据<br> 如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p>
</li>
<li><p>不可重复读 - 前后读取的数据不一致<br> 在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。 </p>
</li>
<li><p>幻读 - 前后读取的记录数量不一致<br> 在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p>
</li>
</ol>
<h2 id="事务的隔离级别有哪些"><a href="#事务的隔离级别有哪些" class="headerlink" title="事务的隔离级别有哪些"></a>事务的隔离级别有哪些</h2><p>按隔离水平高低排序如下：<br><img src="./隔离级别.webp" width = "50%" height = "50%" alt="隔离级别" align=center /></p>
<ol>
<li>读未提交（read uncommitted）<br> 指一个事务还没提交时，它做的变更就能被其他事务看到；</li>
<li>读提交（read committed）<br> 指一个事务提交之后，它做的变更才能被其他事务看到；</li>
<li>可重复读（repeatable read）<br> 指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；</li>
<li>串行化（serializable ）<br> 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ol>
<p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。</p>
<p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了，详见这篇文章 (opens new window)），解决的方案有两种：</p>
<ol>
<li>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。</li>
<li>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，</li>
</ol>
<h2 id="事务的隔离级别实现"><a href="#事务的隔离级别实现" class="headerlink" title="事务的隔离级别实现"></a>事务的隔离级别实现</h2><ol>
<li>读未提交，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li>
<li>读提交，通过 Read View 来实现的，可以理解成一个数据快照。在「每个语句执行前」都会重新生成一个 Read View。</li>
<li>可重复读，通过 Read View 来实现的，可以理解成一个数据快照。在「启动事务时」生成一个 Read View。然后整个事务期间都在用这个 Read View。</li>
<li>串行化，通过加读写锁的方式来避免并行访问；</li>
</ol>
<h2 id="Read-View-在-MVCC-里如何工作的？"><a href="#Read-View-在-MVCC-里如何工作的？" class="headerlink" title="Read View 在 MVCC 里如何工作的？"></a>Read View 在 MVCC 里如何工作的？</h2><ol>
<li><p>Read View 结构</p>
 <img src="./readview结构.webp" width = "50%" height = "50%" alt="readview结构" align=center />

<ol>
<li>creator_trx_id：创建该 Read View 的事务的事务 id。</li>
<li>m_ids：创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。</li>
<li>min_trx_id：在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。</li>
<li>max_trx_id：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；</li>
</ol>
</li>
<li><p>聚簇索引记录的两个隐藏列</p>
 <img src="./记录隐藏列.webp" width = "50%" height = "50%" alt="记录隐藏列" align=center />

<ol>
<li>trx_id：当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li>
<li>roll_pointer（undo log）：每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo log日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。</li>
</ol>
</li>
<li><p>记录里的事务id trx_id 的划分情况</p>
 <img src="./trx_id_所有记录.webp" width = "50%" height = "50%" alt="trx_id_所有记录" align=center />

<p> 一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<pre><code> 1. 如果 trx_id &lt; Read View 中的 min_trx_id，表示这个版本的记录是在创建 Read View 之前已经提交的事务生成的，是可见的。

 2. 如果 trx_id &gt;= Read View 中的 max_trx_id，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，是不可见的。

 3. 如果 min_trx_id &lt;= trx_id &lt; max_trx_id，需要判断 trx_id 是否在 m_ids 列表中：
     1. 如果在列表中，表示生成该版本记录的活跃事务依然活跃（还没提交事务），不可见
     2. 如果不在列表中，表示生成该版本记录的活跃事务已经被提交，可见。
</code></pre>
<p> 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</p>
</li>
</ol>
<h2 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h2><p>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。</p>
<p>然后根据 Read View(读视图) 和 记录里两个隐藏列 trx_id(事务id) 和 undo log() 来实现。</p>
<h2 id="读提交是如何工作的？"><a href="#读提交是如何工作的？" class="headerlink" title="读提交是如何工作的？"></a>读提交是如何工作的？</h2><p>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。</p>
<p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
<h2 id="MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p>
<pre><code>1. 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。

2. 针对当前读（select ... for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。
</code></pre>
<p>这两个解决方案是很大程度上解决了幻读现象，但是还是有个别的情况造成的幻读现象是无法解决的。</p>
<ol>
<li><p>快照读是如何避免幻读的？<br> 可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
</li>
<li><p>当前读是如何避免幻读的？<br> MySQL 里除了普通查询是快照读，其他都是当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p>
<p> 这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p>
<p> Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了间隙锁。</p>
<p> 事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。</p>
<p> 然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象。</p>
</li>
<li><p>幻读被完全解决了吗？<br> 可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读。</p>
<p> 在可重复读隔离级别下</p>
<pre><code> 事务 A 第一次执行普通的 select 语句时生成了一个 ReadView。

 之后事务 B 向表中新插入了一条 id = 5 的记录并提交。

 接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id。

 之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。
</code></pre>
<p> 除了上面这一种场景会发生幻读现象之外，还有下面这个场景也会发生幻读现象。</p>
<pre><code> T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。

 T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；
 
 T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。
</code></pre>
<p> 要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-内存</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。</p>
<span id="more"></span>

<h1 id="为什么要有-Buffer-Pool"><a href="#为什么要有-Buffer-Pool" class="headerlink" title="为什么要有 Buffer Pool"></a>为什么要有 Buffer Pool</h1><img src="./缓冲池.webp" width = "50%" height = "50%" alt="缓冲池" align=center />

<p>MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p>
<h2 id="有了缓冲池后："><a href="#有了缓冲池后：" class="headerlink" title="有了缓冲池后："></a>有了缓冲池后：</h2><p>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</p>
<p>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</p>
<h2 id="Buffer-Pool-有多大？"><a href="#Buffer-Pool-有多大？" class="headerlink" title="Buffer Pool 有多大？"></a>Buffer Pool 有多大？</h2><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下Buffer Pool 只有 128MB 。</p>
<p>可以通过调整 innodb_buffer_pool_size 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p>
<h2 id="Buffer-Pool-缓存什么？"><a href="#Buffer-Pool-缓存什么？" class="headerlink" title="Buffer Pool 缓存什么？"></a>Buffer Pool 缓存什么？</h2><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p>
<p>Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p>
<p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。</p>
<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p>
<img src="./bufferpool内容.webp" width = "50%" height = "50%" alt="bufferpool内容" align=center />


<h1 id="如何管理-Buffer-Pool？"><a href="#如何管理-Buffer-Pool？" class="headerlink" title="如何管理 Buffer Pool？"></a>如何管理 Buffer Pool？</h1><h2 id="如何管理空闲页？"><a href="#如何管理空闲页？" class="headerlink" title="如何管理空闲页？"></a>如何管理空闲页？</h2><img src="./freelis.webp" width = "50%" height = "50%" alt="freelis" align=center />
    
<p>Buffer Pool 是一片连续的内存空间，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 Free 链表（空闲链表）。</p>
<h2 id="如何管理脏页？"><a href="#如何管理脏页？" class="headerlink" title="如何管理脏页？"></a>如何管理脏页？</h2><img src="./Flush.webp" width = "50%" height = "50%" alt="Flush" align=center />

<p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为脏页，然后再由后台线程将脏页写入到磁盘。</p>
<p>为了能快速知道哪些缓存页是脏的，于是就设计出 Flush 链表，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p>
<h2 id="如何提高缓存命中率？"><a href="#如何提高缓存命中率？" class="headerlink" title="如何提高缓存命中率？"></a>如何提高缓存命中率？</h2><p>Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。</p>
<p>要实现这个，最容易想到的就是 LRU（Least recently used）算法。</p>
<p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p>
<p>Buffer Pool 里有三种页和链表来管理数据。</p>
<img src="./bufferpoll_page.webp" width = "50%" height = "50%" alt="bufferpoll_page" align=center />

<pre><code>Free Page（空闲页），表示此页未被使用，位于 Free 链表；
Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。
Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。
</code></pre>
<p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：<br>预读失效：</p>
<pre><code>程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。但是可能这些被提前加载进来的数据页，并没有被访问，相当于这个预读是白做了，这个就是预读失效。

解决方法：
    让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长。
</code></pre>
<img src="./young+old.webp" width = "50%" height = "50%" alt="young+old" align=center />

<p>Buffer Pool 污染：</p>
<pre><code>当某一个 SQL 语句扫描了大量的数据时，在 Buffer Pool 空间比较有限的情况下，可能会将 Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 Buffer Pool 污染。

Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。比如索引失效导致的全表扫描。

解决方法：
    像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。

    MySQL 是这样做的，进入到 young 区域条件增加了一个停留在 old 区域的时间判断。
        
    这个间隔时间是由 innodb_old_blocks_time 控制的，默认是 1000 ms。

    也就说，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部，这样就解决了 Buffer Pool 污染的问题 。

    另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。
</code></pre>
<h2 id="脏页什么时候会被刷入磁盘？"><a href="#脏页什么时候会被刷入磁盘？" class="headerlink" title="脏页什么时候会被刷入磁盘？"></a>脏页什么时候会被刷入磁盘？</h2><p>InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p>
<p>下面几种情况会触发脏页的刷新：</p>
<pre><code>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；

Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；

MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；

MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；
</code></pre>
<p>在我们开启了慢 SQL 监控后，如果你发现<strong>「偶尔」会出现一些用时稍长的 SQL</strong>，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p>
<p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
<h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-基础</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>MySQL 执行一条查询&#x2F;更新语句，期间发生了什么？</p>
<span id="more"></span>

<h2 id="MySQL-执行查询流程"><a href="#MySQL-执行查询流程" class="headerlink" title="MySQL 执行查询流程"></a>MySQL 执行查询流程</h2><ol start="0">
<li><p>mysql逻辑架构图</p>
 <!-- <img src="/%E5%AD%98%E5%82%A8/mysql-%E5%9F%BA%E7%A1%80/mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.webp" class="" title="mysql逻辑架构图"> -->
 <img src="./mysql逻辑架构图.webp" width = "50%" height = "50%" alt="update更新流程" align=center />
</li>
<li><p>连接器-建立连接，管理连接、校验用户身份</p>
<ol>
<li>客户端跟服务端建立连接 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</span></span><br><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure></li>
<li>TCP 三次握手；</li>
<li>验证用户名和密码，权限固定在该连接上；</li>
<li>连接后状态 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有后续动作处于空闲状态，即Command列显示sleep</span></span><br><span class="line">show processlist;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 太长没动静，根据参数wait_timeout时间断开链接，默认8小时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立链接比较复杂，尽量使用长连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为执行过程中临时使用的内存是管理在连接对象里面的。所以长连接累积下来，可能导致内存占用太大。被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</span></span><br><span class="line"><span class="comment"># 定期断开长连接或者执行较大操作后通过执行mysql_reset_connection来重新初始化连接资源。</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>查询缓存-查询语句:查询结果</p>
<ol>
<li>mysql拿到一个查询请求后，会先查询缓存看看，key 是查询的语句，value 是查询的结果。</li>
<li>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</li>
<li>缓存“按需使用”的方式。将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样： <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_cache <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
 MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</li>
</ol>
</li>
<li><p>分析器-sql语句词法和语法解析构建语法树</p>
<ol>
<li>SQL语句解析，输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</li>
<li>词法分析。</li>
<li>语法分析。</li>
</ol>
</li>
<li><p>执行器</p>
<ol>
<li>预处理阶段-字段表校验、符号扩展<br> 检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li>
<li>优化器-怎么做<ol>
<li>在表里面有多个索引的时候，决定使用哪个索引；</li>
<li>在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</li>
<li>覆盖索引，不回表，直接在二级索引就能查到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值）。同时查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大（因为主键索引叶子节点存全量数据）。</li>
</ol>
</li>
<li>执行器-具体执行。<ol>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推<ol>
<li>联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配。</li>
<li>将其他条件中的联合索引部分条件在引擎层判断，减少回表后在server层判断的次数。</li>
<li>二级索引在查询时的不进行回表操作，就能提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="MySQL-执行更新流程"><a href="#MySQL-执行更新流程" class="headerlink" title="MySQL 执行更新流程"></a>MySQL 执行更新流程</h2><!-- <img src="/%E5%AD%98%E5%82%A8/mysql-%E5%9F%BA%E7%A1%80/update%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.webp" class="" title="update 更新流程"> -->
<img src="./update更新流程.webp" width = "50%" height = "50%" alt="update更新流程" align=center />


<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><img src="/%E5%AD%98%E5%82%A8/mysql-%E5%9F%BA%E7%A1%80/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png" class="" title="两阶段提交">

<p>InnoDB在写redo log时，并不是一次性写完的，而有两个阶段，Prepare与Commit阶段，这就是”两阶段提交”的含义。</p>
<ol>
<li><p>为什么要写redo log?<br> MySQL为了提升性能，引入了BufferPool缓冲池。查询数据时，先从BufferPool中查询，查询不到则从磁盘加载在BufferPool。</p>
<p> 每次对数据的更新，也不总是实时刷新到磁盘，而是先同步到BufferPool中，涉及到的数据页就会变成脏页。</p>
<p> 同时会启动后台线程，异步地将脏页刷新到磁盘中，来完成BufferPool与磁盘的数据同步。</p>
<p> 如果在某个时间，MySQL突然崩溃，则内存中的BufferPool就会丢失，剩余未同步的数据就会直接消失。</p>
<p> 虽然在更新BufferPool后，也写入了binlog中，但binlog并不具备crash-safe的能力。</p>
<p> 因为崩溃可能发生在写binlog后，刷脏前。在主从同步的情况下，从节点会拿到多出来的一条binlog。</p>
</li>
<li><p>为什么要写两次redo log?<br> 如果只写一次，存在以下两种</p>
<pre><code> 1. 先写binlog，再写redo log
     当前事务提交后，写入binlog成功，之后主节点崩溃。在主节点重启后，由于没有写入redo log，因此不会恢复该条数据。

     而从节点依据binlog在本地回放后，会相对于主节点多出来一条数据，从而产生主从不一致。

 2. 先写redo log，再写binlog
     当前事务提交后，写入redo log成功，之后主节点崩溃。在主节点重启后，主节点利用redo log进行恢复，就会相对于从节点多出来一条数据，造成主从数据不一致。
</code></pre>
<p> 因此，只写一次redo log与binlog，无法保证这两种日志在事务提交后的一致性。</p>
</li>
<li><p>两阶段提交的情况下，如何实现崩溃恢复？<br> 首先比较重要的一点是，在写入redo log时，会顺便记录当前事务id。在写入binlog时，也会写入当前事务id。</p>
<pre><code> 1. 如果在写入redo log之前崩溃，那么此时redo log与binlog中都没有，是一致的情况，崩溃也无所谓。

 2. 如果在写入redo log prepare阶段之后立马崩溃，之后会在崩溃恢复时，由于redo log没有被标记为commit。于是拿 redo log中事务id去bin log中查找，此时肯定找不到，立即执行回滚操作。

 3. 如果在写入bin log后立马崩溃，在恢复时，由redo log中的事务id可以找到对应的bin log，这个时候直接提交即可。
</code></pre>
<p> 总的来说，在崩溃恢复后，只要redo log不是处于commit阶段，那么就拿着redo log中的XID去binlog中寻找，找得到就提交，否则就回滚。</p>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-日志</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>MySQL 日志主要有 binlog（归档日志）、redo log（重做日志）、undo log（回退日志）。</p>
<span id="more"></span>

<h2 id="执行一条-update-语句，期间发生了什么？"><a href="#执行一条-update-语句，期间发生了什么？" class="headerlink" title="执行一条 update 语句，期间发生了什么？"></a>执行一条 update 语句，期间发生了什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE t_user SET name = &#x27;xiaolin&#x27; WHERE id = 1;</span><br></pre></td></tr></table></figure>
<h3 id="client-and-server-服务层操作"><a href="#client-and-server-服务层操作" class="headerlink" title="client and server 服务层操作"></a>client and server 服务层操作</h3><pre><code>1. 客户端先通过连接器建立连接，连接器自会判断用户身份；
2. 因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；
3. 解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；
4. 预处理器会判断表和字段是否存在，将*展开为对应字段列表；
5. 优化器确定执行计划，主要是索引的选择或者连表查询时的选择，这里因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；
6. 执行器负责具体执行，找到这一行，然后更新。
</code></pre>
<h3 id="server-and-InnoDB-引擎层操作"><a href="#server-and-InnoDB-引擎层操作" class="headerlink" title="server and InnoDB 引擎层操作"></a>server and InnoDB 引擎层操作</h3><pre><code>1. 执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：
    1. 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；
    2. 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。
2. 执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：
    1. 如果一样的话就不进行后续更新流程；
    2. 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；
3. 开启事务，InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。
4. InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。
5. 至此，一条记录更新完了。
6. 在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。
7. 事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：
    1. prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；
    2. commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；
</code></pre>
<h2 id="undo-log（回滚日志）、redo-log（重做日志）、binlog（归档日志）"><a href="#undo-log（回滚日志）、redo-log（重做日志）、binlog（归档日志）" class="headerlink" title="undo log（回滚日志）、redo log（重做日志）、binlog（归档日志）"></a>undo log（回滚日志）、redo log（重做日志）、binlog（归档日志）</h2><pre><code>1. undo log（回滚日志）
    是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。
2. redo log（重做日志）
    是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
3. binlog （归档日志）
    是 Server 层生成的日志，主要用于数据备份和主从复制；
</code></pre>
<h2 id="为什么需要-Buffer-Pool？"><a href="#为什么需要-Buffer-Pool？" class="headerlink" title="为什么需要 Buffer Pool？"></a>为什么需要 Buffer Pool？</h2><p>Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能</p>
<pre><code>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。

当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。
</code></pre>
<p>Buffer Pool 缓存什么？</p>
<pre><code>在 MySQL 启动的时候，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。

Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。
</code></pre>
<p>Undo 页是记录什么？</p>
<pre><code>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。
</code></pre>
<p>查询一条记录，就只需要缓冲一条记录吗？</p>
<pre><code>当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。
</code></pre>
<h2 id="为什么需要-undo-log-？"><a href="#为什么需要-undo-log-？" class="headerlink" title="为什么需要 undo log ？"></a>为什么需要 undo log ？</h2><p>undo log（回滚日志） 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。它保证了事务的 ACID 特性 (opens new window)中的原子性（Atomicity）。</p>
<p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：</p>
<pre><code>通过 trx_id 可以知道该记录是被哪个事务修改的；
通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；
</code></pre>
<p>另外，undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）。</p>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同。</p>
<pre><code>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。

「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。
</code></pre>
<p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（trx_id 和 roll_pointer）」的比对，如果不满足可见行，就会顺着 undo log 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p>
<p>因此，undo log 两大作用：</p>
<pre><code>实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。

实现 MVCC（多版本并发控制）关键因素之一。MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。
</code></pre>
<p>undo log 是如何刷盘（持久化到磁盘）的？</p>
<pre><code>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。

buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。
</code></pre>
<h2 id="为什么需要-redo-log-？"><a href="#为什么需要-redo-log-？" class="headerlink" title="为什么需要 redo log ？"></a>为什么需要 redo log ？</h2><p>Buffer Pool 是基于内存的，是提高了读写效率没错，但是内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL （Write-Ahead Logging）技术。</p>
<p>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</p>
<img src="./wal.webp" width = "50%" height = "50%" alt="wal" align=center />

<p>什么是 redo log？</p>
<pre><code>redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志。

在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。

当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。
</code></pre>
<p>被修改 Undo 页面，需要记录对应 redo log 吗？</p>
<pre><code>需要的。开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。不过，在内存修改该 Undo 页面后，需要记录对应的 redo log。
</code></pre>
<p>redo log 和 undo log 区别在哪？</p>
<pre><code>undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；

redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；

事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图：
</code></pre>
<img src="./事务恢复.webp" width = "50%" height = "50%" alt="事务恢复" align=center />

<p>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 crash-safe（崩溃恢复）。可以看出来， redo log 保证了事务四大特性中的持久性。</p>
<p>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</p>
<pre><code>写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。

磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。
</code></pre>
<p>至此， 针对为什么需要 redo log 这个问题我们有两个答案：</p>
<pre><code>实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；

将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能。
</code></pre>
<p>产生的 redo log 是直接写入磁盘的吗？</p>
<pre><code>不是的。

实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。

所以，redo log 也有自己的缓存—— redo log buffer，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图
</code></pre>
<p>redo log 什么时候刷盘？<br>缓存在 redo log buffer 里的 redo log 还是在内存中，它什么时候刷新到磁盘？</p>
<p>主要有下面几个时机：</p>
<pre><code>1. MySQL 正常关闭时；
2. 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；
3. InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。
4. 每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 innodb_flush_log_at_trx_commit 参数控制，下面会说）。
</code></pre>
<p>加入了后台现线程后，innodb_flush_log_at_trx_commit 的刷盘时机如下图：<br><img src="./innodb_flush_log_at_trx_commit.webp" width = "50%" height = "50%" alt="innodb_flush_log_at_trx_commit" align=center /></p>
<p>redo log 文件写满了怎么办？</p>
<pre><code>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：ib_logfile0 和 ib_logfile1 。

在重做日志组中，每个 redo log File 的大小是固定且一致的，假设每个 redo log File 设置的上限是 1 GB，那么总共就可以记录 2GB 的操作。

重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。

redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置，如下图：
</code></pre>
<img src="./checkpoint.webp" width = "50%" height = "50%" alt="checkpoint" align=center />

<pre><code>如果 write pos 追上了 checkpoint，就意味着 redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞（因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要），此时会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针），然后 MySQL 恢复正常运行，继续执行新的更新操作。
</code></pre>
<h2 id="为什么需要binlog"><a href="#为什么需要binlog" class="headerlink" title="为什么需要binlog"></a>为什么需要binlog</h2><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p>
<p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<p>为什么有了 binlog， 还要有 redo log？</p>
<pre><code>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。

而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。
</code></pre>
<p>redo log 和 binlog 有什么区别？</p>
<pre><code>1、适用对象不同：
    binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；
    redo log 是 Innodb 存储引擎实现的日志；
2、文件格式不同：
    binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：
        STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；
        ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；
        MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；
    redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；
3、写入方式不同：
    binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。
    redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。
4、用途不同：
    binlog 用于备份恢复、主从复制；
    redo log 用于掉电等故障恢复。
</code></pre>
<p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p>
<pre><code>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。

因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。

binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。
</code></pre>
<p>主从复制是怎么实现？</p>
<pre><code>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。
</code></pre>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<pre><code>写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。
同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。
回放 Binlog：回放 binlog，并更新存储引擎中的数据。
</code></pre>
<p>从库是不是越多越好？</p>
<pre><code>不是的。

因为从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。
</code></pre>
<p>MySQL 主从复制还有哪些模型？</p>
<pre><code>同步复制：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。

异步复制（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。

半同步复制：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。
</code></pre>
<p>binlog 什么时候刷盘？</p>
<pre><code>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。

在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。
</code></pre>
<img src="./binlogcache.webp" width = "50%" height = "50%" alt="binlogcache" align=center />

<p>虽然每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件：</p>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<pre><code>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；
sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；
sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。
</code></pre>
<p>在MySQL中系统默认的设置是 sync_binlog &#x3D; 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p>
<h2 id="为什么需要两阶段提交？"><a href="#为什么需要两阶段提交？" class="headerlink" title="为什么需要两阶段提交？"></a>为什么需要两阶段提交？</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p>
<p>在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。</p>
<p>这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p>
<p>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p>
<p>两阶段提交的过程是怎样的？</p>
<pre><code>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了内部 XA 事务（是的，也有外部 XA 事务，跟本文不太相关，我就不介绍了），内部 XA 事务由 binlog 作为协调者，存储引擎是参与者。
</code></pre>
<img src="./两阶段提交.webp" width = "50%" height = "50%" alt="两阶段提交" align=center />
    
<pre><code>prepare 阶段：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；

commit 阶段：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；
</code></pre>
<p>所以说，两阶段提交是以 binlog 写成功为事务提交成功的标识，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p>
<p>事务没提交的时候，redo log 会被持久化到磁盘吗？</p>
<pre><code>会的。

事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。

也就是说，事务没提交的时候，redo log 也是可能被持久化到磁盘的。
</code></pre>
<p>如果 mysql 崩溃了，还没提交事务的 redo log 已经被持久化磁盘了，mysql 重启后，数据不就不一致了？</p>
<pre><code>放心，这种情况 mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。

所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。
</code></pre>
<p>两阶段提交有什么问题？</p>
<pre><code>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：

磁盘 I/O 次数高：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。

锁竞争激烈：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。

MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数
</code></pre>
<h2 id="MySQL-磁盘-I-x2F-O-很高，有什么优化的方法？"><a href="#MySQL-磁盘-I-x2F-O-很高，有什么优化的方法？" class="headerlink" title="MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？"></a>MySQL 磁盘 I&#x2F;O 很高，有什么优化的方法？</h2><p>我们可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I&#x2F;O 的频率：</p>
<pre><code>设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。

将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。

将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。
</code></pre>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-索引</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p>
<span id="more"></span>

<h2 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h2><p>帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ol>
<li>数据结构：B+tree索引、hash索引、Full-text索引</li>
<li>物理存储：聚簇索引（主键索引）、非聚簇索引（二级索引、辅助索引）</li>
<li>字段特性：主键索引、唯一索引、普通索引、前缀索引</li>
<li>字段个数：单列索引、联合索引</li>
</ol>
<h2 id="InnoDB存储引擎索引选择"><a href="#InnoDB存储引擎索引选择" class="headerlink" title="InnoDB存储引擎索引选择"></a>InnoDB存储引擎索引选择</h2><ol>
<li>默认使用主键作为聚簇索引的索引建；</li>
<li>没有主键使用第一个不包含NULL值得唯一列作为聚簇索引的索引键；</li>
<li>都没有情况下，默认生成隐式自助id列作为聚簇索引的索引建；</li>
</ol>
<h2 id="B-tree索引"><a href="#B-tree索引" class="headerlink" title="B+tree索引"></a>B+tree索引</h2><ol>
<li><p>B+tree索引结构（图中叶子节点需改为双向列表）</p>
 <img src="./B+tree.webp" width = "50%" height = "50%" alt="B+tree" align=center />
 
<ol>
<li>多叉树，叶子节点才存放数据，非叶子节点只存放索引，每个节点里的数据是按主键顺序存放的。</li>
<li>叶子节点中包括了所有的索引值信息，有两个指针，分别指向下一个叶子节点和上一个叶子节点，双向链表。</li>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据，二级索引的 B+Tree 的叶子节点存放的是主键值。</li>
<li>在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。</li>
</ol>
</li>
<li><p>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</p>
<ol>
<li><p>B+Tree vs B Tree<br> B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</p>
<p> 另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。B树则需要通过中序遍历才能完成查询范围的查找。</p>
</li>
<li><p>B+Tree vs 二叉树<br> 对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。</p>
<p> 在实际的应用当中， d 值是大于100的，这样就保证了即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I&#x2F;O 操作就能查询到目标数据。</p>
<p> 而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I&#x2F;O 次数要更多。</p>
</li>
<li><p>B+Tree vs Hash<br> Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p>
<p> 但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p>
</li>
</ol>
</li>
<li><p>联合索引的最左匹配原则<br> 按照最左优先的方式进行索引的匹配<br><br> 在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。<br><br> 1. a &gt; 1 and b &gt; 2，从 a &gt; 1 开始扫描<br> 2. a &gt;&#x3D; 1 and b &#x3D; 2，从 a &#x3D; 1 and b &#x3D; 2 开始扫描<br> 3. a between 2 and 8 and b &#x3D; 2，从 a &#x3D; 2 and b &#x3D; 2 开始扫描<br> 4. name like ‘j%’ and age &#x3D; 22，从 name &#x3D; ‘j’ and age &#x3D; 22 开始扫描</p>
</li>
<li><p>索引下推<br> 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
</li>
<li><p>索引是否需要创建</p>
<ol>
<li>需要<ol>
<li>字段有唯一性限制</li>
<li>经常用于where&#x2F;group&#x2F;order by的字段</li>
</ol>
</li>
<li>不需要<ol>
<li>区分度底，某个值出现率超过30%优化器会忽略索引使用全表扫描</li>
<li>不经常用于where&#x2F;group&#x2F;order by的字段</li>
<li>表数据太少</li>
<li>经常更新的字段</li>
</ol>
</li>
</ol>
</li>
<li><p>索引优化</p>
<ol>
<li>前缀索引优化，减少索引字段大小，增加索引页中存储的索引值</li>
<li>覆盖索引优化，查询的字段在二级索引的叶子节点都能找到，减少回表操作</li>
<li>主键索引最好是自增的，插入是追加操作，不需要重新移动数据。否则需要移动数据，会造成页分裂，还会造成大量内存碎片</li>
<li>索引最好设置NOT NULL，统计复杂且占用物理空间</li>
</ol>
</li>
<li><p>索引失效情况</p>
<ol>
<li>左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；(例外情况，查询的字段在二级索引叶子节点（主键+二级索引字段）都能找到，直接全扫描二级索引树)</li>
<li>查询条件中对索引列做了计算、函数、类型转换操作；</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效；</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ol>
</li>
<li><p>explain 查看查询计划</p>
<ol start="0">
<li><p>explain 结果结构</p>
 <img src="./explain结果结构.webp" width = "50%" height = "50%" alt="explain结果结构" align=center />
</li>
<li><p>参数说明<br> a. possible_keys 字段表示可能用到的索引；<br> b. key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；<br> c. key_len 表示索引的长度；<br> d. rows 表示扫描的数据行数。<br> e. type 表示数据扫描类型，我们需要重点看这个。<br> f. extra 额外说明</p>
</li>
<li><p>type 字段参数说明<br> a. All（全表扫描）；<br> b. index（全索引扫描）；<br> c. range（索引范围扫描）；<br> d. ref（非唯一索引扫描）；<br> e. eq_ref（唯一索引扫描）；eq_ref 通常用于多表联查中；<br> f. const（结果只有一条的主键或唯一索引扫描）。const 是与常量进行比较，查询效率会更快；</p>
</li>
</ol>
</li>
</ol>
<h2 id="数据页角度看B-树"><a href="#数据页角度看B-树" class="headerlink" title="数据页角度看B+树"></a>数据页角度看B+树</h2><ol>
<li><p>InnDB 如何存储数据</p>
 <img src="./数据页.webp" width = "50%" height = "50%" alt="数据页" align=center/>

<ol>
<li>InnoDB 的数据是按「数据页」为单位来读写的</li>
<li>InnoDB 数据页的默认大小是 16KB</li>
<li>数据页中的记录按照「主键」顺序组成单向链表，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索</li>
<li>因此，数据页中有一个页目录，起到记录的索引作用</li>
<li>页目录就是由多个槽组成的<br> 槽相当于分组记录的索引，即每组最后一条记录的地址偏移量。我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</li>
<li>槽内的记录数量规定<ol>
<li>第一个分组中的记录只能有 1 条记录；</li>
<li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li>
<li>剩下的分组中记录条数范围只能在 4-8 条之间。</li>
</ol>
</li>
</ol>
</li>
<li><p>B+树如何查询数据</p>
 <img src="./B+树.webp" width = "50%" height = "50%" alt="B+树" align=center/>

<ol>
<li><p>磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要，“矮胖”的B+树数据结构所需要进行的磁盘 I&#x2F;O 次数更少，而且 B+ 树更适合进行关键字的范围查询。</p>
</li>
<li><p>B+树特点</p>
<ol>
<li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ol>
</li>
<li><p>聚簇索引和二级索引<br> 因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p>
<p> 如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</p>
</li>
</ol>
</li>
</ol>
<h2 id="为什么-MySQL-采用-B-树作为索引？"><a href="#为什么-MySQL-采用-B-树作为索引？" class="headerlink" title="为什么 MySQL 采用 B+ 树作为索引？"></a>为什么 MySQL 采用 B+ 树作为索引？</h2><p>不单单要从数据结构的角度出发，还要考虑磁盘 I&#x2F;O 操作次数，因为 MySQL 的数据是存储在磁盘中的嘛。</p>
<p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I&#x2F;O，而磁盘 I&#x2F;O 次数越多，所消耗的时间也就越大。</p>
<ol>
<li><p>怎样的索引数据结构是好的<br> MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。</p>
<p> 磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I&#x2F;O 操作会直接读写 8 个扇区。</p>
<p> 由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I&#x2F;O，而磁盘 I&#x2F;O 次数越多，所消耗的时间也就越大。</p>
<p> 所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<pre><code> 1. 能在尽可能少的磁盘的 I/O 操作中完成查询工作；
 2. 要能高效地查询某一个记录，也要能高效地执行范围查找；
</code></pre>
</li>
<li><p>B+ 作为索引的数据结构原因</p>
<ol>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li>
<li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li>
</ol>
</li>
</ol>
<h2 id="MySQL-单表不要超过-2000W-行？"><a href="#MySQL-单表不要超过-2000W-行？" class="headerlink" title="MySQL 单表不要超过 2000W 行？"></a>MySQL 单表不要超过 2000W 行？</h2><ol>
<li><p>假设</p>
<ol>
<li><p>非叶子节点内指向其他页的数量为 x<br> 索引页记录 x &#x3D; (16KB - 1KB) * 1024KB &#x2F; (8B + 4B) ~ 1280 行<br> 索引页记录 x &#x3D; (页大小 - 页头、页号、目录等) * 1024 B &#x2F; (索引行数据&#x3D;索引 + 页号)</p>
</li>
<li><p>叶子节点内能容纳的数据行数为 y<br> 数据页记录 y &#x3D; (16KB - 1KB) * 1KB &#x2F; 1KB ~ 15<br> 数据页记录 y &#x3D; (页大小 - 页头、页号、目录等) * 1024 B &#x2F; (行数据假设1KB)</p>
</li>
<li><p>B+ 数的层数为 z</p>
</li>
<li><p>总记录数 &#x3D; Total &#x3D; x^(z-1) * y</p>
</li>
<li><p>假设 B+ 树是两层<br> z &#x3D; 2， Total &#x3D; （1280 ^1 ）* 15 &#x3D; 19200</p>
</li>
<li><p>假设 B+ 树是三层<br> z &#x3D; 3， Total &#x3D; （1280 ^2） * 15 &#x3D; 24576000 （约 2.45kw）</p>
</li>
<li><p>这正好就是文章开头说的最大行数建议值 2000W。对的，一般 B+ 数的层级最多也就是 3 层。</p>
</li>
</ol>
</li>
<li><p>单行数据变多情况下，建议值减少<br> 我们刚刚在说 Y 的值时候假设的是 1K ，那比如我实际当行的数据占用空间不是 1K , 而是 5K, 那么单个数据页最多只能放下 3 条数据。</p>
<p> 同样，还是按照 z &#x3D; 3 的值来计算，那 Total &#x3D; （1280 ^2） *3 &#x3D; 4915200 （近 500w）</p>
<p> 所以，在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的，而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。</p>
<p> MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。</p>
<p> 但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。</p>
</li>
<li><p>总结</p>
<ol>
<li>MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。</li>
<li>页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。</li>
<li>在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</li>
<li>索引结构不会影响单表最大行数，2000W 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。更多的与单记录数据大小有关，数据越大，页节点越多，整个树层级就会越高。</li>
</ol>
</li>
</ol>
<h2 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h2><ol>
<li><p>对索引使用左或者左右模糊匹配<br> 使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 都会造成索引失效。</p>
<p> 因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</p>
</li>
<li><p>对索引使用函数<br> 如果查询条件中对索引字段使用函数，就会导致索引失效。</p>
<p> 因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p> 从 MySQL 8.0 开始，索引特性增加了函数索引</p>
</li>
<li><p>对索引进行表达式计算<br> 失效： where id + 1 &#x3D; 10;<br> 不失效：where id &#x3D; 10 - 1; </p>
</li>
<li><p>对索引隐式类型转换<br> 失效： phone &#x3D; 1300000001; where CAST(phone AS signed int) &#x3D; 1300000001;<br> 不失效： id &#x3D; ‘1’; where id &#x3D; CAST(“1” AS signed int);</p>
<p> 通过 select “10” &gt; 9 的结果来知道MySQL 的数据类型转换规则是什么：</p>
<p> 自动「字符串」转换成「数字」，就相当于 select 10 &gt; 9，这个就是数字比较，所以结果应该是 1；</p>
<p> 自动「数字」转换成「字符串」，就相当于 select “10” &gt; “9”，所以结果应该是 0。</p>
<p> 说明 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。</p>
</li>
<li><p>联合索引非最左匹配<br> 创建了一个 (a, b, c) 联合索引</p>
<ol>
<li><p>有效（顺序无关，优化器调整）</p>
<ol>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ol>
</li>
<li><p>无效</p>
<ol>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ol>
</li>
<li><p>截断<br> where a &#x3D; 1 and c &#x3D; 3</p>
<p> 只使用前面 a 会走索引</p>
<p> mysql5.5在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</p>
<p> 从 MySQL 5.6 之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p>
</li>
<li><p>为什么联合索引不遵循最左匹配原则就会失效？<br> 原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p>
</li>
<li><p>WHERE 子句中的 OR<br> 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
</li>
</ol>
</li>
</ol>
<h2 id="MySQL-使用-like-“-x“，索引一定会失效吗？"><a href="#MySQL-使用-like-“-x“，索引一定会失效吗？" class="headerlink" title="MySQL 使用 like “%x“，索引一定会失效吗？"></a>MySQL 使用 like “%x“，索引一定会失效吗？</h2><p>不一定，关键看数据表中的字段。如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type&#x3D;all），而是走全扫描二级索引树(type&#x3D;index)。</p>
<p>只不过没利用索引树的有序性的特点，没有通过查询比较的方式，快速定位到了数据行。</p>
<h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><ol>
<li><p>结论</p>
 <img src="./count比较.webp" width = "50%" height = "50%" alt="count比较" align=center/>
</li>
<li><p>count()是什么<br> 统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。</p>
</li>
<li><p>分析</p>
<ol>
<li><p>表里只有主键索引</p>
<ol>
<li>count(字段)：遍历主键索引，判断字段 !&#x3D; NULL，count++</li>
<li>count(主键字段): 遍历主键索引，判断主键字段 !&#x3D; NULL，count++</li>
<li>count(1): 遍历主键索引, count++</li>
<li>count(*) &#x3D;&#x3D; count(0): 遍历主键索引, count++</li>
</ol>
</li>
<li><p>表里有二级索引</p>
<ol>
<li>count(字段)：遍历主键索引，判断字段 !&#x3D; NULL，count++</li>
<li>count(主键字段): 遍历二级索引，判断主键字段 !&#x3D; NULL，count++</li>
<li>count(1): 遍历二级索引，count++</li>
<li>count(*) &#x3D;&#x3D; count(0): 遍历二级索引，count++</li>
</ol>
</li>
</ol>
</li>
<li><p>小结<br> 所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
</li>
<li><p>为什么要通过遍历的方式来计数？</p>
<ol>
<li><p>使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息有存储了row_count值，由表级锁保证一致性。</p>
</li>
<li><p>InnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。</p>
</li>
<li><p>当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行记录个数的统计。</p>
</li>
</ol>
</li>
<li><p>如何优化 count(*)？<br> 如果对一张大表经常用 count(*) 来做统计，其实是很不好的。</p>
<ol>
<li><p>第一种，近似值<br> 可以使用 show table status 或者 explain 命令来表进行估算。执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是 explain 命令对表 t_order 记录的估算值。</p>
</li>
<li><p>第二种，额外表保存计数值<br> 如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p>
<p> 当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p>
</li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-锁</title>
    <url>/%E5%AD%98%E5%82%A8/mysql-%E9%94%81/</url>
    <content><![CDATA[<p>MySQL 根据加锁的范围，可以分为全局锁、表级锁和行锁三类。</p>
<span id="more"></span>

<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ol>
<li><p>加解全局锁</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加只读锁</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock</span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables</span><br><span class="line"><span class="comment">-- 断开会话</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局锁应用场景<br> 全局锁主要应用于全库逻辑备份，这样在备份期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
</li>
<li><p>全局锁缺点<br> 如果数据库大，那么备份就会很耗时，那么备份期间业务只能读取数据，而不能进行更新数据，会造成业务停滞。</p>
</li>
<li><p>避免方式<br> 如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
<p> 备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p> 但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
</li>
</ol>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ol>
<li><p>分类</p>
<ol>
<li>表锁</li>
<li>元数据锁</li>
<li>意向锁</li>
<li>AUTO-INC 锁</li>
</ol>
</li>
<li><p>表锁</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表级别共享锁，即读锁</span></span><br><span class="line">lock tables 表名 read</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级别独占锁，即写锁</span></span><br><span class="line">lock tables 表名 write</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">unlock tables</span><br><span class="line"><span class="comment">-- 断开会话</span></span><br></pre></td></tr></table></figure>

<p> 需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p> 不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。</p>
</li>
<li><p>元数据锁<br> 我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<pre><code> 1. 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
 2. 对一张表做结构变更操作的时候，加的是 MDL 写锁；
</code></pre>
<p> MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。</p>
<p> 那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<pre><code> 1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
 2. 然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
 3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞
</code></pre>
<p> 那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<p> 所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
</li>
<li><p>意向锁<br> 意向锁的目的是为了快速判断表里是否有记录被加锁。</p>
<p> 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</p>
<p> 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</p>
<p> 也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p> 而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p> 如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢</p>
</li>
<li><p>AUTO-INC 锁<br> 表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。</p>
<p> 之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的</p>
<p> AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。</p>
<p> 但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p> 因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。</p>
<p> 一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</p>
<p> InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<pre><code> 1. 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
 2. 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
 3. 当 innodb_autoinc_lock_mode = 1：
     1. 普通 insert 语句，自增锁在申请之后就马上释放；
     2. 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；
</code></pre>
<p> 当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题。</p>
<p> 这时可能存在主库两个事务随机插入，而从库是bin log原始语句顺序执行，相对有序。就会造成主从不一致情况。</p>
<p> 要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p>
<p> 所以，当 innodb_autoinc_lock_mode &#x3D; 2 时，并且 binlog_format &#x3D; row，既能提升并发性，又不会出现数据一致性问题。</p>
</li>
</ol>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ol>
<li>分类<ol>
<li><p>Record Lock，记录锁，也就是仅仅把一条记录锁上；</p>
</li>
<li><p>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</p>
</li>
<li><p>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
</li>
<li><p>插入意向锁<br> 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p>
<p> 如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p> 插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。</p>
<p> 如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
</li>
</ol>
</li>
</ol>
<h2 id="MySQL-是怎么加锁的？"><a href="#MySQL-是怎么加锁的？" class="headerlink" title="MySQL 是怎么加锁的？"></a>MySQL 是怎么加锁的？</h2><ol>
<li>什么 SQL 语句会加行级锁？<br> 如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对读取的记录加共享锁(S型锁)</span></span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对读取的记录加独占锁(X型锁)</span></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

 除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。</li>
</ol>
<h2 id="update-没加索引会锁全表？"><a href="#update-没加索引会锁全表？" class="headerlink" title="update 没加索引会锁全表？"></a>update 没加索引会锁全表？</h2><ol>
<li><p>原因<br> InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。</p>
<p> 因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。</p>
<p> 当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。</p>
<p> 在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。</p>
<p> 比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁</p>
<p> 但是，在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。</p>
</li>
<li><p>如何避免这种事故的发生？<br> 我们可以将 MySQL 里的 sql_safe_updates 参数设置为 1，开启安全更新模式。<br> update 语句必须满足如下条件之一才能执行成功：</p>
<pre><code> 使用 where，并且 where 条件中必须有索引列；
 使用 limit；
 同时使用 where 和 limit，此时 where 条件中可以没有索引列；
</code></pre>
<p> delete 语句必须满足以下条件能执行成功：</p>
<pre><code> 同时使用 where 和 limit，此时 where 条件中可以没有索引列；
</code></pre>
<p> 如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 force index([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</p>
</li>
</ol>
<h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h2><p>在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。</p>
<p>有一点要注意的是，在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。</p>
<h2 id="MySQL-死锁了，怎么办？"><a href="#MySQL-死锁了，怎么办？" class="headerlink" title="MySQL 死锁了，怎么办？"></a>MySQL 死锁了，怎么办？</h2><ol>
<li><p>死锁产生<br> 两个不同事务，获取包含相同区间的 next-key 锁，却又在插入或者修改或者删除该区间记录时，被对方的 next-key 锁阻塞，从而导致死锁</p>
<p> 案例中的事务 A 和事务 B 在执行完后 select … for update 语句后都持有范围为(1006,+∞]的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。</p>
<p> 间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。</p>
</li>
<li><p>如何避免死锁？<br> 死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p>
<p> 设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。</p>
<p> 开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。</p>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/%E5%AD%98%E5%82%A8/mysql/</url>
    <content><![CDATA[<p>MySQL是目前应用最广泛的开源关系数据库。</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="centos7-安装MySQL"><a href="#centos7-安装MySQL" class="headerlink" title="centos7 安装MySQL"></a>centos7 安装MySQL</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 检查mariadb --&gt;</span><br><span class="line">rpm -qa|grep mariadb</span><br><span class="line">&lt;!-- 如有则按如下删除 --&gt;</span><br><span class="line">rpm -e --nodeps mariadb-server</span><br><span class="line">rpm -e --nodeps mariadb</span><br><span class="line">rpm -e --nodeps mariadb-libs</span><br><span class="line">&lt;!-- 检查mysql --&gt;</span><br><span class="line">rpm -qa|grep mysql</span><br><span class="line">&lt;!-- 存在则按如下删除 --&gt;</span><br><span class="line">rpm -e --nodeps 【xxx】</span><br><span class="line">&lt;!-- mysql yum源下载官网地址 --&gt;</span><br><span class="line">https://dev.mysql.com/downloads/repo/yum/</span><br><span class="line">&lt;!-- 根据自己系统版本选择 --&gt;</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">&lt;!-- centos7 选择如下 --&gt;</span><br><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el7-7.noarch.rpm</span><br><span class="line">&lt;!-- 安装mysql源 --&gt;</span><br><span class="line">rpm -Uvh mysql80-community-release-el7-7.noarch.rpm</span><br><span class="line">&lt;!-- 检查是否安装成功，是否有mysql-community.repo及 mysql-community-source.repo --&gt;</span><br><span class="line">ll /etc/yum.repos.d/</span><br><span class="line">&lt;!-- 查看源中的mysql版本 --&gt;</span><br><span class="line">yum repolist all | grep mysql</span><br><span class="line">&lt;!-- 切换mysql版本 --&gt;</span><br><span class="line">yum-config-manager --disable mysql80-community</span><br><span class="line">yum-config-manager --enable mysql57-community</span><br><span class="line">&lt;!-- 检查当前启用的mysql仓库 --&gt;</span><br><span class="line">yum repolist enabled | grep mysql</span><br><span class="line">&lt;!-- 安装mysql --&gt;</span><br><span class="line">sudo yum -y install mysql-community-server</span><br><span class="line">&lt;!-- 会安装如下 --&gt;</span><br><span class="line">mysql-community-server</span><br><span class="line">mysql-community-client</span><br><span class="line">mysql-community-common</span><br><span class="line">mysql-community-libs</span><br><span class="line">numactl-libs</span><br><span class="line">&lt;!-- 启动mysql --&gt;</span><br><span class="line">sydo systemctl start mysqld.service</span><br><span class="line">&lt;!-- 查看状态 --&gt;</span><br><span class="line">sudo systemctl status mysqld.service</span><br><span class="line">&lt;!-- 停止mysql --&gt;</span><br><span class="line">sudo systemctl stop mysqld.service</span><br><span class="line">&lt;!-- 重启mysql --&gt;</span><br><span class="line">sudo systemctl restart mysqld.service</span><br><span class="line">&lt;!-- 初始密码，MySQL第一次启动后会创建超级管理员账号root@localhost，初始密码存储在日志文件中 --&gt;</span><br><span class="line">sudo grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br><span class="line">&lt;!-- 修改密码 --&gt;</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;jesonlin&#x27;;</span><br><span class="line">&lt;!-- 关闭验证密码复杂度策略 --&gt;</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">&lt;!-- 添加如下并重启 --&gt;</span><br><span class="line">validate_password=OFF</span><br><span class="line">&lt;!-- 运行远程访问 --&gt;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;jesonlin&#x27; WITH GRANT OPTION;</span><br><span class="line">&lt;!-- 查看并修改字符集 --&gt;</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-client-handshake=FALSE</span><br><span class="line">character_set_server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_unicode_ci</span><br><span class="line">init-connect=&#x27;SET NAMES utf8mb4&#x27;</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">&lt;!-- 重启并检查设置效果 --&gt;</span><br><span class="line">SHOW VARIABLES WHERE Variable_name LIKE &#x27;character_set_%&#x27; OR Variable_name LIKE &#x27;collation%&#x27;;</span><br><span class="line">&lt;!-- 设置开机启动 --&gt;</span><br><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="centos8安装mysql"><a href="#centos8安装mysql" class="headerlink" title="centos8安装mysql"></a>centos8安装mysql</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 前面下载yum源步骤同上，官方源里只有mysql8版本，需要手动修改源 --&gt;</span><br><span class="line">&lt;!-- 修改mysql-community.repo --&gt;</span><br><span class="line">vim /etc/yum.repos.d/mysql-community.repo</span><br><span class="line">&lt;!-- 添加如下 --&gt;</span><br><span class="line">[mysql57-community]</span><br><span class="line">name=MySQL 5.7 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br><span class="line">&lt;!-- 禁止mysql8 --&gt;</span><br><span class="line">yum-config-manager --disable mysql80-community</span><br><span class="line">&lt;!-- 核对输出 --&gt;</span><br><span class="line">yum repolist enabled | grep mysql</span><br><span class="line">&lt;!-- 失能模块 --&gt;</span><br><span class="line">yum module disable mysql</span><br><span class="line">&lt;!-- 安装 --&gt;</span><br><span class="line">yum install mysql-community-server</span><br><span class="line">&lt;!-- 启动mysql --&gt;</span><br><span class="line">systemctl start mysqld.service</span><br><span class="line">&lt;!-- 其他步骤同上 --&gt;</span><br><span class="line">&lt;!-- 修改密码有报错执行下面 --&gt;</span><br><span class="line">flush privileges;</span><br><span class="line">&lt;!-- 重启失败，发现不能添加如下语句 --&gt;</span><br><span class="line">validate_password=OFF</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="docker-安装启动mysql5-7"><a href="#docker-安装启动mysql5-7" class="headerlink" title="docker 安装启动mysql5.7"></a>docker 安装启动mysql5.7</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line">docker run -p 3307:3306 --name mysql -v /data/service/docker/mysql/logs:/var/log/mysql -v /data/service/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=jesonlin -d mysql:5.7</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="跳过密码登录数据库"><a href="#跳过密码登录数据库" class="headerlink" title="跳过密码登录数据库"></a>跳过密码登录数据库</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 设置MYSQLD_OPTS --&gt;</span><br><span class="line">systemctl set-environment MYSQLD_OPTS=&quot;--skip-grant-tables&quot;;</span><br><span class="line">&lt;!-- 显示mysql环境变量 --&gt;</span><br><span class="line">systemctl show-environment</span><br><span class="line">&lt;!-- 撤销mysql环境变量 --&gt;</span><br><span class="line">systemctl unset-environment MYSQLD_OPTS;</span><br><span class="line">&lt;!-- 重启，脚本里有用到该参数  --&gt;</span><br><span class="line">systemctl restart mysqld.service </span><br></pre></td></tr></table></figure>
</code></pre>
<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><ol>
<li>创建用户 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;[用户名]&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;[密码]&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>授予权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    GRANT ALL PRIVILEGES ON `[DB]`.* TO &#x27;[用户名]&#x27;@&#x27;[host]&#x27;;</span><br><span class="line">    ```  </span><br><span class="line">3. 删除用户</span><br></pre></td></tr></table></figure>
 drop user [用户名]@’%’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 删除权限</span><br></pre></td></tr></table></figure>
 revoke all on [DB].* from ‘[用户名]‘@’[host]’;<br> Delete from mysql.user where user &#x3D; ‘[用户名]’ and host &#x3D; ‘[host]’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 改密码</span><br></pre></td></tr></table></figure>
 mysqladmin -uroot -p[旧密码] password [新密码]<br> set password for [用户名]@[host] &#x3D; password([新密码]);<br> update mysql.user set authentication_string&#x3D;password(‘新密码’) where user&#x3D;’用户名’ and Host &#x3D;’localhost’;<br> flush privileges; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 库表操作</span><br><span class="line">0. 启动、重启、停止</span><br></pre></td></tr></table></figure>
 systemctl start&#x2F;restart&#x2F;stop mysqld.service <!-- 查看启动状态 -->
 systemctl status mysqld.service <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建数据库</span><br></pre></td></tr></table></figure>
 create database [DB] if not exists [DB] default charset utf8mb4 collate utf8mb4_unicode_ci; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 创建数据表</span><br></pre></td></tr></table></figure>
 CREATE TABLE <code>[表名]</code> (<br>   <code>id</code> int(11) NOT NULL AUTO_INCREMENT COMMENT ‘自增ID’,<br>   <code>name</code> varchar(32) NOT NULL COMMENT ‘名称’,<br>   <code>comment</code> varchar(255) NOT NULL COMMENT ‘备注’,<br>   <code>create_time</code> datetime DEFAULT CURRENT_TIMESTAMP COMMENT ‘创建时间’,<br>   <code>update_time</code> datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘更新时间’,<br>   PRIMARY KEY (<code>id</code>),<br>   KEY <code>idx_name</code> (<code>name</code>),<br> ) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;0 DEFAULT CHARSET&#x3D;utf8mb4 COMMENT &#x3D; ‘业务信息’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 插入数据</span><br></pre></td></tr></table></figure>
 insert into [表名] (id, name, comment) values (null, ‘’, ‘’); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 拷贝表结构</span><br></pre></td></tr></table></figure>
 create table [新表名] like [旧表名] <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 拷贝数据</span><br></pre></td></tr></table></figure>
 insert into [新表名] select * from [旧表名] <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6. 导入导出数据库</span><br></pre></td></tr></table></figure>
 mysqldump -h[IP] –set-gtid-purged&#x3D;off -uroot -p[PASSWORD] –databases [DB] &gt; [DB].sql<br> mysql -h[IP] -uroot -p[PASSWORD] &lt; [DB].sql <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. 数据库大小</span><br></pre></td></tr></table></figure>
 select (sum(DATA_LENGTH)+sum(INDEX_LENGTH))&#x2F;1024&#x2F;1024&#x2F;1024 from information_schema.TABLES where TABLE_SCHEMA&#x3D;’[DB]’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8. 数据库每个表大小</span><br></pre></td></tr></table></figure>
 SELECT TABLE_NAME, DATA_LENGTH&#x2F;1024&#x2F;1024&#x2F;1024, INDEX_LENGTH&#x2F;1024&#x2F;1024&#x2F;1024 FROM information_schema.TABLES WHERE TABLE_SCHEMA&#x3D;’[DB]’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9. 数据表大小</span><br></pre></td></tr></table></figure>
 SELECT count(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA&#x3D;’[DB]’; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10. 查询表创建和更新时间</span><br></pre></td></tr></table></figure>
 select * from information_schema.tables where information_schema.tables.TABLE_SCHEMA&#x3D;’[DB]’ and information_schema.tables.TABLE_NAME&#x3D;’[TB]’\G; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11. 添加表字段</span><br></pre></td></tr></table></figure>
 alter table [TB] add [FIELD] int(11) unsigned default 0 comment “id”; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12. 到出到本地csv</span><br></pre></td></tr></table></figure>
 mysql –host&#x3D;[HOST] –user&#x3D;[USER] –password&#x3D;[PASSWORD] -se “SELECT * FROM [DB].[TB]” | sed ‘s&#x2F;\t&#x2F;“,”&#x2F;g;s&#x2F;^&#x2F;“&#x2F;;s&#x2F;$&#x2F;“&#x2F;;s&#x2F;\n&#x2F;&#x2F;g’ &gt; app.csv <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 字段操作</span><br><span class="line">1. 修改表字段类型：  </span><br></pre></td></tr></table></figure>
 alter table [TB] modify 字段名 varchar(20); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 增加表字段：  </span><br></pre></td></tr></table></figure>
 alter table [TB] add column age int(3); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 增加表字段时控制顺序（或者使用first）：  </span><br></pre></td></tr></table></figure>
 alter table [TB] add column age int(3) after [旧字段名]; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 删除表字段：  </span><br></pre></td></tr></table></figure>
 alter table [TB] drop [字段名]; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5. 修改表字段名：  </span><br></pre></td></tr></table></figure>
 alter table [TB] change [字段原名] [字段新名] [字段类型]; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 索引</span><br><span class="line">1. 普通索引</span><br></pre></td></tr></table></figure>
 alter table 表 add idnex(字段); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 唯一索引</span><br></pre></td></tr></table></figure>
 alter table 表 add unique(字段); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 全文索引</span><br></pre></td></tr></table></figure>
 alter table 表 add fulltext(字段); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 主键索引</span><br></pre></td></tr></table></figure>
 alter table 表 add primary key(字段); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看任务及其状态</span><br><span class="line">1. 查看任务及其状态 </span><br><span class="line">    ```sql</span><br><span class="line">    show full processlist;</span><br></pre></td></tr></table></figure></li>
<li>过滤掉Sleep链接 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pager grep <span class="operator">-</span>v Sleep</span><br></pre></td></tr></table></figure></li>
<li>结束单个任务 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">    kill Id</span><br><span class="line">    ```<span class="keyword">sql</span></span><br><span class="line"><span class="number">4.</span> 批量结束任务</span><br><span class="line">    ```<span class="keyword">sql</span></span><br><span class="line">    <span class="keyword">select</span> concat(<span class="string">&#x27;kill &#x27;</span>,id,<span class="string">&#x27;;&#x27;</span>) <span class="keyword">from</span> information_schema.processlist <span class="keyword">where</span> info <span class="keyword">like</span> <span class="string">&#x27;%INSERT INTO `log`%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>查看和修改最大连接 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%max_connections%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">GLOBAL</span> max_connections <span class="operator">=</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h2><ol>
<li>配置变量查看和修改 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%max_allowed_packet%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> max_allowed_packet<span class="operator">=</span><span class="number">1073741824</span>;</span><br></pre></td></tr></table></figure></li>
<li>查看和修改引擎 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">select</span> CONCAT(<span class="string">&#x27;alter table &#x27;</span>, table_schema, <span class="string">&#x27;.&#x27;</span>, table_name,<span class="string">&#x27; engine=InnoDB;&#x27;</span>) <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>&quot;interface_manage&quot; <span class="keyword">AND</span> ENGINE<span class="operator">=</span>&quot;MyISAM&quot;;    </span><br></pre></td></tr></table></figure></li>
<li>统计每天任务量 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),DATE_FORMAT(FROM_UNIXTIME(<span class="type">time</span>), <span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="keyword">AS</span> t <span class="keyword">from</span> [TB] <span class="keyword">WHERE</span> DATE_FORMAT(FROM_UNIXTIME(<span class="type">time</span>), <span class="string">&#x27;%Y&#x27;</span>) <span class="operator">=</span> <span class="string">&#x27;2020&#x27;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> t</span><br></pre></td></tr></table></figure></li>
<li>批量删除符合某些字符串的数据表 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 以下拼接结果有长度限制，可重复多次得到结果</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT( <span class="string">&#x27;DROP TABLE &#x27;</span>, GROUP_CONCAT(table_name) , <span class="string">&#x27;;&#x27;</span> ) <span class="keyword">AS</span> statement <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema <span class="operator">=</span> [DB] <span class="keyword">AND</span> table_name <span class="keyword">LIKE</span> <span class="string">&#x27;[TB]%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 将拼接得到的结果执行删除</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">廖雪峰SQL教程</a><br><a href="https://juejin.cn/post/6844903870053761037">cenos安装mysql</a><br><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a><br><a href="https://xiaolincoding.com/mysql/">图解MySQL介绍</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>network-面试</title>
    <url>/%E9%9D%A2%E8%AF%95/network-%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>network 面试要点</p>
<span id="more"></span>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="TCP-x2F-IP-网络模型分层"><a href="#TCP-x2F-IP-网络模型分层" class="headerlink" title="TCP&#x2F;IP 网络模型分层"></a>TCP&#x2F;IP 网络模型分层</h2><ol>
<li>应用层：向用户提供一组应用程序<br> 操作系统中的用户态，专注为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP 等。</li>
<li>传输层：负责端到端的通信<br> 为应用层提供网络支持，有两个传输协议，分别是 TCP 和 UDP。<ol>
<li>TCP：流量控制、超时重传、拥塞控制保障数据包可靠传输到对方。</li>
<li>UDP：只负责发送数据包、不保证到达，实时性相对较好，传输效率高。也可以实现可靠穿梭，把 TCP 的特性在应用层上实现就可以。</li>
<li>当传输层数据超过 MSS（TCP 最大报文段长度），需要分段传输，称为一个 TCP 段。同时需要端口号来区分不同的应用数据。</li>
</ol>
</li>
<li>网络层：负责网络包的封装、分片、路由、转发<br> 比如 IP、ICMP 等<br> IP 协议，将传输层的报文作为数据部分，再加上 IP 头组装成 IP 报文。如果大小超过 MTU （以太网中一般为 1500 字节），就会再次分片。 <img src="./网络模型分层.webp" width = "50%" height = "50%" alt="网络模型分层" align=center />
 IP 地址分成两种意义

<pre><code> 1. 一个是网络号，负责标识该 IP 地址是属于哪个「子网」的；
 2. 一个是主机号，负责标识同一「子网」下的不同主机；
</code></pre>
 IP 寻址和路由：IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。</li>
<li>网络接口层：网络包在物理网络中的传输<br> 网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包。<br> 比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等。</li>
<li>总结 <img src="./网络模型分层数据封装.webp" width = "50%" height = "50%" alt="网络模型分层数据封装" align=center /></li>
</ol>
<p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。统称为数据包。</p>
<h2 id="键入网址到网页显示过程"><a href="#键入网址到网页显示过程" class="headerlink" title="键入网址到网页显示过程"></a>键入网址到网页显示过程</h2><img src="./http请求.webp" width = "50%" height = "50%" alt="http请求" align=center />

<ol>
<li><p>解析 URL ，生成 HTTP 请求  </p>
<ol>
<li>生成发送给 web 服务器的请求信息。   <img src="./URL解析.webp" width = "50%" height = "50%" alt="URL解析" align=center /></li>
<li>http请求和响应   <img src="./http请求和响应.webp" width = "50%" height = "50%" alt="http请求和响应" align=center /></li>
</ol>
</li>
<li><p>DNS 域名解析查询真实 IP 地址<br> 服务器域名对应的 IP 地址。<br> DNS 保存了 web 服务器和 IP 之间的对应关系。</p>
<ol>
<li>域名解析会通过缓存<br> 浏览器缓存 -&gt; 操作系统缓存 -&gt; hosts -&gt; 本地 DNS 服务器</li>
<li>域名解析的工作流程<br> 客户端首先会发出一个 DNS 请求 -&gt; 缓存 -&gt; 本地 DNS 服务器 -&gt; 根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威域名服务器 -&gt; ip</li>
</ol>
</li>
<li><p>指南好帮手 —— 协议栈<br> 通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。</p>
 <img src="./协议栈.webp" width = "50%" height = "50%" alt="协议栈" align=center />

<p> 协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。<br> 协议栈的下面一半是用 IP 协议控制网络包收发操作。<br> IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p>
</li>
<li><p>可靠传输 —— TCP</p>
<ol>
<li>三次握手建立连接，保证双方都有发送和接收的能力 <img src="./TCP三次握手.png" width = "50%" height = "50%" alt="TCP三次握手" align=center />

<ol>
<li>一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。</li>
<li>然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。</li>
<li>服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。</li>
<li>客户端收到服务端发送的 SYN 和 ACK 之后，发送对 SYN 确认的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。</li>
<li>服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。</li>
</ol>
</li>
<li>TCP 分割数据<ol>
<li>MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。传输层。</li>
<li>MTU：一个网络包的最大长度，以太网中一般为 1500 字节。网路层。</li>
</ol>
</li>
</ol>
</li>
<li><p>远程定位 —— IP</p>
 <img src="./ip协议.webp" width = "50%" height = "50%" alt="ip协议" align=center />

<p> 在 IP 协议里面需要有源地址 IP 和 目标地址 IP：</p>
<pre><code> 源地址IP，即是客户端输出的 IP 地址；
 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。
</code></pre>
</li>
<li><p>两点传输 —— MAC<br> MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p>
<p> ARP（Address Resolution Protocol），即地址解析协议，是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p>
<p> MAC 发送方和接收方如何确认?</p>
<pre><code> 发送方的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

 接收方的 MAC 地址就有点复杂了，ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。
</code></pre>
<p> 也就是说，在发包时：</p>
<pre><code> 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。
</code></pre>
</li>
<li><p>出口 —— 网卡<br> 网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>
<p> 负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。</p>
 <img src="./数据包.webp" width = "50%" height = "50%" alt="数据包" align=center />
</li>
<li><p>送别者 —— 交换机<br> 交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为二层网络设备。<br> 和网卡不同，交换机的端口不具有 MAC 地址。</p>
</li>
<li><p>出境大门 —— 路由器<br> 网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。</p>
<p> 路由器和交换机是有区别的。</p>
<pre><code> 因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
 而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。
</code></pre>
<p> 在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。</p>
</li>
<li><p>互相扒皮 —— 服务器 与 客户端<br>数据包抵达服务器后，服务器会层层扒开数据包： MAC 头部 -&gt; IP 头 -&gt; TCP 头 -&gt; 序列号（如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。）-&gt; 端口号 -&gt; 交给监听这个端口的应用程序进程 -&gt; 将网页封装进响应报文 -&gt; 层层协议嵌套 -&gt; 网卡 -&gt; 交换机 -&gt; 路由器 -&gt; 交换机 -&gt; 网卡 -&gt; 层层协议解析 -&gt; 客户端应用进程 -&gt; 渲染页面。</p>
</li>
<li><p>总结<br>应用程序数据（应用层）<br>TCP 可靠传输（传输层）<br>IP 路由和寻址（网络层）<br>MAC 点对点传输（网络接口层）<br>数电转换（网卡驱动程序控制网卡）<br>交换机转发 （原样转发网络包）<br>路由器（IP 路由转发）</p>
</li>
</ol>
<h2 id="Linux系统如何收发网络包"><a href="#Linux系统如何收发网络包" class="headerlink" title="Linux系统如何收发网络包"></a>Linux系统如何收发网络包</h2><ol>
<li>网络模型 <img src="./OSI与TCP.webp" width = "50%" height = "50%" alt="OSI与TCP" align=center />

 当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。</li>
</ol>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-是什么"><a href="#HTTP-是什么" class="headerlink" title="HTTP 是什么"></a>HTTP 是什么</h2><p>HTTP 是超文本传输协议，是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p>
<h2 id="HTTP-常见的状态码"><a href="#HTTP-常见的状态码" class="headerlink" title="HTTP 常见的状态码"></a>HTTP 常见的状态码</h2><img src="./五大类HTTP状态码.webp" width = "50%" height = "50%" alt="五大类HTTP状态码" align=center />

<h2 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h2><ol>
<li>GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</li>
<li>POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</li>
</ol>
<h2 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h2><ol>
<li>安全：指请求方法不会「破坏」服务器上的资源。</li>
<li>幂等：意思是多次执行相同的操作，结果都是「相同」的。</li>
</ol>
<p>如果从 RFC 规范定义的语义来看：</p>
<pre><code>GET 方法就是安全且幂等的。
POST 方法不安全不幂等，因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。
</code></pre>
<p>GET 请求可以带 body 吗？<br>    理论上，任何请求都可以带 body 的。 任何请求的 URL 中也可以有参数的。</p>
<h2 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h2><p>HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。</p>
<p>什么是强制缓存？<br>    1. 强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边<br>    2. 强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：<br>        Cache-Control， 是一个相对时间；(优先级高)<br>        Expires，是一个绝对时间；<br>    3. 具体的实现流程如下：</p>
<pre><code>    1. 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
    2. 浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；
    3. 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。
</code></pre>
<p>什么是协商缓存？<br>    协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。<br>    协商缓存可以基于两种头部来实现。</p>
<pre><code>    1. 第一种（基于时间，可被篡改，不可靠）：请求头部中的 If-Modified-Since 字段带上缓存的响应头部中的 Last-Modified 字段实现。
    2. 第二种（基于唯一标识，更可靠，优先级高）：请求头部中的 If-None-Match 字段带上缓存的响应头部中的 ETag 字段（唯一标识响应资源）。
</code></pre>
<p>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<img src="./http缓存.webp" width = "50%" height = "50%" alt="http缓存" align=center />


<h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ol>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<h2 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h2><ol>
<li>HTTP 由于是明文传输，所以安全上存在以下三个风险 <ol>
<li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li>篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li>冒充风险，比如冒充淘宝网站，用户钱容易没。</li>
</ol>
</li>
</ol>
<img src="./HTTPS与HTTP.webp" width = "50%" height = "50%" alt="HTTPS与HTTP" align=center />

<ol start="2">
<li>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了上述的风险：<ol>
<li>信息加密（混合加密实现信息的机密性）：交互信息无法被窃取。</li>
<li>校验机制（摘要算法的方式来实现完整性）：无法篡改通信内容，篡改了就不能正常显示。</li>
<li>身份证书（服务器公钥放入到数字证书）：证明淘宝是真的淘宝网。</li>
</ol>
</li>
</ol>
<h2 id="http1-0-x2F-1-1-x2F-2-x2F-3比较"><a href="#http1-0-x2F-1-1-x2F-2-x2F-3比较" class="headerlink" title="http1.0&#x2F;1.1&#x2F;2&#x2F;3比较"></a>http1.0&#x2F;1.1&#x2F;2&#x2F;3比较</h2><img src="./http123比较.webp" width = "50%" height = "50%" alt="http123比较" align=center />

<ol>
<li><p>http1.1 优点</p>
<ol>
<li>使用长连接的方式改善1.0短连接造成的性能开销</li>
<li>支持管道网络传输，不必等前一个请求回来就可以发出下一个请求，减少整体响应时间</li>
</ol>
</li>
<li><p>http2（基于https） 优点</p>
<ol>
<li>头部压缩（HPACK 算法，维护头信息表，只发送索引号）</li>
<li>二进制格式（头信息和数据体都是二进制，统称为帧）</li>
<li>并发传输（多个stream复用tcp链接，解决http层面队头阻塞问题）</li>
<li>服务器主动推送（客户端stream为奇数号，服务端为偶数号，比如网页中的其他css依赖）</li>
</ol>
</li>
<li><p>http3 优点</p>
<ol>
<li>把http下层的 tcp 协议改成了 udp 。<br> UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP&#x2F;2 队头阻塞的问题。</li>
<li>增加 基于 UDP 的 QUIC 协议实现类似 TCP 的可靠传输。<ol>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移<ol>
<li>tcp 四元组（源地址、源端口、目的地址、目的端口）</li>
<li>QUIC 链接ID<br> 所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="基于-udp-实现可靠传输"><a href="#基于-udp-实现可靠传输" class="headerlink" title="基于 udp 实现可靠传输"></a>基于 udp 实现可靠传输</h2><p>TCP 可靠传输的特性（序列号、确认应答、超时重传、流量控制、拥塞控制）在应用层实现一遍。</p>
<pre><code>1.  TCP 协议四个方面的缺陷：
    1. 升级 TCP 的工作很困难；
    2. TCP 建立连接的延迟；
    3. TCP 存在队头阻塞问题；
    4. 网络迁移需要重新建立 TCP 连接;
</code></pre>
<p>市面上已经有基于 UDP 协议实现的可靠传输协议的成熟方案了，那就是 QUIC 协议，已经应用在了 HTTP&#x2F;3。</p>
<h2 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h2><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h2 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h2><p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</p>
<p>建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p>
<pre><code>Socket：由 IP 地址和端口号组成
序列号：用来解决乱序问题等
窗口大小：用来做流量控制
</code></pre>
<h2 id="UDP-和-TCP-有什么区别呢？"><a href="#UDP-和-TCP-有什么区别呢？" class="headerlink" title="UDP 和 TCP 有什么区别呢？"></a>UDP 和 TCP 有什么区别呢？</h2><ol>
<li>连接<ol>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ol>
</li>
<li>服务对象<ol>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信。</li>
</ol>
</li>
<li>可靠性<ol>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ol>
</li>
<li>拥塞控制、流量控制<ol>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ol>
</li>
<li>首部开销<ol>
<li>TCP 首部长度较长，会有一定的开销。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ol>
</li>
<li>传输方式<ol>
<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>
<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>
</ol>
</li>
</ol>
<h2 id="端口的TCP最大连接数是多少？"><a href="#端口的TCP最大连接数是多少？" class="headerlink" title="端口的TCP最大连接数是多少？"></a>端口的TCP最大连接数是多少？</h2><pre><code>TCP最大连接数 = 客户端的ip数 x 客户端的端口数
            = 2^32 x 2^16
            = 2^48
</code></pre>
<p>还受以下影响</p>
<pre><code>1. 文件描述符
    每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。
2. 内存限制
    每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。
</code></pre>
<h2 id="TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗？"></a>TCP 和 UDP 可以同时绑定相同的端口吗？</h2><p>可以的。<br>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p>
<h2 id="多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗？"></a>多个 TCP 服务进程可以绑定同一个端口吗？</h2><p>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</p>
<h2 id="重启-TCP-服务进程时，为什么会有“Address-in-use”的报错信息？"><a href="#重启-TCP-服务进程时，为什么会有“Address-in-use”的报错信息？" class="headerlink" title="重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？"></a>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？</h2><p>当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。</p>
<h2 id="客户端的端口可以重复使用吗？"><a href="#客户端的端口可以重复使用吗？" class="headerlink" title="客户端的端口可以重复使用吗？"></a>客户端的端口可以重复使用吗？</h2><p>可以，因为内核是通过四元组信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</p>
<h2 id="tcp-为什么是三次握手"><a href="#tcp-为什么是三次握手" class="headerlink" title="tcp 为什么是三次握手"></a>tcp 为什么是三次握手</h2><p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<pre><code>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。
</code></pre>
<h2 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h2><ol>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）。</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li>
</ol>
<h2 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h2><ol>
<li>如果仅有IP分片，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。<br>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。<br>经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。</li>
</ol>
<h2 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h2><p>在特定情况下，四次挥手是可以变成三次挥手的。主要看服务端关闭后是否需要处理数据，如果不需要处理数据，则可以直接将第二次和第三次挥手整合成一次。</p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="ping-的工作原理"><a href="#ping-的工作原理" class="headerlink" title="ping 的工作原理"></a>ping 的工作原理</h2><p>ping 是基于网络层的 ICMP 协议工作的，是其查询报文类型的使用。</p>
<p>ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。</p>
<p>ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p>
<p>ICMP 的这种通知消息会使用 IP 进行发送 。</p>
<p>ping 这个程序是使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）。</p>
<h2 id="断网了，还能-ping-通-127-0-0-1-吗？"><a href="#断网了，还能-ping-通-127-0-0-1-吗？" class="headerlink" title="断网了，还能 ping 通 127.0.0.1 吗？"></a>断网了，还能 ping 通 127.0.0.1 吗？</h2><p>拔了网线，ping 127.0.0.1 是能ping通的。</p>
<p>从应用层到传输层再到网络层。这段路径跟ping外网的时候是几乎是一样的。到了网络层，系统会根据目的IP，在路由表中获取对应的路由信息，而这其中就包含选择哪个网卡把消息发出。</p>
<pre><code>当发现目标IP是外网IP时，会从&quot;真网卡&quot;发出。
当发现目标IP是回环地址时，就会选择本地网卡。
</code></pre>
<p>IPV4: 127 开头的都属于回环地址，127.0.0.1是众多回环地址中的一个。<br>IPV6: 回环地址是 ::1，中间把连续的0给省略了，之所以不是7个 冒号，而是2个冒号: ， 是因为一个 IPV6 地址中只允许出现⼀次两个连续的冒号。</p>
<p>在IPV4下用的是 ping 127.0.0.1 命令。在IPV6下用的是 ping6 ::1 命令。</p>
<p>虽然ICMP协议和IP协议都属于网络层协议，但其实ICMP也是利用了IP协议进行消息的传输。</p>
<h2 id="TCP发数据和ping的区别"><a href="#TCP发数据和ping的区别" class="headerlink" title="TCP发数据和ping的区别"></a>TCP发数据和ping的区别</h2><p>TCP: mac头 + IP头 + TCP头 + tcp数据<br>PING: mac头 + IP头 + ICMP头 + ping数据</p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>linux里万物皆文件，那你要发消息的目的地，也是个文件，这里就引出了socket 的概念。</p>
<p>在 TCP 传输中创建的方式是 socket(AF_INET, SOCK_STREAM, 0);，其中 AF_INET 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。SOCK_STREAM 是指使用面向字节流的 TCP 协议，工作在传输层。</p>
<p>创建好了 socket 之后，就可以愉快的把要传输的数据写到这个文件里。调用 socket 的sendto接口的过程中进程会从用户态进入到内核态，最后会调用到 sock_sendmsg 方法。</p>
<p>然后进入传输层，带上TCP头。网络层带上IP头，数据链路层带上 MAC头等一系列操作后。进入网卡的发送队列 ring buffer ，顺着网卡就发出去了。</p>
<p>回到 ping ， 整个过程也基本跟 TCP 发数据类似，差异的地方主要在于，创建 socket 的时候用的是 socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)，SOCK_RAW 是原始套接字 ，工作在网络层， 所以构建ICMP（网络层协议）的数据，是再合适不过了。ping 在进入内核态后最后也是调用的 sock_sendmsg 方法，进入到网络层后加上ICMP和IP头后，数据链路层加上MAC头，也是顺着网卡发出。因此 本质上ping 跟 普通应用发消息 在程序流程上没太大差别。</p>
<h2 id="ping回环地址和ping本机地址有什么区别"><a href="#ping回环地址和ping本机地址有什么区别" class="headerlink" title="ping回环地址和ping本机地址有什么区别"></a>ping回环地址和ping本机地址有什么区别</h2><p>ping回环地址和ping本机地址没有区别。</p>
<p>相关的网络数据，都是走的 lo0 “假网卡”，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前狠狠拐了个弯， 将数据插入到一个链表后就软中断通知 ksoftirqd 来进行收数据的逻辑，压根就不出网络。所以断网了也能 ping 通回环地址。</p>
<h2 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h2><p>127.0.0.1: 本地回环地址<br>localhost: 是一个域名，只不过默认会把它解析为 127.0.0.1，当然这可以在 &#x2F;etc&#x2F;hosts 文件下进行修改。<br>0.0.0.0: 执行 ping 0.0.0.0，是会失败的，因为它在IPV4中表示的是无效的目标地址。<br>    我们启动服务器的时候，一般会 listen 一个 IP 和端口，等待客户端的连接。<br>    如果此时 listen 的是本机的 0.0.0.0 , 那么它表示本机上的所有IPV4地址。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://xiaolincoding.com/network/">图解网络介绍</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/</url>
    <content><![CDATA[<p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="centos7-安装-Nginx"><a href="#centos7-安装-Nginx" class="headerlink" title="centos7 安装 Nginx"></a>centos7 安装 Nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加yum源</span></span><br><span class="line">rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">yum repolist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum intall nginx</span><br></pre></td></tr></table></figure>

<h2 id="启动和其他命令"><a href="#启动和其他命令" class="headerlink" title="启动和其他命令"></a>启动和其他命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动并进行测试</span></span><br><span class="line">nginx -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start nginx</span><br><span class="line">nginx -c /PAHT/TO/nginx.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">systemctl reload nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 热更新配置</span></span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查配置文件并定位</span></span><br><span class="line">nginx -t</span><br><span class="line">nginx -t -c /PAHT/TO/nginx.conf</span><br></pre></td></tr></table></figure>


<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><img src="./nginx.webp" width = "50%" height = "50%" alt="nginx" align=center />

<p>Nginx的Master-Worker模式Nginx的Master-Worker模式</p>
<img src="./Master-Worker.webp" width = "50%" height = "50%" alt="Master-Worker" align=center />

<p>Master进程的作用是？<br>    读取并验证配置文件nginx.conf；管理worker进程；</p>
<p>Worker进程的作用是？<br>    每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</p>
<h1 id="Nginx如何做到热部署？"><a href="#Nginx如何做到热部署？" class="headerlink" title="Nginx如何做到热部署？"></a>Nginx如何做到热部署？</h1><p>所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效。（nginx -s reload ）</p>
<h2 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h2><p>修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点valatile的味道）</p>
<h2 id="方案二（Nginx采用）："><a href="#方案二（Nginx采用）：" class="headerlink" title="方案二（Nginx采用）："></a>方案二（Nginx采用）：</h2><p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p>
<h1 id="Nginx如何做到高并发下的高效处理？"><a href="#Nginx如何做到高并发下的高效处理？" class="headerlink" title="Nginx如何做到高并发下的高效处理？"></a>Nginx如何做到高并发下的高效处理？</h1><p>上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p>
<p>作为专业的程序员，我们可以开一下脑洞：BIO&#x2F;NIO&#x2F;AIO、异步&#x2F;同步、阻塞&#x2F;非阻塞…</p>
<p>要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</p>
<p>Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</p>
<h1 id="Nginx挂了怎么办？"><a href="#Nginx挂了怎么办？" class="headerlink" title="Nginx挂了怎么办？"></a>Nginx挂了怎么办？</h1><p>Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p>
<p>Keepalived+Nginx实现高可用。</p>
<p>Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）。</p>
<p>Keepalived+Nginx实现高可用的思路：</p>
<p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p>
<p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</p>
<h1 id="配置-nginx-conf"><a href="#配置-nginx-conf" class="headerlink" title="配置 nginx.conf"></a>配置 nginx.conf</h1><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><pre><code>其实这是把Nginx作为web server来处理静态资源。

第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）

第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。

第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。

第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。
</code></pre>
<h2 id="反向代理【proxy-pass】"><a href="#反向代理【proxy-pass】" class="headerlink" title="反向代理【proxy_pass】"></a>反向代理【proxy_pass】</h2><pre><code>所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。

反向代理，上面已经说了，过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。
</code></pre>
<h2 id="负载均衡【upstream】"><a href="#负载均衡【upstream】" class="headerlink" title="负载均衡【upstream】"></a>负载均衡【upstream】</h2><pre><code>上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？

第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。

第二，将proxy_pass替换成upstream指定的值即可。

负载均衡可能带来的问题？
    负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。
</code></pre>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><pre><code>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。具体配置，大家可以参考Nginx官方文档，这里就不在展开了。
</code></pre>
<h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://zhuanlan.zhihu.com/p/34943332">8分钟带你深入浅出搞懂Nginx
</a><br><a href="https://mp.weixin.qq.com/s/XoqGvYBabW8YBl9xEeNYZw">Nginx详解，睡前十分钟啃完值了！</a><br><a href="https://mp.weixin.qq.com/s/TYM83F2O-keMvn4ZYa5nqw">一文详解负载均衡和反向代理的真实区别</a><br><a href="https://juejin.cn/post/6844904129987526663">连前端都看得懂的《Nginx 入门指南》</a></p>
]]></content>
      <categories>
        <category>Web服务器</category>
        <category>反向代理服务器</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>process-thread</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/process-thread/</url>
    <content><![CDATA[<p>运行中的程序，就被称为「进程」（Process）。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>进程<ol>
<li>进程的概念</li>
<li>进程的状态</li>
<li>进程的控制结构</li>
<li>进程的控制</li>
<li>进程的上下文切换</li>
</ol>
</li>
<li>线程<ol>
<li>为什么使用线程？</li>
<li>什么是线程？</li>
<li>线程与进程的比较</li>
<li>线程的上下文切换</li>
<li>线程的实现</li>
</ol>
</li>
<li>调度<ol>
<li>调度时机</li>
<li>调度原则</li>
<li>调度算法</li>
</ol>
</li>
</ol>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>进行中的程序，就被称为「进程」（Process）。</p>
<p>编写的代码 -编译-&gt; 二进制可执行文件 -运行-&gt; 加载进内存 -cpu执行-&gt; 运行中</p>
<p>对于一个支持多进程的系统，CPU 会从一个进程快速切换至另一个进程，其间每个进程各运行几十或几百个毫秒。</p>
<p>这种多个程序、交替执行的思想，就有 CPU 管理多个进程的初步想法。</p>
<p>虽然单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是并发。</p>
<p>并发vs并行：并发是单核处理器快速交替执行多个进程，并行是多核处理器分别执行各自的进程。<br><img src="./并发与并行.webp" width = "50%" height = "50%" alt="并发与并行" align=center /></p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><img src="./进程七个状态.webp" width = "50%" height = "50%" alt="进程七个状态" align=center />

<p>如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。</p>
<p>用挂起状态来描述进程没有占用实际的物理内存空间的情况</p>
<p>导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：</p>
<pre><code>1. 通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。
2. 用户希望挂起一个程序的执行，比如在 Linux 中用 Ctrl+Z 挂起进程；
</code></pre>
<h3 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h3><p>进程控制块（process control block，PCB）数据结构来描述进程的</p>
<p>PCB 是进程存在的唯一标识</p>
<p>进程描述信息：</p>
<pre><code>1. 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
2. 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；
</code></pre>
<p>进程控制和管理信息：</p>
<pre><code>1. 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
2. 进程优先级：进程抢占 CPU 时的优先级；
</code></pre>
<p>资源分配清单：</p>
<pre><code>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。
</code></pre>
<p>CPU 相关信息：</p>
<pre><code>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。
</code></pre>
<p>每个 PCB 是如何组织的呢？</p>
<pre><code>通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。比如：
1. 将所有处于就绪状态的进程链在一起，称为就绪队列；
2. 把所有因等待某事件而处于等待状态的进程链在一起就组成各种阻塞队列；
3. 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。
</code></pre>
<h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><ol>
<li><p>创建进程<br> 操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。</p>
<ol>
<li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息</li>
<li>为该进程分配运行时所必需的资源，比如内存资源；</li>
<li>将 PCB 插入到就绪队列，等待被调度运行；</li>
</ol>
</li>
<li><p>终止进程<br> 进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 kill 掉）。</p>
<p> 当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。</p>
<ol>
<li>查找需要终止的进程的 PCB；</li>
<li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li>
<li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li>
<li>将该进程所拥有的全部资源都归还给操作系统；</li>
<li>将其从 PCB 所在队列中删除；</li>
</ol>
</li>
<li><p>阻塞进程<br> 当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</p>
<ol>
<li>找到将要被阻塞进程标识号对应的 PCB；</li>
<li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；</li>
<li>将该 PCB 插入到阻塞队列中去；</li>
</ol>
</li>
<li><p>唤醒进程<br> 进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。</p>
<p> 如果某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p>
<ol>
<li>在该事件的阻塞队列中找到相应进程的 PCB；</li>
<li>将其从阻塞队列中移出，并置其状态为就绪状态；</li>
<li>把该 PCB 插入到就绪队列中，等待调度程序调度</li>
</ol>
</li>
</ol>
<h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p>各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个一个进程切换到另一个进程运行，称为进程的上下文切换。</p>
<ol>
<li><p>CPU 上下文切换<br> CPU 寄存器和程序计数器是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。</p>
<p> CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p> 上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。</p>
</li>
<li><p>进程的上下文切换到底是切换什么呢？<br> 进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p>
<p> 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p>
</li>
<li><p>发生进程上下文切换有哪些场景？</p>
<ol>
<li>CPU时间片耗尽，运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li>
<li>在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程被挂起；</li>
<li>通过睡眠函数sleep将滋滋主动挂起；</li>
<li>有更高优先级进程运行时，当前进程被挂起；</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；</li>
</ol>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在早期的操作系统中都是以进程作为独立运行的基本单位，直到后面，计算机科学家们又提出了更小的能独立运行的基本单位，也就是线程。</p>
<h3 id="为什么使用线程？"><a href="#为什么使用线程？" class="headerlink" title="为什么使用线程？"></a>为什么使用线程？</h3><p>线程之间可以并发运行且共享相同的地址空间。</p>
<h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><img src="./多线程内存结构.webp" width = "50%" height = "50%" alt="多线程内存结构" align=center />

<p>线程是进程当中的一条执行流程。</p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源。<br>每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p>
<p>线程的优点：</p>
<pre><code>1. 一个进程中可以同时存在多个线程；
2. 各个线程之间可以并发执行；
3. 各个线程之间可以共享地址空间和文件等资源；
</code></pre>
<p>线程的缺点：</p>
<pre><code>1. 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）
</code></pre>
<h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><ol>
<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执行的时间和空间开销；</li>
</ol>
<p>对于，线程相比进程能减少开销，体现在：</p>
<pre><code>1. 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
2. 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
3. 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
4. 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；
</code></pre>
<p>所以，不管是时间效率，还是空间效率线程比进程都要高。</p>
<h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><p>所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。</p>
<p>对于线程和进程，我们可以这么理解：</p>
<pre><code>1. 当进程只有一个线程时，可以认为进程就等于线程；
2. 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，这些资源在上下文切换时是不需要修改的；
</code></pre>
<p>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p>
<p>线程上下文切换的是什么？<br>    这还得看线程是不是属于同一个进程：</p>
<pre><code>1. 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
2. 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；
</code></pre>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式：</p>
<ol>
<li><p>用户线程（User Thread）：多对一，即多个用户线程对应同一个内核线程</p>
<ol>
<li>在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li>
<li>用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</li>
</ol>
</li>
<li><p>内核线程（Kernel Thread）：一对一，即一个用户线程对应一个内核线程<br> 1.在内核中实现的线程，是由内核管理的线程；</p>
<ol start="2">
<li>内核线程是由操作系统管理的，线程对应的 TCB<br> 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。</li>
</ol>
</li>
<li><p>轻量级进程（LightWeight Process）：</p>
<ol>
<li>在内核中来支持用户线程；</li>
<li>是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度；</li>
<li>LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。</li>
</ol>
</li>
</ol>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>选择一个进程运行 这个功能是在操作系统中完成的，通常称为调度程序（scheduler）。</p>
<h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><p>在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。</p>
<p>另外，如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断 ，把调度算法分为两类：</p>
<pre><code>1. 非抢占式调度算法挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
2. 抢占式调度算法挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制。
</code></pre>
<h3 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h3><p>原则一：如果运行的程序，发生了 I&#x2F;O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，为了提高 CPU 利用率，在这种发送 I&#x2F;O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。</p>
<p>原则二：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。</p>
<p>原则三：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。</p>
<p>原则四：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，就绪队列中进程的等待时间也是调度程序所需要考虑的原则。</p>
<p>原则五：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。</p>
<p>针对上面的五种调度原则，总结成如下：</p>
<pre><code>1. CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
2. 系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
3. 周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；
4. 这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
5. 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。
</code></pre>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>多级反馈队列（Multilevel Feedback Queue）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。<br>顾名思义：</p>
<pre><code>1. 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。
2. 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；
</code></pre>
<img src="./多级队列.webp" width = "50%" height = "50%" alt="多级队列" align=center/>

<p>来看看，它是如何工作的：</p>
<pre><code>1. 设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；
2. 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；
3. 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；
</code></pre>
<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。</p>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B">进程管理</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>python</title>
    <url>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/</url>
    <content><![CDATA[<p>Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。</p>
<span id="more"></span>


<h2 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;文档注释</span><br><span class="line"></span><br><span class="line">文档功能描述</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;Jeson Lin&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SampleClass(object):</span><br><span class="line">    &quot;&quot;&quot;类功能</span><br><span class="line"></span><br><span class="line">    类功能详细描述</span><br><span class="line"></span><br><span class="line">    Attributes:</span><br><span class="line">        attr1: 属性1描述</span><br><span class="line">        attr2: 属性2描述</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, attr1=False):</span><br><span class="line">        &quot;&quot;&quot;初始化 SampleClass 用attr1&quot;&quot;&quot;</span><br><span class="line">        self.attr1 = attr1</span><br><span class="line">        self.attr2 = 0</span><br><span class="line"></span><br><span class="line">    def _inner_methon(self):</span><br><span class="line">        &quot;&quot;&quot;类内自身调用方法&quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def public_method(self):</span><br><span class="line">        &quot;&quot;&quot;公共方法&quot;&quot;&quot;</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sample_function(param1: str, param2: &#x27;int &gt; 0&#x27;, param3: bool = False) -&gt; dict:</span><br><span class="line">    &quot;&quot;&quot;函数功能</span><br><span class="line"></span><br><span class="line">    函数功能详细描述</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        param1: 参数1说明。</span><br><span class="line">        param2: 参数2说明。</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        返回值描述</span><br><span class="line">        example:</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            &quot;a&quot;: 1,</span><br><span class="line">            &quot;b&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        返回详细描述</span><br><span class="line"></span><br><span class="line">    Raises:</span><br><span class="line">        IOError: 异常描述</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 函数功能逻辑</span><br><span class="line">    pass</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;hello, world&#x27;)</span><br></pre></td></tr></table></figure>


<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><ol>
<li>centos <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y python36</span><br><span class="line">ln -s python3.6 python3</span><br><span class="line">yum install -y python36-setuptools</span><br><span class="line">easy_install pip </span><br></pre></td></tr></table></figure></li>
<li>mac <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 官网下载安装包</span><br><span class="line">https://www.python.org/downloads/</span><br><span class="line"></span><br><span class="line"># 安装了Homebrew</span><br><span class="line">brew install python3</span><br></pre></td></tr></table></figure></li>
<li>解释器<br> 安装python后，命令行运行<code>python</code>启动python交互解释器。  <ol>
<li>CPython<br> 用<code>&gt;&gt;&gt;</code>作为提示符，用C语言开发</li>
<li>IPython<br> 用<code>In [序号]:</code>作为提示符，基于CPython之上，增强交互。</li>
<li>PyPy<br> PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。需要了解PyPy和CPython的不同点。</li>
<li>Jython<br> Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</li>
</ol>
</li>
<li>Shebang<ol>
<li>在计算机科学中，Shebang (也称为Hashbang)是一个由井号和叹号构成的字符串行(<code>#!</code>)，其出现在文本文件的第一行的前两个字符。  </li>
<li>在文件中存在Shebang的情况下， 类Unix操作系统的程序载入器会分析Shebang后的内容，将这些内容作为解释器指令， 并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。  </li>
<li>例如，以指令<code>#!/bin/sh</code>开头的文件在执行时会实际调用<code>/bin/sh 程序</code>。)</li>
</ol>
</li>
</ol>
<h2 id="虚拟环境-virtualenv"><a href="#虚拟环境-virtualenv" class="headerlink" title="虚拟环境-virtualenv"></a>虚拟环境-virtualenv</h2><ol>
<li>升级pip <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 升级pip</span><br><span class="line">python3 -m pip install --upgrade --force-reinstall pip</span><br><span class="line"></span><br><span class="line"># pip 位置变成/usr/local/bin/pip</span><br><span class="line">which pip</span><br><span class="line"></span><br><span class="line"># pip 缓存没更新/usr/bin/pip</span><br><span class="line">type pip</span><br><span class="line"></span><br><span class="line"># 更新缓存</span><br><span class="line">hash -r</span><br></pre></td></tr></table></figure></li>
<li>安装virtualenv <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">pip install virtualenv</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">virtualenv --version</span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line">mkdir project_virtualenv</span><br><span class="line">cd project_virtualenv</span><br><span class="line">virtualenv venv</span><br><span class="line"></span><br><span class="line"># 激活虚拟环境</span><br><span class="line">source venv/bin/activate</span><br><span class="line"></span><br><span class="line"># 虚拟环境安装python包</span><br><span class="line">pip install requests</span><br><span class="line"></span><br><span class="line"># 虚拟环境查看安装包</span><br><span class="line">pip freeze</span><br><span class="line"></span><br><span class="line"># 虚拟环境导出已安装包</span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"># 根据requirements.txt重新安装所有包</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line"># 退出虚拟环境</span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li>编码和字符串<ol>
<li><code>ASCII</code>：1个字节，能表示最大整数是2^8-1&#x3D;255。</li>
<li><code>Unicode</code>：2个字节，能表示最大整数是2^16-1&#x3D;65535。</li>
<li><code>UTF-8</code>：1-6个字节，可变长编码，英文字母1个字节，汉字3个字节，很生僻字符4~6个字节，基于传输存储空间节约角度。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Python 3版本中，字符串是以Unicode编码的</span><br><span class="line"></span><br><span class="line"># 字符对应的整数</span><br><span class="line">ord(&#x27;A&#x27;)</span><br><span class="line"></span><br><span class="line"># 整数对应的字符</span><br><span class="line">chr(66)</span><br><span class="line"></span><br><span class="line"># 二进制</span><br><span class="line">x = b&#x27;ABC&#x27;</span><br><span class="line"></span><br><span class="line"># str转ascii(bytes)</span><br><span class="line">&#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)</span><br><span class="line"></span><br><span class="line"># str转utf-8(bytes)</span><br><span class="line">&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line"># bytes转str，用errors忽略无法解码的字节</span><br><span class="line">b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)</span><br><span class="line">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)</span><br><span class="line"></span><br><span class="line"># 格式化字符串三种方式</span><br><span class="line">str1 = &#x27;Age: %s. Gender: %s, rate: %.2f&#x27; % (25, True, 6.186)</span><br><span class="line">str2 = &#x27;Age: &#123;0&#125;. Gender: &#123;1&#125;, rate: &#123;2:.2f&#125;&#x27;.format(25, True, 6.186)</span><br><span class="line">rate=6.186</span><br><span class="line">str3 = f&#x27;Age: &#123;25&#125;. Gender: &#123;True&#125;, rate: &#123;rate:.2f&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>list和tuple <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># list 可变，如下方法</span><br><span class="line">append(元素)</span><br><span class="line">insert(位置, 元素)</span><br><span class="line">pop()  # 弹出最后一个</span><br><span class="line">pop(0)  # 弹出第一个</span><br><span class="line"></span><br><span class="line"># tuple 指向不可变</span><br><span class="line">t = (1,)  # tuple定义一个元素</span><br></pre></td></tr></table></figure></li>
<li>dict和set <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dict 删除</span><br><span class="line">A = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125;</span><br><span class="line">A.pop(&#x27;c&#x27;, None)  # key不存在不报错</span><br><span class="line"></span><br><span class="line"># set 删除</span><br><span class="line">A = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;</span><br><span class="line">A.remove(&#x27;d&#x27;)  # key不存在报错</span><br><span class="line">A.discard(&#x27;d&#x27;)  # key不存在不报错</span><br><span class="line"></span><br><span class="line"># set 交集、并集、差集</span><br><span class="line">&amp;、|、-</span><br></pre></td></tr></table></figure></li>
<li>生成器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成器1-()</span><br><span class="line">g = (x * x for x in range(10))</span><br><span class="line"></span><br><span class="line"># 迭代</span><br><span class="line">next(g)</span><br><span class="line"># 或</span><br><span class="line">for x in g:</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"># e.g. 斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：</span><br><span class="line">def fibonacci(N):</span><br><span class="line">    a, b, n = 0, 1, 0</span><br><span class="line">    while n &lt; N:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n += 1</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"># 生成器2-yield</span><br><span class="line">def fibonacci(N):</span><br><span class="line">    a, b, n = 0, 1, 0</span><br><span class="line">    while n &lt; N:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n += 1</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ol>
<li>高阶函数-map&#x2F;reduce&#x2F;filter&#x2F;sorted<ol>
<li>map <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map(func, iterable)</span><br><span class="line"></span><br><span class="line"># e.g.</span><br><span class="line">list(map(str, [1, 2, 3, 4]))</span><br></pre></td></tr></table></figure></li>
<li>reduce <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reduce(func, iterable)</span><br><span class="line"></span><br><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br><span class="line"></span><br><span class="line"># e.g. 正整数字符串转正整数</span><br><span class="line">from functools import reduce</span><br><span class="line">def str2int(s):</span><br><span class="line">    return reduce(lambda x, y: x * 10 + y, map(lambda x: ord(x) - ord(&#x27;0&#x27;), s))</span><br></pre></td></tr></table></figure></li>
<li>filter <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter(func, iterable)</span><br><span class="line"></span><br><span class="line"># e.g. 保留list中的奇数</span><br><span class="line">list(filter(lambda x: x % 2 == 1, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"></span><br><span class="line"># e.g. 保留list中的非空字符串</span><br><span class="line">list(filter(lambda x: x and x.strip(), [&#x27;A&#x27;, &#x27;&#x27;, &#x27;B&#x27;, None, &#x27;C&#x27;, &#x27;  &#x27;]))</span><br></pre></td></tr></table></figure></li>
<li>sorted <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sorted(iterable, key=abs)</span><br><span class="line"></span><br><span class="line"># e.g. 绝对值排序</span><br><span class="line">sorted([36, 5, -12, 9, -21], key=abs)</span><br><span class="line"></span><br><span class="line"># e.g. 默认按ascii大小排序</span><br><span class="line">sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;])</span><br><span class="line"># 等价于</span><br><span class="line">sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str)</span><br><span class="line"></span><br><span class="line"># 忽略大小写排序</span><br><span class="line">sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str.lower)</span><br><span class="line"></span><br><span class="line"># 反向排序加参数reverse=True</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>返回函数-返回的是一个函数，闭包<ol>
<li>单个函数返回 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x7f4f9c8c3730&gt;</span><br><span class="line"></span><br><span class="line"># f实际是返回的sum函数定义+参数，调用f()才真正执行</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">25</span><br></pre></td></tr></table></figure></li>
<li>多个函数返回 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    # 循环3次，fs = [func1+i, func2+i, func3+i]</span><br><span class="line">    # 最终返回是把i变成最后迭代完的3</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"># 所以</span><br><span class="line">f1() == f2() == f3() == 9</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>匿名函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = lambda x: x * x</span><br></pre></td></tr></table></figure></li>
<li>装饰器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&#x27;%s %s():&#x27; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@log(&#x27;execute&#x27;)</span><br><span class="line">def now():</span><br><span class="line">    print(&quot;2020-02-02&quot;)</span><br><span class="line"></span><br><span class="line"># 等价于</span><br><span class="line">now = log(&#x27;execute&#x27;)(now)</span><br></pre></td></tr></table></figure></li>
<li>偏函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把一个函数的某些参数给固定住</span><br><span class="line">import functools</span><br><span class="line">func_new = functools.partial(func, *args, **kw)</span><br><span class="line"></span><br><span class="line"># 自动替换默认参数的值</span><br><span class="line">func_new = functools.partial(func, args1=默认值)</span><br><span class="line"></span><br><span class="line"># 将默认值放在函数最左边</span><br><span class="line">func_new = functools.partial(func, 默认值)</span><br><span class="line"></span><br><span class="line"># 参数展开</span><br><span class="line">func_new = functools.partial(func, &#123;arg1:默认值&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol>
<li>结构 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mycompany  # 包名</span><br><span class="line">├─ __init__.py  # 有这个文件才是包目录，本身就是模块，模块名是mycompany</span><br><span class="line">├─ abc.py  # 模块名是文件名mycompany.abc</span><br><span class="line">└─ xyz.py  # 模块名是mycompanyxyz</span><br></pre></td></tr></table></figure></li>
<li>使用<br> 当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure></li>
<li>安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ol>
<li>类和实例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    </span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score  # 私有变量，不能直接访问</span><br><span class="line">            </span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if 0 &lt;= score &lt;= 100:</span><br><span class="line">            self.__score = score</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#x27;bad score&#x27;)</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    def get_grade(self):</span><br><span class="line">        if self.__score &gt;= 90:</span><br><span class="line">            return &#x27;A&#x27;</span><br><span class="line">        elif self.__score &gt;= 60:</span><br><span class="line">            return &#x27;B&#x27;</span><br><span class="line">        else:</span><br><span class="line">            return &#x27;C&#x27;</span><br><span class="line"></span><br><span class="line">stu1 = Student(&#x27;jesonlin&#x27;, 99)</span><br></pre></td></tr></table></figure></li>
<li>继承和多态<ol>
<li>类的定义<br> 当我们定义一个class的时候，我们实际上就定义了一种数据类型。</li>
<li>继承<br> 子类继承父类的全部功能，同名功能则覆盖父类功能。</li>
<li>多态<br> 同名功能则覆盖父类功能，父类参数可用子类实例。</li>
<li>开闭原则<br> 对扩展开放，允许增加子类；对修改封闭，不需要修改父类函数，只需要修改新增子类函数。有点动态绑定意思。</li>
<li>鸭子类型<br> 静态语言的父类参数对象必须是父类实例或者子类实例；而动态语言则只要子类有对应方法即可，不一定要求是继承自该父类。这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</li>
</ol>
</li>
<li>类型判断 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isinstance([1, 2, 3], list)</span><br><span class="line">isinstance((1, 2, 3), (list, tuple))</span><br><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">person = Person()</span><br><span class="line">isinstance(person, Person)</span><br></pre></td></tr></table></figure></li>
<li>属性&#x2F;方法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取所有属性和方法</span><br><span class="line">dir(&#x27;ABC&#x27;)</span><br><span class="line"></span><br><span class="line"># __xxx__的属性和方法在Python中都是有特殊用途的</span><br><span class="line">len(&#x27;ABC&#x27;) == &#x27;ABC&#x27;.__len__()</span><br><span class="line"></span><br><span class="line"># 判断属性或方法</span><br><span class="line">hasattr(person, &#x27;x&#x27;)</span><br><span class="line"></span><br><span class="line"># 获取属性或方法</span><br><span class="line">getattr(person, &#x27;z&#x27;, &#x27;不存在&#x27;)</span><br><span class="line"></span><br><span class="line"># 设置属性</span><br><span class="line">setattr(person, &#x27;y&#x27;)</span><br><span class="line"></span><br><span class="line"># 定义方法</span><br><span class="line">def set_name(self, name):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line"># 设置类方法</span><br><span class="line">Person.set_name = set_name</span><br><span class="line"></span><br><span class="line"># 设置实例方法</span><br><span class="line">from types import MethodType</span><br><span class="line">person.set_name = MethodType(set_name, person)</span><br><span class="line"></span><br><span class="line"># 限制类属性-仅对当前类实例起作用，子类不起左右，即子类没有继承__slots__</span><br><span class="line">class Student(object):</span><br><span class="line">    # 用tuple定义允许绑定的属性名称</span><br><span class="line">    __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;)</span><br><span class="line"></span><br><span class="line"># 方法用属性方式调用，@property</span><br><span class="line"> def Student(object):</span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&#x27;score must be an integer!&#x27;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&#x27;score must between 0 ~ 100!&#x27;)</span><br><span class="line">        self._score = value</span><br><span class="line">s = Student()</span><br><span class="line">s.score = 99  # 实际转换为s.set_score(99)</span><br><span class="line">s.score  # 实际转换为s.get_score()</span><br></pre></td></tr></table></figure></li>
<li>多重继承<br> 若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索。即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li>
<li>定制类 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 限制当前类对象属性</span><br><span class="line">__slots__</span><br><span class="line"></span><br><span class="line"># 作用len(实例)</span><br><span class="line">__len__()</span><br><span class="line"></span><br><span class="line"># print打印类</span><br><span class="line">__str__()</span><br><span class="line"></span><br><span class="line"># 直接打印类</span><br><span class="line">__repr__()</span><br><span class="line"></span><br><span class="line"># 类似列表迭代</span><br><span class="line">__iter__()</span><br><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        return self.a # 返回下一个值</span><br><span class="line">for n in Fib():</span><br><span class="line">    print(n)</span><br><span class="line">    </span><br><span class="line"># 类似列表取值</span><br><span class="line">__getitem__()</span><br><span class="line">class Fib(object):</span><br><span class="line">def __getitem__(self, n):</span><br><span class="line">    a, b = 1, 1</span><br><span class="line">    for x in range(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    return a</span><br><span class="line">f = Fib()</span><br><span class="line">f[1]</span><br><span class="line"></span><br><span class="line"># 类似列表切片</span><br><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        if isinstance(n, int): # n是索引</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            for x in range(n):</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return a</span><br><span class="line">        if isinstance(n, slice): # n是切片</span><br><span class="line">            start = n.start</span><br><span class="line">            stop = n.stop</span><br><span class="line">            if start is None:</span><br><span class="line">                start = 0</span><br><span class="line">            a, b = 1, 1</span><br><span class="line">            L = []</span><br><span class="line">            for x in range(stop):</span><br><span class="line">                if x &gt;= start:</span><br><span class="line">                    L.append(a)</span><br><span class="line">                a, b = b, a + b</span><br><span class="line">            return </span><br><span class="line">f = Fib()</span><br><span class="line">f[0:5]</span><br></pre></td></tr></table></figure></li>
<li>枚举类 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line"># Month类继承Enum，有()成员属性，mth是类实例</span><br><span class="line">mth = Enum(&#x27;Month&#x27;, (&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;))</span><br><span class="line"># value属性则是自动赋给成员的int常量，默认从1开始计数。</span><br><span class="line">for name, member in mth.__members__.items():</span><br><span class="line">    print(name, &#x27;=&gt;&#x27;, member, &#x27;,&#x27;, member.value)</span><br><span class="line"></span><br><span class="line">@unique  # 装饰器可以帮助我们检查保证没有重复值。</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br><span class="line"></span><br><span class="line">Weekday.Sun == Weekday[&#x27;Sun&#x27;]</span><br><span class="line">&lt;Weekday.Sun: 0&gt;  # 返回形式</span><br><span class="line">Weekday.Sun.value</span><br><span class="line">0  # 返回形式</span><br><span class="line">for name, member in Weekday.__members__.items():</span><br><span class="line">    print(name, &#x27;=&gt;&#x27;, member)</span><br><span class="line">for name, member in Weekday.__members__.items():</span><br><span class="line">    print(name, &#x27;=&gt;&#x27;, member.value)</span><br></pre></td></tr></table></figure></li>
<li>元类 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># class的type类型就是type</span><br><span class="line">type(Person)</span><br><span class="line"></span><br><span class="line"># 通过type创建Hello类</span><br><span class="line"># 类名，父类的元组形式，方法名称与函数绑定</span><br><span class="line">Hello = type(&#x27;Hello&#x27;, (object,), dict(hello=fn)) # 创建Hello class</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="IO-编程"><a href="#IO-编程" class="headerlink" title="IO 编程"></a>IO 编程</h2><ol>
<li>文件读写 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 读取utf-8文本文件</span><br><span class="line">with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">    # 打印全部</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line">    # 按行打印</span><br><span class="line">    for line in f.readlines():</span><br><span class="line">        print(line.strip()) # 把末尾的&#x27;\n&#x27;删掉</span><br><span class="line"></span><br><span class="line"># 读取二进制文件如图片、视频</span><br><span class="line">with open(&#x27;/path/to/file&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line"># 非UTF-8编码的文本文件</span><br><span class="line">with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;, errors=&#x27;ignore&#x27;) as f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line"># 写入文件，追加用&#x27;a&#x27;</span><br><span class="line">with open(&#x27;/path/to/file&#x27;, &#x27;w&#x27;, encoding=&#x27;UTF-8&#x27;) as f:</span><br><span class="line">    f.write(&#x27;Hello, world!&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>内存读写 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from io import StringIO</span><br><span class="line">f = StringIO()</span><br><span class="line">f.write(&#x27;hello&#x27;)  # 返回5</span><br><span class="line">f.write(&#x27; &#x27;)  # 返回1</span><br><span class="line">f.write(&#x27;world!&#x27;)  # 返回6</span><br><span class="line">print(f.getvalue())  # 返回hello world!</span><br><span class="line"></span><br><span class="line">from io import BytesIO</span><br><span class="line">f = BytesIO()</span><br><span class="line">f.write(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))  # 返回6表示6个字节</span><br><span class="line">print(f.getvalue())  # 返回b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br></pre></td></tr></table></figure></li>
<li>操作文件和目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">os.name  # 操作系统类型</span><br><span class="line">os.uname  # 详细的系统信息</span><br><span class="line">os.environ  # 环境变量</span><br><span class="line">os.environ.get(&#x27;PATH&#x27;)</span><br><span class="line"></span><br><span class="line">os.path.abspath(&#x27;.&#x27;)  # 查看当前目录的绝对路径</span><br><span class="line">os.path.join(&#x27;/Users/michael&#x27;, &#x27;testdir&#x27;)  # 合并路径</span><br><span class="line">os.mkdir(&#x27;/Users/michael/testdir&#x27;)  # 创建目录</span><br><span class="line">os.rmdir(&#x27;/Users/michael/testdir&#x27;)  # 删除目录</span><br><span class="line">os.path.split(&#x27;/Users/michael/testdir/file.txt&#x27;)  # 拆分路径</span><br><span class="line">os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;)  # 重命名文件</span><br><span class="line">os.remove(&#x27;test.py&#x27;)  # 删除文件</span><br><span class="line"></span><br><span class="line"># shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。</span><br><span class="line"></span><br><span class="line"># 列出当前所有目录</span><br><span class="line">[x for x in os.listdir(&#x27;.&#x27;) if os.path.isdir(x)]</span><br></pre></td></tr></table></figure></li>
<li>序列化<ol>
<li>pickle-只能在同版本python <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pickle</span><br><span class="line">d = dict(name=&#x27;jesonlin&#x27;, age=30, score=99)</span><br><span class="line"></span><br><span class="line"># 序列化</span><br><span class="line"># 任意对象序列化成一个bytes，然后写入文件</span><br><span class="line">dd = pickle.dumps(d)</span><br><span class="line"># 或者直接序列化写入一个-file-like object</span><br><span class="line">with open(&#x27;dump.txt&#x27;, &#x27;wb&#x27;) as f:</span><br><span class="line">    pickle.dump(d, f)</span><br><span class="line"></span><br><span class="line"># 反序列化</span><br><span class="line">ddd = pickle.loads(dd)</span><br><span class="line"># 或者直接从文件反序列化</span><br><span class="line">with open(&#x27;dump.txt&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    ddd = pickle.load(f)</span><br></pre></td></tr></table></figure></li>
<li>json-跨语言传递对象 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">d = dict(name=&#x27;jesonlin&#x27;, age=30, score=99)</span><br><span class="line"></span><br><span class="line"># 序列化</span><br><span class="line">dd = json.dumps(d)</span><br><span class="line"># 反序列化</span><br><span class="line">ddd = json.loads(dd)</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, age, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line">stu = Student(&#x27;jesonlin&#x27;, 30, 99)</span><br><span class="line"></span><br><span class="line"># 类对象序列化，无法直接序列化，可自定义使用转换函数转换为字典</span><br><span class="line">def stu2dict(stu):</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x27;name&#x27;: stu.name,</span><br><span class="line">        &#x27;age&#x27;: stu.age,</span><br><span class="line">        &#x27;score&#x27;: stu.score</span><br><span class="line">    &#125;</span><br><span class="line">dd = json.dumps(stu, default=stu2dict)</span><br><span class="line"># 通用的</span><br><span class="line">dd = json.dumps(stu, default=lambda obj: obj.__dict__)</span><br><span class="line"></span><br><span class="line"># 类对象反序列</span><br><span class="line">def dict2stu(d):</span><br><span class="line">    return Student(d[&#x27;name&#x27;], d[&#x27;age&#x27;], d[&#x27;score&#x27;])</span><br><span class="line">json.loads(dd, object_hook=dict2stu)</span><br><span class="line"># 通用的</span><br><span class="line">json.loads(dd, object_hook=lambda obj: Student(**obj))</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ol start="0">
<li>进程 vs. 线程<ol>
<li>进程<ol>
<li>优点：稳定性高，一个子进程挂了不影响其他进程；</li>
<li>缺点：效率低，创建和调度进程开销大，进程数有限；</li>
</ol>
</li>
<li>线程<ol>
<li>优点：效率高，创建和调度线程开销较小；</li>
<li>缺点：稳定性低，一个线程挂了可能导致整个进程崩溃，因为所有线程共享进程内存。</li>
</ol>
</li>
</ol>
</li>
<li>fork<br> Unix&#x2F;Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">print(&#x27;process (%s) start...&#x27; % os.getpid())</span><br><span class="line"></span><br><span class="line"># Only works on Unix/Linux/Mac:</span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&#x27;I am child process (%s) and my parent is %s.&#x27; % (os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;I (%s) just created a child process (%s).&#x27; % (os.getpid(), pid))</span><br></pre></td></tr></table></figure></li>
<li>进程<ol>
<li>单个进程-Process <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">import os, time</span><br><span class="line"></span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&#x27;Begin run child process %s (%s)...&#x27; % (name, os.getpid()))</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&#x27;End run child process %s (%s)...&#x27; % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;Parent process %s.&#x27; % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(&#x27;test&#x27;,))</span><br><span class="line">    print(&#x27;Child process will start.&#x27;)</span><br><span class="line">    p.start()  # 开始执行子进程</span><br><span class="line">    p.join()  # 等待子进程结束后再继续往下运行，通常用于进程间的同步</span><br><span class="line">    print(&#x27;Child process end.&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>进程池-Pool <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line">def long_time_task(name):</span><br><span class="line">    print(&#x27;Run task %s (%s)...&#x27; % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&#x27;Task %s runs %0.2f seconds.&#x27; % (name, (end - start)))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    print(&#x27;Parent process %s.&#x27; % os.getpid())</span><br><span class="line">    p = Pool(4)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        # 立刻执行，无需等待，异步非阻塞</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(&#x27;Waiting for all subprocesses done...&#x27;)</span><br><span class="line">    p.close()  # 调用close()之后就不能继续添加新的Process了</span><br><span class="line">    p.join()  # 等待所有子进程执行完毕</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&#x27;All subprocesses done.&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>子进程-subprocess <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line"># 直接调用命令</span><br><span class="line">print(&#x27;$ nslookup www.python.org&#x27;)</span><br><span class="line">subprocess.call([&#x27;nslookup&#x27;, &#x27;www.python.org&#x27;])</span><br><span class="line">print(&#x27;Exit code: %s&#x27; % r)</span><br><span class="line"></span><br><span class="line"># 交互调用命令</span><br><span class="line">print(&#x27;$ nslookup&#x27;)</span><br><span class="line">p = subprocess.Popen([&#x27;nslookup&#x27;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(b&#x27;set q=mx\npython.org\nexit\n&#x27;)</span><br><span class="line">print(output.decode(&#x27;utf-8&#x27;))</span><br><span class="line">print(&#x27;Exit code: %s&#x27; % p.returncode)</span><br></pre></td></tr></table></figure></li>
<li>进程间通信 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line"># 写数据进程执行的代码:</span><br><span class="line">def write(q):</span><br><span class="line">    print(&#x27;Process to write: %s&#x27; % os.getpid())</span><br><span class="line">    for value in [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]:</span><br><span class="line">        print(&#x27;Put %s to queue...&#x27; % value)</span><br><span class="line">        q.put(value)  # 队列写入</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"># 读数据进程执行的代码:</span><br><span class="line">def read(q):</span><br><span class="line">    print(&#x27;Process to read: %s&#x27; % os.getpid())</span><br><span class="line">    while True:</span><br><span class="line">        value = q.get(True)  # 队列读出</span><br><span class="line">        print(&#x27;Get %s from queue.&#x27; % value)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # 父进程创建Queue，并传给各个子进程：</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    # 启动子进程pw，写入:</span><br><span class="line">    pw.start()</span><br><span class="line">    # 启动子进程pr，读取:</span><br><span class="line">    pr.start()</span><br><span class="line">    # 等待pw结束:</span><br><span class="line">    pw.join()</span><br><span class="line">    # pr进程里是死循环，无法等待其结束，只能强行终止:</span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>线程<br> 多线程中，所有变量都由所有线程共享<ol start="0">
<li>模块<br> Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</li>
<li>启动线程-传入函数，创建Thread实例，调用start()开始执行： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def loop():</span><br><span class="line">    print(&#x27;thread %s is running...&#x27; % threading.current_thread().name)</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&#x27;thread %s &gt;&gt;&gt; %s&#x27; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&#x27;thread %s ended.&#x27; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&#x27;thread %s is running...&#x27; % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=&#x27;LoopThread&#x27;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&#x27;thread %s ended.&#x27; % threading.current_thread().name)</span><br></pre></td></tr></table></figure></li>
<li>锁 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 假定这是你的银行存款:</span><br><span class="line">balance = 0</span><br><span class="line"># 锁</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def change_it(n):</span><br><span class="line">    # 先存后取，结果应该为0:</span><br><span class="line">    global balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(2000000):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=run_thread, args=(5,))</span><br><span class="line">t2 = threading.Thread(target=run_thread, args=(8,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(balance)</span><br></pre></td></tr></table></figure></li>
<li>GIL锁<br> Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。<br> Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</li>
<li>threading.local()-解决了参数在一个线程中各个函数之间互相传递的问题。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建全局ThreadLocal对象</span><br><span class="line"># 全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。</span><br><span class="line"># 可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。</span><br><span class="line"># ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line">def process_student():</span><br><span class="line">    # 获取当前线程关联的student:</span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(&#x27;Hello, %s (in %s)&#x27; % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">def process_thread(name):</span><br><span class="line">    # 绑定ThreadLocal的student:</span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=process_thread, args=(&#x27;A&#x27;,), name=&#x27;Thread-A&#x27;)</span><br><span class="line">t2 = threading.Thread(target=process_thread, args=(&#x27;B&#x27;,), name=&#x27;Thread-B&#x27;)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>分布式进程<ol>
<li>生成任务，放入任务队列，等待从结果队列取结果 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random, time, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 发送任务的队列:</span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"># 接收结果的队列:</span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line"># 从BaseManager继承的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span><br><span class="line">QueueManager.register(&#x27;get_task_queue&#x27;, callable=lambda: task_queue)</span><br><span class="line">QueueManager.register(&#x27;get_result_queue&#x27;, callable=lambda: result_queue)</span><br><span class="line"># 绑定端口5000, 设置验证码&#x27;abc&#x27;:</span><br><span class="line">manager = QueueManager(address=(&#x27;&#x27;, 5000), authkey=b&#x27;abc&#x27;)</span><br><span class="line"># 启动Queue:</span><br><span class="line">manager.start()</span><br><span class="line"># 获得通过网络访问的Queue对象:</span><br><span class="line">task = manager.get_task_queue()</span><br><span class="line">result = manager.get_result_queue()</span><br><span class="line"># 放几个任务进去:</span><br><span class="line">for i in range(10):</span><br><span class="line">    n = random.randint(0, 10000)</span><br><span class="line">    print(&#x27;Put task %d...&#x27; % n)</span><br><span class="line">    task.put(n)</span><br><span class="line"># 从result队列读取结果:</span><br><span class="line">print(&#x27;Try get results...&#x27;)</span><br><span class="line">for i in range(10):</span><br><span class="line">    r = result.get(timeout=10)</span><br><span class="line">    print(&#x27;Result: %s&#x27; % r)</span><br><span class="line"># 关闭:</span><br><span class="line">manager.shutdown()</span><br><span class="line">print(&#x27;master exit.&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>消费任务，从任务队列获取，将结果放入结果队列 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time, sys, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 创建类似的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span><br><span class="line">QueueManager.register(&#x27;get_task_queue&#x27;)</span><br><span class="line">QueueManager.register(&#x27;get_result_queue&#x27;)</span><br><span class="line"></span><br><span class="line"># 连接到服务器，也就是运行task_master.py的机器:</span><br><span class="line">server_addr = &#x27;127.0.0.1&#x27;</span><br><span class="line">print(&#x27;Connect to server %s...&#x27; % server_addr)</span><br><span class="line"># 端口和验证码注意保持与task_master.py设置的完全一致:</span><br><span class="line">m = QueueManager(address=(server_addr, 5000), authkey=b&#x27;abc&#x27;)</span><br><span class="line"># 从网络连接:</span><br><span class="line">m.connect()</span><br><span class="line"># 获取Queue的对象:</span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"># 从task队列取任务,并把结果写入result队列:</span><br><span class="line">for i in range(10):</span><br><span class="line">    try:</span><br><span class="line">        n = task.get(timeout=1)</span><br><span class="line">        print(&#x27;run task %d * %d...&#x27; % (n, n))</span><br><span class="line">        r = &#x27;%d * %d = %d&#x27; % (n, n, n*n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        result.put(r)</span><br><span class="line">    except Queue.Empty:</span><br><span class="line">        print(&#x27;task queue is empty.&#x27;)</span><br><span class="line"># 处理结束:</span><br><span class="line">print(&#x27;worker exit.&#x27;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ol>
<li>正则表达式规则<ol>
<li>如果直接给出字符，就是精确匹配。用 <code>\d</code> 可以匹配一个数字，<code>\w</code> 可以匹配一个字母或数字。</li>
<li><code>.</code> 匹配任意字符</li>
<li><code>*</code> 匹配任意个字符（包括0个）</li>
<li><code>+</code> 匹配至少一个字符</li>
<li><code>?</code> 匹配0个或1个字符</li>
<li><code>\s</code> 匹配一个空格</li>
<li><code>&#123;n&#125;</code> 匹配那个字符</li>
<li><code>&#123;n-m&#125;</code> 匹配n-m个前面字符<br> <code>\d&#123;3&#125;\s+\d&#123;3,8&#125;</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d&#123;3&#125; 表示匹配3个数字</span><br><span class="line">\s+   表示匹配至少一个空格</span><br><span class="line">\d&#123;3,8&#125; 表示匹配3-8个数字</span><br></pre></td></tr></table></figure></li>
<li><code>[]</code> 表示范围 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0-9a-zA-Z\_]+ 可以匹配至少由一个数字、字母或者下划线组成的字符串；</span><br><span class="line">[a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</span><br><span class="line">[a-zA-Z\_][0-9a-zA-Z\_]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）；</span><br></pre></td></tr></table></figure></li>
<li><code>A|B</code> 表示匹配A或B，所以 <code>(P|p)ython</code> 可以匹配 <code>&#39;Python&#39;</code> 或者 <code>&#39;python&#39;</code></li>
<li><code>^</code> 表示行的开头，<code>^\d</code> 表示必须以数字开头</li>
<li><code>$</code> 表示行的结尾，<code>\d$</code> 表示结尾必须以数字结束</li>
</ol>
</li>
<li>re 模块<ol>
<li>python 也使用 <code>\</code> 转义 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;ABC\\-001&#x27; # Python的字符串</span><br><span class="line"># 对应的正则表达式字符串变成：</span><br><span class="line"># &#x27;ABC\-001&#x27;</span><br><span class="line"></span><br><span class="line"># 建议使用Python的r前缀，就不用考虑转义的问题了</span><br><span class="line">s = r&#x27;ABC\-001&#x27; # Python的字符串</span><br><span class="line"># 对应的正则表达式字符串不变：</span><br><span class="line"># &#x27;ABC\-001&#x27;</span><br></pre></td></tr></table></figure></li>
<li>match-是否匹配 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"># 匹配成功</span><br><span class="line">re.match(r&#x27;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x27;, &#x27;010-12345&#x27;)</span><br><span class="line"># 匹配成功返回如下</span><br><span class="line">&lt;_sre.SRE_Match object at 0x7f3d6a6017e8&gt;</span><br><span class="line"># 匹配失败返回None</span><br><span class="line">re.match(r&#x27;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x27;, &#x27;010 12345&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>split-切分字符串 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;a b   c&#x27;.split(&#x27; &#x27;)</span><br><span class="line"># 无法失败联系的空格</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;c&#x27;]</span><br><span class="line"></span><br><span class="line"># 正则切割包含连续空格串</span><br><span class="line">&gt;&gt;&gt; re.split(r&#x27;\s+&#x27;, &#x27;a b   c&#x27;)</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line"></span><br><span class="line"># 正则切割包含联系空格和逗号串</span><br><span class="line">&gt;&gt;&gt; re.split(r&#x27;[\s\,]+&#x27;, &#x27;a,b, c  d&#x27;)</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><ol>
<li>asyncio <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def wget(host):</span><br><span class="line">    print(&#x27;wget %s...&#x27; % host)</span><br><span class="line">    connect = asyncio.open_connection(host, 80)</span><br><span class="line">    reader, writer = yield from connect</span><br><span class="line">    header = &#x27;GET / HTTP/1.0\r\nHost: %s\r\n\r\n&#x27; % host</span><br><span class="line">    writer.write(header.encode(&#x27;utf-8&#x27;))</span><br><span class="line">    yield from writer.drain()</span><br><span class="line">    while True:</span><br><span class="line">        line = yield from reader.readline()</span><br><span class="line">        if line == b&#x27;\r\n&#x27;:</span><br><span class="line">            break</span><br><span class="line">        print(&#x27;%s header &gt; %s&#x27; % (host, line.decode(&#x27;utf-8&#x27;).rstrip()))</span><br><span class="line">    # Ignore the body, close the socket</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [wget(host) for host in [&#x27;www.sina.com.cn&#x27;, &#x27;www.sohu.com&#x27;, &#x27;www.163.com&#x27;]]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></li>
<li>python3.5以上新写法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    r = yield from asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br><span class="line"></span><br><span class="line"># 新写法</span><br><span class="line">async def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    r = await asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.python.org/">官网</a><br><a href="https://pythonguidecn.readthedocs.io/zh/latest/">Python最佳实践指南</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰-python教程</a><br><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/">谷歌-python风格指南</a><br><a href="https://httpbin.org/">简单的http请求和响应服务</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-持久化</title>
    <url>/%E5%AD%98%E5%82%A8/redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>Redis 共有两种持久化技术，分别是 AOF 日志和 RDB 快照（默认）。</p>
<span id="more"></span>


<h1 id="AOF-Append-Only-File-日志"><a href="#AOF-Append-Only-File-日志" class="headerlink" title="AOF(Append Only File) 日志"></a>AOF(Append Only File) 日志</h1><img src="./AOF日志.webp" width = "50%" height = "50%" alt="AOF日志" align=center />

<p>只会记录写操作命令，读操作命令是不会被记录的</p>
<h2 id="开启和关闭"><a href="#开启和关闭" class="headerlink" title="开启和关闭"></a>开启和关闭</h2><p>默认是不开启的，需要我们修改 redis.conf 配置文件中的以下参数<br><img src="./AOF开启.webp" width = "50%" height = "50%" alt="AOF开启" align=center /></p>
<h2 id="日志规则"><a href="#日志规则" class="headerlink" title="日志规则"></a>日志规则</h2><img src="./AOF日志规则.webp" width = "50%" height = "50%" alt="AOF日志规则" align=center />

<h2 id="先执行后日志"><a href="#先执行后日志" class="headerlink" title="先执行后日志"></a>先执行后日志</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>避免额外的检查开销<br> 先执行操作命令，成功后（无语法问题）再记录到AOF日志里。</li>
<li>不会阻塞当前写操作命令的执行<br> 写操作成功后才记录到AOF日志</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><p>丢失风险<br> 执行写操作和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</p>
</li>
<li><p>可能会给「下一个」命令带来阻塞风险。<br> 因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作是同步的。</p>
<p> 如果在将日志内容写入到硬盘时，服务器的硬盘的 I&#x2F;O 压力太大，就会导致写硬盘的速度很慢，进而阻塞住了，也就会导致后续的命令无法执行。</p>
</li>
</ol>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><ol>
<li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。<br>在 redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填<br><img src="./AOF写回策略.webp" width = "50%" height = "50%" alt="AOF写回策略" align=center /></p>
<h3 id="AOF-重写机制（后台子进程）"><a href="#AOF-重写机制（后台子进程）" class="headerlink" title="AOF 重写机制（后台子进程）"></a>AOF 重写机制（后台子进程）</h3><p>Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>Redis 的重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的</p>
<pre><code>1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；
2. 子进程带有主进程的数据副本（数据副本怎么产生的后面会说），这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。
</code></pre>
<p>子进程是怎么拥有主进程一样的数据副本的呢？<br><img src="./AOF父子进程写时复制.webp" width = "50%" height = "50%" alt="AOF父子进程写时复制" align=center /></p>
<pre><code>主进程在通过 fork 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「页表」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。

当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发写保护中断，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作，这个过程被称为「写时复制(Copy On Write)」。
</code></pre>
<p>所以，有两个阶段会导致阻塞父进程：</p>
<pre><code>1. 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；
2. 创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；
</code></pre>
<p>重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p>
<p>为了解决这种数据不一致问题，Redis 设置了一个 AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。<br><img src="./AOF重写缓冲区.webp" width = "50%" height = "50%" alt="AOF重写缓冲区" align=center /></p>
<p>当子进程完成 AOF 重写工作（扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<pre><code>1. 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；
2. 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。
</code></pre>
<h1 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB() 快照"></a>RDB() 快照</h1><p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据。</p>
<p>RDB 文件的内容是二进制数据。</p>
<p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p>
<h2 id="快照怎么用"><a href="#快照怎么用" class="headerlink" title="快照怎么用"></a>快照怎么用</h2><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p>
<pre><code>1. 执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程；
2. 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞；
</code></pre>
<p>RDB 文件的加载工作是在服务器启动时自动执行的</p>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p>
<pre><code>save 900 1
save 300 10
save 60 10000
</code></pre>
<p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。<br>只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p>
<pre><code>900 秒之内，对数据库进行了至少 1 次修改；
300 秒之内，对数据库进行了至少 10 次修改；
60 秒之内，对数据库进行了至少 10000 次修改。
</code></pre>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p>执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
</li>
<li><p>通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。</p>
</li>
<li><p>这就是 RDB 快照的缺点，在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能。而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少。</p>
</li>
</ol>
<h2 id="执行快照时，数据能被修改吗？"><a href="#执行快照时，数据能被修改吗？" class="headerlink" title="执行快照时，数据能被修改吗？"></a>执行快照时，数据能被修改吗？</h2><p>执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，也就是数据是能被修改的。</p>
<p>那具体如何做到到呢？关键的技术就在于写时复制技术（Copy-On-Write, COW）。</p>
<p>bgsave 快照过程中，如果主线程修改了共享数据，发生了写时复制后，RDB 快照保存的是原本的内存数据，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。 </p>
<p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程（父进程）的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p>
<p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。</p>
<p>那么极端情况下，如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍。</p>
<h2 id="RDB-和-AOF-合体"><a href="#RDB-和-AOF-合体" class="headerlink" title="RDB 和 AOF 合体"></a>RDB 和 AOF 合体</h2><p>那有没有什么方法不仅有 RDB 恢复速度快的优点和，又有 AOF 丢失数据少的优点呢？</p>
<p>当然有，那就是将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫混合使用 AOF 日志和内存快照，也叫混合持久化。</p>
<p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p>
<pre><code>aof-use-rdb-preamble yes
</code></pre>
<p>混合持久化工作在 AOF 日志重写过程。</p>
<pre><code>1. 在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件；
2. 然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件
3. 写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。
</code></pre>
<p>AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。</p>
<pre><code>1. 这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快。
2. 加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得数据更少的丢失。
</code></pre>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://xiaolincoding.com/redis/">图解Redis介绍</a><br><a href="https://try.redis.io/">在线redis环境</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-数据类型</title>
    <url>/%E5%AD%98%E5%82%A8/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Redis 提供了丰富的数据类型，常见的有五种：<br>String（字符串）、List（列表）、Hash（哈希）、Set（集合）、Zset（有序集合）。</p>
<span id="more"></span>
<h1 id="Redis-数据类型对应数据结构"><a href="#Redis-数据类型对应数据结构" class="headerlink" title="Redis 数据类型对应数据结构"></a>Redis 数据类型对应数据结构</h1><img src="./redis数据类型与数据结构.webp" width = "50%" height = "50%" alt="redis数据类型与数据结构" align=center />

<h1 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>String 是最基本的 key-value 结构，，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<p>SDS 相比于 C 的原生字符串：</p>
<pre><code>SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束

SDS 获取字符串长度的时间复杂度是 O(1)。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。

Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。
</code></pre>
<p>字符串对象的内部编码（encoding）有 3 种 ：int、raw和 embstr。<br>    <img src="./string结构.webp" width = "50%" height = "50%" alt="string结构" align=center /></p>
<p>整数值可以用long类型来表示<br>    <img src="./int.webp" width = "50%" height = "50%" alt="int" align=center /></p>
<p>字符申的长度小于等于 44 字节，一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS，所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。<br>    <img src="./embstr.webp" width = "50%" height = "50%" alt="embstr" align=center /></p>
<p>字符申的长度大于 44 字节，调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS。<br>    <img src="./raw.webp" width = "50%" height = "50%" alt="raw" align=center /></p>
<p> embstr 字符串长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以embstr编码的字符串对象实际上是只读的。对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="普通字符串基本操作"><a href="#普通字符串基本操作" class="headerlink" title="普通字符串基本操作"></a>普通字符串基本操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> name lin</span><br><span class="line">OK</span><br><span class="line"># 根据 key 获得对应的 <span class="keyword">value</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">GET</span> name</span><br><span class="line">&quot;lin&quot;</span><br><span class="line"># 判断某个 key 是否存在</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">EXISTS</span> name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 返回 key 所储存的字符串值的长度</span><br><span class="line"><span class="operator">&gt;</span> STRLEN name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"># 删除某个 key 对应的值</span><br><span class="line"><span class="operator">&gt;</span> DEL name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="批量设置"><a href="#批量设置" class="headerlink" title="批量设置"></a>批量设置</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 批量设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> MSET key1 value1 key2 value2 </span><br><span class="line">OK</span><br><span class="line"># 批量获取多个 key 对应的 <span class="keyword">value</span></span><br><span class="line"><span class="operator">&gt;</span> MGET key1 key2 </span><br><span class="line"><span class="number">1</span>) &quot;value1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="计数器（字符串的内容为整数的时候可以使用）："><a href="#计数器（字符串的内容为整数的时候可以使用）：" class="headerlink" title="计数器（字符串的内容为整数的时候可以使用）："></a>计数器（字符串的内容为整数的时候可以使用）：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> number <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"># 将 key 中储存的数字值增一</span><br><span class="line"><span class="operator">&gt;</span> INCR number</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 将key中存储的数字值加 <span class="number">10</span></span><br><span class="line"><span class="operator">&gt;</span> INCRBY number <span class="number">10</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">11</span></span><br><span class="line"># 将 key 中储存的数字值减一</span><br><span class="line"><span class="operator">&gt;</span> DECR number</span><br><span class="line">(<span class="type">integer</span>) <span class="number">10</span></span><br><span class="line"># 将key中存储的数字值键 <span class="number">10</span></span><br><span class="line"><span class="operator">&gt;</span> DECRBY number <span class="number">10</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="过期（默认为永不过期）："><a href="#过期（默认为永不过期）：" class="headerlink" title="过期（默认为永不过期）："></a>过期（默认为永不过期）：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置 key 在 <span class="number">60</span> 秒后过期（该方法是针对已经存在的key设置过期时间）</span><br><span class="line"><span class="operator">&gt;</span> EXPIRE name  <span class="number">60</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 查看数据还有多久过期</span><br><span class="line"><span class="operator">&gt;</span> TTL name </span><br><span class="line">(<span class="type">integer</span>) <span class="number">51</span></span><br><span class="line"></span><br><span class="line">#设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值，并设置该key的过期时间为 <span class="number">60</span> 秒</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> key  <span class="keyword">value</span> EX <span class="number">60</span></span><br><span class="line">OK</span><br><span class="line"><span class="operator">&gt;</span> SETEX key  <span class="number">60</span> <span class="keyword">value</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="不存在就插入："><a href="#不存在就插入：" class="headerlink" title="不存在就插入："></a>不存在就插入：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 不存在就插入（<span class="keyword">not</span> <span class="keyword">exists</span>）</span><br><span class="line"><span class="operator">&gt;</span>SETNX key <span class="keyword">value</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>缓存整个对象的 JSON</p>
<pre><code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;
</code></pre>
<p>将 key 进行分离为 user:ID:属性</p>
<pre><code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20
</code></pre>
<h3 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h3><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化文章的阅读量</span><br><span class="line">&gt; SET aritcle:readcount:1001 0</span><br><span class="line">OK</span><br><span class="line">#阅读量+1</span><br><span class="line">&gt; INCR aritcle:readcount:1001</span><br><span class="line">(integer) 1</span><br><span class="line">#阅读量+1</span><br><span class="line"># 获取对应文章的阅读量</span><br><span class="line">&gt; GET aritcle:readcount:1001</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<pre><code>1. 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；
2. 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。
</code></pre>
<p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p>
<pre><code>SET lock_key unique_value NX PX 10000

lock_key 就是 key 键；
unique_value 是客户端生成的唯一的标识；
NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；
PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁
</code></pre>
<p>解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。</p>
<pre><code>// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
</code></pre>
<h3 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h3><p>开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息<br><img src="./Session2.webp" width = "50%" height = "50%" alt="Session2" align=center /></p>
<h1 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。</p>
<p>列表的最大长度为 2^32 - 1，也即每个列表支持超过 40 亿个元素。</p>
<h2 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h2><p>List 类型的底层数据结构是由双向链表或压缩列表实现的：</p>
<pre><code>1. 如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用ziplist（压缩列表）作为 List 类型的底层数据结构；连续内存空间，存储效率高，不利于修改操作，插入和删除操作需要频繁申请和释放内存。


2. 如果列表的元素不满足上面的条件，Redis 会使用双向链表作为 List 类型的底层数据结构，前后指针浪费16字节。其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。
</code></pre>
<p>但是在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。</p>
<img src="./quicklist.webp" width = "50%" height = "50%" alt="quicklist" align=center />

<h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><img src="./list.webp" width = "50%" height = "50%" alt="list" align=center />

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 将一个或多个值<span class="keyword">value</span>插入到key列表的表头(最左边)，最后的值在最前面</span><br><span class="line">LPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...] </span><br><span class="line"># 将一个或多个值<span class="keyword">value</span>插入到key列表的表尾(最右边)</span><br><span class="line">RPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...]</span><br><span class="line"># 移除并返回key列表的头元素</span><br><span class="line">LPOP key     </span><br><span class="line"># 移除并返回key列表的尾元素</span><br><span class="line">RPOP key </span><br><span class="line"></span><br><span class="line"># 返回列表key中指定区间内的元素，区间以偏移量<span class="keyword">start</span>和stop指定，从<span class="number">0</span>开始</span><br><span class="line">LRANGE key <span class="keyword">start</span> stop</span><br><span class="line"></span><br><span class="line"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout<span class="operator">=</span><span class="number">0</span>则一直阻塞</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout<span class="operator">=</span><span class="number">0</span>则一直阻塞</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列在存取消息时，必须要满足三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。</p>
<pre><code>消息保序：使用 LPUSH + RPOP；
阻塞读取：使用 BRPOP；
重复消息处理：生产者自行实现全局唯一 ID；
消息的可靠性：使用 BRPOPLPUSH
</code></pre>
<ol>
<li><p>如何满足消息保序需求？</p>
<p> List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。</p>
<p> Redis提供了 BRPOP 命令。BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。</p>
</li>
</ol>
<img src="./消息队列.webp" width = "50%" height = "50%" alt="消息队列" align=center />

<ol start="2">
<li><p>如何处理重复的消息？</p>
<p> 每个消息都有一个全局的 ID。</p>
<p> 消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。</p>
<p> 但是 List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID</p>
</li>
<li><p>如何保证消息可靠性？</p>
<p> 如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p>
<p> 为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。</p>
</li>
</ol>
<p>List 作为消息队列有什么缺陷？<br>    List 不支持多个消费者消费同一条消息，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费</p>
<h1 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>Hash 是一个键值对（key - value）集合。Hash 特别适合用于存储对象。</p>
<h2 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h2><p>Hash 类型的底层数据结构是由压缩列表或哈希表实现的：</p>
<pre><code>1. 如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用压缩列表作为 Hash 类型的底层数据结构；

2. 如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的 底层数据结构。

3. 在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。
</code></pre>
<h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储一个哈希表key的键值</span><br><span class="line">HSET key field <span class="keyword">value</span>   </span><br><span class="line"># 获取哈希表key对应的field键值</span><br><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line"># 在一个哈希表key中存储多个键值对</span><br><span class="line">HMSET key field <span class="keyword">value</span> [field value...] </span><br><span class="line"># 批量获取哈希表key中多个field键值</span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"># 删除哈希表key中的field键值</span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"></span><br><span class="line"># 返回哈希表key中field的数量</span><br><span class="line">HLEN key       </span><br><span class="line"># 返回哈希表key中所有的键值</span><br><span class="line">HGETALL key </span><br><span class="line"></span><br><span class="line"># 为哈希表key中field键的值加上增量n</span><br><span class="line">HINCRBY key field n                         </span><br></pre></td></tr></table></figure>

<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象-1"><a href="#缓存对象-1" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</p>
<p>我们可以使用如下命令，将用户对象的信息存储到 Hash 类型：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 存储一个哈希表uid:<span class="number">1</span>的键值</span><br><span class="line"><span class="operator">&gt;</span> HMSET uid:<span class="number">1</span> name Tom age <span class="number">15</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"># 存储一个哈希表uid:<span class="number">2</span>的键值</span><br><span class="line"><span class="operator">&gt;</span> HMSET uid:<span class="number">2</span> name Jerry age <span class="number">13</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"># 获取哈希表用户id为<span class="number">1</span>中所有的键值</span><br><span class="line"><span class="operator">&gt;</span> HGETALL uid:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Tom&quot;</span><br><span class="line"><span class="number">3</span>) &quot;age&quot;</span><br><span class="line"><span class="number">4</span>) &quot;15&quot;</span><br></pre></td></tr></table></figure>

<h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p>以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素，如下图所示。</p>
<img src="./购物车.webp" width = "50%" height = "50%" alt="购物车" align=center />

<p>涉及的命令如下：</p>
<pre><code>添加商品：HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1
添加数量：HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1
商品总数：HLEN cart:&#123;用户id&#125;
删除商品：HDEL cart:&#123;用户id&#125; &#123;商品id&#125;
获取购物车所有商品：HGETALL cart:&#123;用户id&#125;
</code></pre>
<h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>一个集合最多可以存储 2^32-1 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<h2 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h2><p>Set 类型的底层数据结构是由哈希表或整数集合实现的：</p>
<pre><code>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；

如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。
</code></pre>
<h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li>常用操作<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span><br><span class="line">SADD key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br><span class="line"># 从集合key中删除元素</span><br><span class="line">SREM key <span class="keyword">member</span> [<span class="keyword">member</span> ...] </span><br><span class="line"># 获取集合key中所有元素</span><br><span class="line">SMEMBERS key</span><br><span class="line"># 获取集合key中的元素个数</span><br><span class="line">SCARD key</span><br><span class="line"></span><br><span class="line"># 判断<span class="keyword">member</span>元素是否存在于集合key中</span><br><span class="line">SISMEMBER key <span class="keyword">member</span></span><br><span class="line"></span><br><span class="line"># 从集合key中随机选出count个元素，元素不从key中删除</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"># 从集合key中随机选出count个元素，元素从key中删除</span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure></li>
<li>运算操作<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 交集运算</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"># 将交集结果存入新集合destination中</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 并集运算</span><br><span class="line">SUNION key [key ...]</span><br><span class="line"># 将并集结果存入新集合destination中</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 差集运算</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"># 将差集结果存入新集合destination中</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p>这里有一个潜在的风险。Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计</p>
<h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p>
<p>uid:1 、uid:2、uid:3 三个用户分别对 article:1 文章点赞了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># uid:<span class="number">1</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># uid:<span class="number">2</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># uid:<span class="number">3</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">3</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># uid:<span class="number">1</span> 取消了对 article:<span class="number">1</span> 文章点赞。</span><br><span class="line"><span class="operator">&gt;</span> SREM article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 获取 article:<span class="number">1</span> 文章所有点赞用户 :</span><br><span class="line"><span class="operator">&gt;</span> SMEMBERS article:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;uid:3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;uid:2&quot;</span><br><span class="line"></span><br><span class="line"># 判断用户 uid:<span class="number">1</span> 是否对文章 article:<span class="number">1</span> 点赞了：</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span>  # 返回<span class="number">0</span>说明没点赞，返回<span class="number">1</span>则说明点赞了</span><br></pre></td></tr></table></figure>

<h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户id，value 则是已关注的公众号的id。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># uid:<span class="number">1</span> 用户关注公众号 id 为 <span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span></span><br><span class="line"><span class="operator">&gt;</span> SADD uid:<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line"># uid:<span class="number">2</span>  用户关注公众号 id 为 <span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span>、<span class="number">10</span>、<span class="number">11</span></span><br><span class="line"><span class="operator">&gt;</span> SADD uid:<span class="number">2</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line"></span><br><span class="line"># uid:<span class="number">1</span> 和 uid:<span class="number">2</span> 共同关注的公众号：</span><br><span class="line"># 获取共同关注</span><br><span class="line"><span class="operator">&gt;</span> SINTER uid:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;7&quot;</span><br><span class="line"><span class="number">2</span>) &quot;8&quot;</span><br><span class="line"><span class="number">3</span>) &quot;9&quot;</span><br><span class="line"></span><br><span class="line"># 给 uid:<span class="number">2</span> 推荐 uid:<span class="number">1</span> 关注的公众号：</span><br><span class="line"><span class="operator">&gt;</span> SDIFF uid:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;6&quot;</span><br><span class="line"></span><br><span class="line"># 验证某个公众号是否同时被 uid:<span class="number">1</span> 或 uid:<span class="number">2</span> 关注:</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER uid:<span class="number">1</span> <span class="number">5</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span> # 返回<span class="number">0</span>，说明关注了</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER uid:<span class="number">2</span> <span class="number">5</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span> # 返回<span class="number">0</span>，说明没关注</span><br></pre></td></tr></table></figure>

<h3 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h3><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line"></span><br><span class="line"># 如果允许重复中奖，可以使用 SRANDMEMBER 命令。</span><br><span class="line"># 抽取 <span class="number">1</span> 个一等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;Tom&quot;</span><br><span class="line"># 抽取 <span class="number">2</span> 个二等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;Mark&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Jerry&quot;</span><br><span class="line"># 抽取 <span class="number">3</span> 个三等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;Sary&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Tom&quot;</span><br><span class="line"><span class="number">3</span>) &quot;Jerry&quot;</span><br><span class="line"></span><br><span class="line"># 如果不允许重复中奖，可以使用 SPOP 命令。</span><br><span class="line"># 抽取一等奖<span class="number">1</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;Sary&quot;</span><br><span class="line"># 抽取二等奖<span class="number">2</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;Jerry&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Mark&quot;</span><br><span class="line"># 抽取三等奖<span class="number">3</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;John&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Sean&quot;</span><br><span class="line"><span class="number">3</span>) &quot;Lindy&quot;</span><br></pre></td></tr></table></figure>


<h1 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p>
<p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p>
<img src="./zset.webp" width = "50%" height = "50%" alt="zset" align=center />

<h2 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h2><p>Zset 类型的底层数据结构是由压缩列表或跳表实现的：</p>
<pre><code>1. 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；

2.如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；
</code></pre>
<p>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</p>
<h2 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><p>常用操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 往有序集合key中加入带分值元素</span><br><span class="line">ZADD key score <span class="keyword">member</span> [[score <span class="keyword">member</span>]...]   </span><br><span class="line"># 往有序集合key中删除元素</span><br><span class="line">ZREM key <span class="keyword">member</span> [member...]                 </span><br><span class="line"># 返回有序集合key中元素<span class="keyword">member</span>的分值</span><br><span class="line">ZSCORE key <span class="keyword">member</span></span><br><span class="line"># 返回有序集合key中元素个数</span><br><span class="line">ZCARD key </span><br><span class="line"></span><br><span class="line"># 为有序集合key中元素<span class="keyword">member</span>的分值加上increment</span><br><span class="line">ZINCRBY key increment <span class="keyword">member</span> </span><br><span class="line"></span><br><span class="line"># 正序获取有序集合key从<span class="keyword">start</span>下标到stop下标的元素</span><br><span class="line">ZRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br><span class="line"># 倒序获取有序集合key从<span class="keyword">start</span>下标到stop下标的元素</span><br><span class="line">ZREVRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT <span class="keyword">offset</span> count]</span><br><span class="line"></span><br><span class="line"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span><br><span class="line">ZRANGEBYLEX key min max [LIMIT <span class="keyword">offset</span> count]</span><br><span class="line"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT <span class="keyword">offset</span> count]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key...] </span><br><span class="line"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span><br><span class="line">ZINTERSTORE destkey numberkeys key [key...]</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h2><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p>
<p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p>
<h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p>
<p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># arcticle:<span class="number">1</span> 文章获得了<span class="number">200</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">200</span> arcticle:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># arcticle:<span class="number">2</span> 文章获得了<span class="number">40</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">40</span> arcticle:<span class="number">2</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># arcticle:<span class="number">3</span> 文章获得了<span class="number">100</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">100</span> arcticle:<span class="number">3</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># arcticle:<span class="number">4</span> 文章获得了<span class="number">50</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">50</span> arcticle:<span class="number">4</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># arcticle:<span class="number">5</span> 文章获得了<span class="number">150</span>个赞</span><br><span class="line"><span class="operator">&gt;</span> ZADD <span class="keyword">user</span>:xiaolin:ranking <span class="number">150</span> arcticle:<span class="number">5</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 文章 arcticle:<span class="number">4</span> 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素<span class="keyword">member</span>的分值加上increment）：</span><br><span class="line"><span class="operator">&gt;</span> ZINCRBY <span class="keyword">user</span>:xiaolin:ranking <span class="number">1</span> arcticle:<span class="number">4</span></span><br><span class="line">&quot;51&quot;</span><br><span class="line"></span><br><span class="line"># 查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</span><br><span class="line"><span class="operator">&gt;</span> ZSCORE <span class="keyword">user</span>:xiaolin:ranking arcticle:<span class="number">4</span></span><br><span class="line">&quot;50&quot;</span><br><span class="line"></span><br><span class="line"># 获取小林文章赞数最多的 <span class="number">3</span> 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从<span class="keyword">start</span>下标到stop下标的元素）：</span><br><span class="line"># WITHSCORES 表示把 score 也显示出来</span><br><span class="line"><span class="operator">&gt;</span> ZREVRANGE <span class="keyword">user</span>:xiaolin:ranking <span class="number">0</span> <span class="number">2</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) &quot;arcticle:1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;200&quot;</span><br><span class="line"><span class="number">3</span>) &quot;arcticle:5&quot;</span><br><span class="line"><span class="number">4</span>) &quot;150&quot;</span><br><span class="line"><span class="number">5</span>) &quot;arcticle:3&quot;</span><br><span class="line"><span class="number">6</span>) &quot;100&quot;</span><br><span class="line"></span><br><span class="line"># 获取小林 <span class="number">100</span> 赞到 <span class="number">200</span> 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</span><br><span class="line"><span class="operator">&gt;</span> ZRANGEBYSCORE <span class="keyword">user</span>:xiaolin:ranking <span class="number">100</span> <span class="number">200</span> WITHSCORES</span><br><span class="line"><span class="number">1</span>) &quot;arcticle:3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;100&quot;</span><br><span class="line"><span class="number">3</span>) &quot;arcticle:5&quot;</span><br><span class="line"><span class="number">4</span>) &quot;150&quot;</span><br><span class="line"><span class="number">5</span>) &quot;arcticle:1&quot;</span><br><span class="line"><span class="number">6</span>) &quot;200&quot;</span><br></pre></td></tr></table></figure>

<h3 id="电话、姓名排序"><a href="#电话、姓名排序" class="headerlink" title="电话、姓名排序"></a>电话、姓名排序</h3><p>使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序</p>
<p>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> ZADD phone <span class="number">0</span> <span class="number">13100111100</span> <span class="number">0</span> <span class="number">13110114300</span> <span class="number">0</span> <span class="number">13132110901</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="operator">&gt;</span> ZADD phone <span class="number">0</span> <span class="number">13200111100</span> <span class="number">0</span> <span class="number">13210414300</span> <span class="number">0</span> <span class="number">13252110901</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"><span class="operator">&gt;</span> ZADD phone <span class="number">0</span> <span class="number">13300111100</span> <span class="number">0</span> <span class="number">13310414300</span> <span class="number">0</span> <span class="number">13352110901</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 获取所有号码:</span><br><span class="line"><span class="number">1</span>) &quot;13100111100&quot;</span><br><span class="line"><span class="number">2</span>) &quot;13110114300&quot;</span><br><span class="line"><span class="number">3</span>) &quot;13132110901&quot;</span><br><span class="line"><span class="number">4</span>) &quot;13200111100&quot;</span><br><span class="line"><span class="number">5</span>) &quot;13210414300&quot;</span><br><span class="line"><span class="number">6</span>) &quot;13252110901&quot;</span><br><span class="line"><span class="number">7</span>) &quot;13300111100&quot;</span><br><span class="line"><span class="number">8</span>) &quot;13310414300&quot;</span><br><span class="line"><span class="number">9</span>) &quot;13352110901&quot;</span><br><span class="line"></span><br><span class="line"># 获取 <span class="number">132</span> 号段的号码：</span><br><span class="line"><span class="operator">&gt;</span> ZRANGEBYLEX phone [<span class="number">132</span> (<span class="number">133</span></span><br><span class="line"><span class="number">1</span>) &quot;13200111100&quot;</span><br><span class="line"><span class="number">2</span>) &quot;13210414300&quot;</span><br><span class="line"><span class="number">3</span>) &quot;13252110901&quot;</span><br><span class="line"></span><br><span class="line"># 获取<span class="number">132</span>、<span class="number">133</span>号段的号码：</span><br><span class="line"><span class="operator">&gt;</span> ZRANGEBYLEX phone [<span class="number">132</span> (<span class="number">134</span></span><br><span class="line"><span class="number">1</span>) &quot;13200111100&quot;</span><br><span class="line"><span class="number">2</span>) &quot;13210414300&quot;</span><br><span class="line"><span class="number">3</span>) &quot;13252110901&quot;</span><br><span class="line"><span class="number">4</span>) &quot;13300111100&quot;</span><br><span class="line"><span class="number">5</span>) &quot;13310414300&quot;</span><br><span class="line"><span class="number">6</span>) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://xiaolincoding.com/redis/">图解Redis介绍</a><br><a href="https://try.redis.io/">在线redis环境</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-数据结构</title>
    <url>/%E5%AD%98%E5%82%A8/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>Redis 共有9种数据结构：SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。</p>
<span id="more"></span>

<h1 id="键值对数据库是怎么实现的？"><a href="#键值对数据库是怎么实现的？" class="headerlink" title="键值对数据库是怎么实现的？"></a>键值对数据库是怎么实现的？</h1><p>Redis 的键值对中的 key 就是字符串对象，而 value 可以是字符串对象，也可以是集合数据类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p>
<h2 id="Redis-保存键值对所涉及到的数据结构"><a href="#Redis-保存键值对所涉及到的数据结构" class="headerlink" title="Redis 保存键值对所涉及到的数据结构"></a>Redis 保存键值对所涉及到的数据结构</h2><img src="./redis数据结构.webp" width = "50%" height = "50%" alt="redis数据结构" align=center />

<ol>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li>
<li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li>
<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li>
<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， key 指向的是 String 对象，而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</li>
</ol>
<h2 id="数据类型与数据结构对应"><a href="#数据类型与数据结构对应" class="headerlink" title="数据类型与数据结构对应"></a>数据类型与数据结构对应</h2><img src="./redis数据类型与数据结构.webp" width = "50%" height = "50%" alt="redis数据类型与数据结构" align=center />

<h2 id="redis-这么快的原因"><a href="#redis-这么快的原因" class="headerlink" title="redis 这么快的原因"></a>redis 这么快的原因</h2><ol>
<li>内存数据库，所有操作都在内存上。</li>
<li>高效的数据结构。</li>
</ol>
<h2 id="redis-数据结构共有-9-种"><a href="#redis-数据结构共有-9-种" class="headerlink" title="redis 数据结构共有 9 种"></a>redis 数据结构共有 9 种</h2><p>SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。</p>
<img src="./redis9种数据结构.webp" width = "50%" height = "50%" alt="redis9种数据结构" align=center />
 
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>redis里的键 void * key 和 值 void * value 的指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示，如下图：<br>    <img src="./redis对象.webp" width = "50%" height = "50%" alt="redis对象" align=center /></p>
<ol>
<li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li>
<li>encoding，标识该对象使用了哪种底层的数据结构；</li>
<li>ptr，指向底层数据结构的指针。</li>
</ol>
<h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><p>键值对中的键是字符串类型，值有时也是字符串类型。</p>
<p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p>
<h2 id="C-语言字符串的缺陷"><a href="#C-语言字符串的缺陷" class="headerlink" title="C 语言字符串的缺陷"></a>C 语言字符串的缺陷</h2><ol>
<li>获取字符串长度的时间复杂度为 O（N）；</li>
<li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li>
<li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；<ol>
<li>比如strcat 函数是可以将两个字符串拼接在一起。</li>
<li>如果没有为拼接后的对象分配足够多的内存，就会发生缓冲区溢出。</li>
<li>拼接过程需要遍历到目的对象末尾，再遍历待拼接对象，效率低。</li>
</ol>
</li>
</ol>
<h2 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h2><img src="./SDS数据结构.webp" width = "50%" height = "50%" alt="SDS数据结构" align=center />

<h2 id="SDS-扩容规则"><a href="#SDS-扩容规则" class="headerlink" title="SDS 扩容规则"></a>SDS 扩容规则</h2><ol>
<li>如果所需的 sds 长度小于 1 MB，那么最后的扩容是按照翻倍扩容来执行的。</li>
<li>如果所需的 sds 长度超过 1 MB，那么最后的扩容长度应该是 newlen + 1MB。</li>
</ol>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。是由 list 结构和 3 个 listNode 结构组成的双向链表。<br>    <img src="./链表数据结构.webp" width = "50%" height = "50%" alt="链表数据结构" align=center /></p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)。</li>
<li>获取链表的表头节点和表尾节点的时间复杂度只需O(1)。</li>
<li>获取链表中的节点数量的时间复杂度只需O(1)。</li>
<li>链表节点可以保存各种不同类型的值。</li>
</ol>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol>
<li>链表每个节点之间的内存都是不连续的，意味着无法很好利用 CPU 缓存。</li>
<li>保存一个链表节点的值都需要一个链表节点结构头的分配，内存开销较大。</li>
</ol>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间。<br>    <img src="./压缩列表数据结构.webp" width = "50%" height = "50%" alt="压缩列表数据结构" align=center /></p>
<p>压缩列表节点包含三部分内容：<br>    1. prevlen，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；<br>    2. encoding，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。<br>    3. data，记录了当前节点的实际数据，类型和长度都由 encoding 决定；</p>
<h2 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h2><ol>
<li>内存紧凑型的数据结构，占用一块连续的内存空间，可以利用 CPU 缓存；</li>
<li>而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</li>
</ol>
<h2 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h2><ol>
<li>不能保存过多的元素，否则查询效率就会降低；</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ol>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表是一种保存键值对（key-value）的数据结构。</p>
<h2 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h2><p>它能以 O(1) 的复杂度快速查询数据。怎么做到的呢？将 key 通过 Hash 函数的计算，就能定位数据在表中的位置，因为哈希表实际上是数组，所以可以通过索引值快速查询到数据。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>哈希表大小固定的情况下，随着数据不断增多，那么哈希冲突的可能性也会越高。</p>
<h2 id="链式哈希"><a href="#链式哈希" class="headerlink" title="链式哈希"></a>链式哈希</h2><img src="./链式哈希.webp" width = "50%" height = "50%" alt="链式哈希" align=center />

<p>Redis 采用了「链式哈希」来解决哈希冲突。在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接，以便这些数据在表中仍然可以被查询到。</p>
<p>链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>Redis 定义一个 dict 结构体，这个结构体里定义了两个哈希表（ht[2]）。</p>
<p>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。</p>
<p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p>
<pre><code>1. 给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；
2. 将「哈希表 1 」的数据迁移到「哈希表 2」 中；
3. 迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。
</code></pre>
<p>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求。</p>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了渐进式 rehash，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p>
<p>渐进式 rehash 步骤如下：</p>
<pre><code>1. 给「哈希表 2」 分配空间；
2. 在 rehash 进行期间，每次哈希表元素进行更新时，将相应key-value搬迁到「哈希表 2」上进行更新，新增直接在「哈希表 2」上新增，删除和查找依次在「哈希表 1」和「哈希表 2」上操作。
3. 随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。
</code></pre>
<h2 id="rehash-触发条件"><a href="#rehash-触发条件" class="headerlink" title="rehash 触发条件"></a>rehash 触发条件</h2><p>负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小</p>
<p>触发 rehash 操作的条件，主要有两个：</p>
<pre><code>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。

当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。
</code></pre>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合是 Set 对象的底层实现之一。</p>
<p>当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p>
<h2 id="整数集合结构设计"><a href="#整数集合结构设计" class="headerlink" title="整数集合结构设计"></a>整数集合结构设计</h2><p>本质上是一块连续内存空间，保存元素的容器是一个 contents 数组。</p>
<h2 id="整数集合的升级操作"><a href="#整数集合的升级操作" class="headerlink" title="整数集合的升级操作"></a>整数集合的升级操作</h2><p>当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也要维持整数集合的有序性。</p>
<pre><code>1. 先计算需要扩容的空间，在原有空间上扩容。
2. 旧数组倒序遍历处理升级每个元素并放在相应位置。
3. 将待插入元素放到最后应该处于的位置。
</code></pre>
<h2 id="整数集合升级有什么好处呢？"><a href="#整数集合升级有什么好处呢？" class="headerlink" title="整数集合升级有什么好处呢？"></a>整数集合升级有什么好处呢？</h2><p>   不做升级时最简单的方案是使用int64_t类型数组，存在内存浪费情况。<br>   只有实现升级才能够依据元素具体类型来动态选择最优方案，尽可能节省内存资源。</p>
<p>   不支持升级后又降级的操作。</p>
<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p>zset 结构体里有两个数据结构：</p>
<pre><code>一个是跳表：高效的范围查询
一个是哈希表：高效单点查询。
</code></pre>
<h2 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h2><p>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是能快速定位数据。<br><img src="./3层跳表.webp" width = "50%" height = "50%" alt="3层跳表" align=center /></p>
<h2 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h2><img src="./3层跳表.webp" width = "50%" height = "50%" alt="3层跳表" align=center />

<p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断：</p>
<pre><code>1. 如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。
2. 如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。
3. 如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。
</code></pre>
<h2 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h2><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p>
<p>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)。</p>
<p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p>
<pre><code>1. 如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。
2. Redis 则采用一种巧妙的方法是，跳表在创建节点的时候，随机生成每个节点的层数，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。
    具体的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。

    这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 32
</code></pre>
<h2 id="为什么用跳表而不用平衡树？"><a href="#为什么用跳表而不用平衡树？" class="headerlink" title="为什么用跳表而不用平衡树？"></a>为什么用跳表而不用平衡树？</h2><ol>
<li>从内存占用上来比较，跳表比平衡树更灵活一些。<ol>
<li>平衡树每个节点包含 2 个指针（分别指向左右子树）</li>
<li>跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
</ol>
</li>
<li>在做范围查找的时候，跳表比平衡树操作要简单。<ol>
<li>平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。</li>
<li>在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
</ol>
</li>
<li>从算法实现难度上来比较，跳表比平衡树要简单得多。<ol>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂。</li>
<li>跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ol>
</li>
</ol>
<h2 id="redis为什么使用跳表而不使用B-树或二叉树呢"><a href="#redis为什么使用跳表而不使用B-树或二叉树呢" class="headerlink" title="redis为什么使用跳表而不使用B+树或二叉树呢?"></a>redis为什么使用跳表而不使用B+树或二叉树呢?</h2><ol start="0">
<li>redis 是纯纯的内存数据库。</li>
<li>进行读写数据都是操作内存，跟磁盘没啥关系，因此也不存在磁盘IO了，所以层高就不再是跳表的劣势了。</li>
<li>B+树是有一系列合并拆分操作的，换成红黑树或者其他AVL树的话也是各种旋转，目的也是为了保持树的平衡。</li>
<li>而跳表插入数据时，只需要随机一下，就知道自己要不要往上加索引，也就少了旋转平衡的开销。</li>
</ol>
<h2 id="Mysql的索引为什么使用B-树而不使用跳表"><a href="#Mysql的索引为什么使用B-树而不使用跳表" class="headerlink" title="Mysql的索引为什么使用B+树而不使用跳表?"></a>Mysql的索引为什么使用B+树而不使用跳表?</h2><ol start="0">
<li>mysql 是磁盘数据库。</li>
<li>B+树是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，三层左右就可以存储2kw左右的数据。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询三次磁盘IO。</li>
<li>跳表是链表结构，一条数据一个结点，如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方左右，最坏情况下，这24层数据会分散在不同的数据页里，也即是查一次数据会经历24次磁盘IO。</li>
<li>因此存放同样量级的数据，B+树的高度比跳表的要少，如果放在mysql数据库上来说，就是磁盘IO次数更少，因此B+树查询更快。如果放在mysql数据库上来说，就是磁盘IO次数更少，因此B+树查询更快。</li>
<li>而针对写操作，B+树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此跳表的写入性能会比B+树要好。</li>
</ol>
<h1 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h1><p>在 Redis 3.2 的时候，List 对象的底层由双向链表或者压缩列表改为 quicklist 数据结构实现。</p>
<p>quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。<br><img src="./quicklist数据结构.webp" width = "50%" height = "50%" alt="quicklist数据结构" align=center /></p>
<p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p>
<h1 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h1><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。<br><img src="./listpack数据结构.webp" width = "50%" height = "50%" alt="listpack数据结构" align=center /></p>
<pre><code>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；
data，实际存放的数据；
len，encoding+data的总长度；
</code></pre>
<p>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://xiaolincoding.com/redis/">图解Redis介绍</a><br><a href="https://try.redis.io/">在线redis环境</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-面试</title>
    <url>/%E9%9D%A2%E8%AF%95/redis-%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>Redis 面试要点</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><ol>
<li><p>redis 是开源的基于内存的数据库，读写都在内存中，因此速度非常快，常用于缓存、消息队列、分布式锁等场景。</p>
</li>
<li><p>redis 提供了5种常用的数据类型：String(字符串)、List (列表)、Hash(哈希)、Set(集合)、Zset(有序集合)，并且对数据类型的操作都是原子性的，因为是由单线程来执行命令，不存在并发竞争问题。</p>
</li>
<li><p>redis 还支持事务、持久化、lua脚本、多集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制等等。</p>
</li>
</ol>
<h2 id="redis-和-memcached-区别"><a href="#redis-和-memcached-区别" class="headerlink" title="redis 和 memcached 区别"></a>redis 和 memcached 区别</h2><ol>
<li><p>共同点</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存。</li>
<li>都有过期策略。</li>
<li>性能都非常高</li>
</ol>
</li>
<li><p>区别</p>
<ol>
<li>数据类型丰富<br> redis支持丰富的数据类型，而memcached只支持最简单的key-value数据类型。</li>
<li>持久化到磁盘<br> redis支持数据的持久化到磁盘中，而memcached重启或者挂掉后，内存数据会丢失。</li>
<li>原生支持集群模式<br> redis原生支持集群模式，而memcached原生无集群，需要依靠客户端实现往集群中分片写入。</li>
<li>提供更多功能<br> redis支持发布订阅模型、lua脚本、事务等功能，而memcached不支持。</li>
</ol>
</li>
</ol>
<h2 id="为什么用redis作为mysql的缓存"><a href="#为什么用redis作为mysql的缓存" class="headerlink" title="为什么用redis作为mysql的缓存"></a>为什么用redis作为mysql的缓存</h2><p>主要是因为redis具备【高性能】和【高并发】两种特性。</p>
<ol>
<li><p>高性能<br> redis 数据存在于内存中，所以速度非常快。</p>
</li>
<li><p>高并发<br> 单设备的redis的qps是mysql的10倍，能轻松破10万，而mysql单机的QPS很难破1万。</p>
</li>
</ol>
<h2 id="redis-高并发的原因"><a href="#redis-高并发的原因" class="headerlink" title="redis 高并发的原因"></a>redis 高并发的原因</h2><ol>
<li>基于内存，读写速度非常快。</li>
<li>单线程，省去很多上下文切换线程的开销。</li>
<li>采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求。</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数据类型及使用场景"><a href="#数据类型及使用场景" class="headerlink" title="数据类型及使用场景"></a>数据类型及使用场景</h2><img src="./redis数据类型.webp" width = "50%" height = "50%" alt="redis数据类型" align=center />

<ol>
<li><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：String（字符串），List（列表），Hash（哈希），Set（集合）、Zset（有序集合）。</p>
</li>
<li><p>应用场景</p>
<ol>
<li>string: 缓存对象、常规计数、分布式锁、共享session信息。</li>
<li>list: 消息队列。</li>
<li>hash: 缓存对象、购物车。</li>
<li>set: 聚合计算，比如点赞、共同关注、抽奖活动。</li>
<li>zset: 排序场景，比如排行榜、电话和姓名排序等。</li>
</ol>
</li>
</ol>
<h2 id="数据类型底层结构实现"><a href="#数据类型底层结构实现" class="headerlink" title="数据类型底层结构实现"></a>数据类型底层结构实现</h2><img src="./redis数据结构实现.webp" width = "50%" height = "50%" alt="redis数据结构实现" align=center />

<pre><code>string -&gt; SDS
list -&gt; 压缩列表/双向链表 -&gt; （listpack+双向链表）quicklist
hash -&gt; 压缩列表/哈希表 -&gt;  listpack/哈希表
set -&gt; 哈希表/整数集合
zset -&gt; 压缩列表/跳表 -&gt; listpack/跳表
</code></pre>
<h3 id="String-类型实现"><a href="#String-类型实现" class="headerlink" title="String 类型实现"></a>String 类型实现</h3><img src="./SDS数据结构.webp" width = "50%" height = "50%" alt="SDS数据结构" align=center />

<p>String 类型的底层的数据结构实现主要是 SDS（简单动态字符串），相比C语言的原生字符串：</p>
<ol>
<li>SDS 不仅可以保留文本数据，还可以保存二进制数据。因为SDS使用len属性而不是空字符来判断字符串结束。</li>
<li>SDS 获取字符串长度的时间复杂度为O(1)。</li>
<li>SDS api是安全的，拼接字符串不会造成缓冲区溢出。</li>
</ol>
<h3 id="List-类型实现"><a href="#List-类型实现" class="headerlink" title="List 类型实现"></a>List 类型实现</h3><img src="./list数据结构.webp" width = "50%" height = "50%" alt="list数据结构" align=center />

<ol>
<li><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。</p>
<ol>
<li>双向链表<ol>
<li>优点：可以保存不用类型的值、快速获取某个节点的前后节点</li>
<li>缺点：无法很好地利用cpu缓存，额外指针内存开销大</li>
</ol>
</li>
<li>压缩列表<ol>
<li>优点：内存紧凑，连续内存空间，很好地利用cpu缓存。</li>
<li>缺点：不能保存过多元素，否则查询效率低，新增或修改可能导致连锁更新问题。</li>
</ol>
</li>
</ol>
</li>
<li><p>然后在 Redis 3.2 的时候，List 对象的底层改由 【quicklist】 数据结构实现。</p>
<ol>
<li>其实 quicklist 就是「双向链表 + 压缩列表」组合。</li>
<li>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</li>
</ol>
</li>
</ol>
<h3 id="Hash-类型实现"><a href="#Hash-类型实现" class="headerlink" title="Hash 类型实现"></a>Hash 类型实现</h3><ol>
<li><p>在 Redis 7.0 之前，Hash 类型的底层数据结构是由压缩列表或哈希表实现的</p>
</li>
<li><p>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 【listpack】 和【哈希表】来实现了。</p>
</li>
<li><p>哈希</p>
<img src="./hash数据结构.webp" width = "50%" height = "50%" alt="hash数据结构" align=center />
<img src="./hash-rehash-1.webp" width = "50%" height = "50%" alt="hash-rehash-1" align=center />
<img src="./hash-rehash-2.webp" width = "50%" height = "50%" alt="hash-rehash-2" align=center />

<ol>
<li>哈希表实际上是数组，所以可以通过索引值快速查询到数据。</li>
<li>在哈希表大小固定的情况下，随着数据不断增多，那么哈希冲突的可能性也会越高。</li>
<li>redis采用链式哈希解决哈希冲突，将具有相同哈希值的数据串起来。</li>
<li>rehash<ol>
<li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li>
<li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li>
<li>迁移完成后，「哈希表 1 」的空间会被释放;</li>
<li>并把「哈希表 2」 设置为「哈希表 1」;</li>
<li>然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li>
</ol>
</li>
<li>渐进式 rehash<ol>
<li>给「哈希表 2」 分配空间；</li>
<li>在 rehash 进行期间，<ol>
<li>查找：先查找「哈希表 1」，如果没有，则查找「哈希表 2」；</li>
<li>新增：保存到「哈希表 2 」，而「哈希表 1」 则不进行任何操作；</li>
<li>删除：依次对「哈希表 1」和「哈希表 2」删除；</li>
<li>更新：如果在「哈希表 1」上，则删除并新增到「哈希表 2」上；</li>
</ol>
</li>
<li>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</li>
</ol>
</li>
<li>rehash触发条件<ol>
<li>负载因子 &#x3D; 已保存节点数量 &#x2F; 哈希表大小 </li>
<li>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewriteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</li>
<li>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</li>
</ol>
</li>
</ol>
</li>
<li><p>listpack</p>
<img src="./listpack.webp" width = "50%" height = "50%" alt="listpack" align=center /></li>
</ol>
<p>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set 类型的底层数据结构是由【哈希表】或【整数集合】实现的：</p>
<pre><code>1. 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；
2. 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。
</code></pre>
<ol>
<li>整数集合<img src="./整数集合数据结构.webp" width = "50%" height = "50%" alt="整数集合数据结构" align=center />

<ol>
<li>本质上是一块连续内存空间，每个元素定义某中int类型。</li>
<li>整数集合的升级操作，新插入int32_t整数时，由 int16_t 升级为 int32_t。（节省内存）</li>
<li>升级过程先扩容，然后从后向前遍历旧元素往最终位置移动。</li>
</ol>
</li>
</ol>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>Zset 类型的底层数据结构是由【压缩列表】-&gt; 【listpack】或【跳表】实现的：</p>
<pre><code>1. 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；
2. 如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；
</code></pre>
<p>跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p>zset 结构体里有两个数据结构：</p>
<pre><code>1. 一个是跳表: 进行高效的范围查询
2. 一个是哈希表: 高效单点查询。
</code></pre>
<p>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是能快读定位数据。</p>
<img src="./跳表数据结构.webp" width = "50%" height = "50%" alt="跳表数据结构" align=center />

<p>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)。</p>
<p>Redis 则采用一种巧妙的方法是，跳表在创建节点的时候，随机生成每个节点的层数，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。</p>
<p>为什么用跳表不用平衡树？</p>
<pre><code>1. 内存上，跳表更灵活，每个节点包含的指针数目平均为1/(1-p)，p取1/4时，平均每个节点包含1.33个指针，而平衡树每个节点包含2个指针。
2. 范围查询时，跳表操作更简单，只需要找到最小值之后，对第一层链表进行遍历即可。而平衡树需要以中序遍历寻找，实现较复杂。
3. 算法实现难度，跳表比平衡树要简单，跳表的插入和删除只需要修改相邻节点的指针。而平衡树的插入和删除操作可能引发子树的调整，逻辑复杂。
</code></pre>
<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><h2 id="redis是单线程"><a href="#redis是单线程" class="headerlink" title="redis是单线程"></a>redis是单线程</h2><p>「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端</p>
<p>但是，Redis 程序并不是单线程的，Redis 在启动的时候，是会启动后台线程（BIO）的，主要用来处理「关闭文件、AOF 刷盘、释放内存」等耗时操作：<br><img src="./后台线程.webp" width = "50%" height = "50%" alt="后台线程" align=center /></p>
<pre><code>1. Redis 在 2.6 版本，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘（AOF日志配置成everysec）这两个任务；
2. Redis 在 4.0 版本之后，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。
</code></pre>
<h2 id="单线程模式"><a href="#单线程模式" class="headerlink" title="单线程模式"></a>单线程模式</h2><img src="./redis单线程模型.webp" width = "50%" height = "50%" alt="redis单线程模型" align=center />

<p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I&#x2F;O 和命令处理都是单线程。</p>
<ol>
<li><p>初始化函数  </p>
<ol>
<li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li>
<li>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；</li>
<li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li>
</ol>
</li>
<li><p>事件循环函数</p>
<ol>
<li>首先，先调用处理发送队列函数，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li>
<li>接着，调用 epoll_wait 函数等待事件的到来。</li>
</ol>
</li>
</ol>
<h2 id="单线程还快的原因"><a href="#单线程还快的原因" class="headerlink" title="单线程还快的原因"></a>单线程还快的原因</h2><ol>
<li>大部分操作都在内存中完成，并且采用了高效的数据结构。因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li>
<li>单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销。而且也不会导致死锁问题。</li>
<li>采用了 I&#x2F;O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li>
</ol>
<h2 id="为什么使用单线程"><a href="#为什么使用单线程" class="headerlink" title="为什么使用单线程"></a>为什么使用单线程</h2><p>单线程的程序是无法利用服务器的多核 CPU 的</p>
<ol>
<li>CPU不是制约redis性能表现的瓶颈所在，更多情况下是受到内存和网络带宽的限制。</li>
<li>单线程可维护性高，多线程带来并发读写的一系列问题，增加系统复杂度，同时可能存在线程切换、加锁解锁、死锁造成的性能损耗。</li>
</ol>
<h2 id="6-0之后为什么引入多线程"><a href="#6-0之后为什么引入多线程" class="headerlink" title="6.0之后为什么引入多线程"></a>6.0之后为什么引入多线程</h2><p>在 Redis 6.0 版本之后，也采用了多个 I&#x2F;O 线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上。</p>
<p>所以为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。</p>
<p>但是对于命令的执行，Redis 仍然使用单线程来处理。</p>
<p>默认情况下 I&#x2F;O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。</p>
<p> Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会额外创建 6 个线程（这里的线程数不包括主线程）：</p>
<pre><code>1. Redis-server ： Redis的主线程，主要负责执行命令；
2. bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；
3. io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。
</code></pre>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="如何实现数据不丢失？"><a href="#如何实现数据不丢失？" class="headerlink" title="如何实现数据不丢失？"></a>如何实现数据不丢失？</h2><p>实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p>
<p>Redis 共有三种数据持久化的方式：</p>
<pre><code>1. AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
2. RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；
3. 混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；
</code></pre>
<h2 id="AOF-日志实现"><a href="#AOF-日志实现" class="headerlink" title="AOF 日志实现"></a>AOF 日志实现</h2><img src="./AOF日志.webp" width = "50%" height = "50%" alt="AOF日志" align=center />
<img src="./AOF日志格式.webp" width = "50%" height = "50%" alt="AOF日志格式" align=center />

<h3 id="先执行命令，再写入日志？"><a href="#先执行命令，再写入日志？" class="headerlink" title="先执行命令，再写入日志？"></a>先执行命令，再写入日志？</h3><p>优点：<br>    1. 避免额外的检查开销，主要是写操作命令的语法检查。<br>    2. 不会阻塞当前写操作命令的执行。<br>缺点：<br>    1. 数据可能会丢失。<br>    2. 可能阻塞其他操作，可能阻塞后续其他操作的执行。</p>
<h3 id="AOF-写回策略有几种？"><a href="#AOF-写回策略有几种？" class="headerlink" title="AOF 写回策略有几种？"></a>AOF 写回策略有几种？</h3><p>Redis 提供了 3 种写回硬盘的策略，在 Redis.conf 配置文件中的 appendfsync 配置项。</p>
<ol>
<li>Always: 每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li>Everysec: 先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li>No: 先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ol>
<h3 id="AOF-日志过大，会触发什么机制？"><a href="#AOF-日志过大，会触发什么机制？" class="headerlink" title="AOF 日志过大，会触发什么机制？"></a>AOF 日志过大，会触发什么机制？</h3><p>Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制。</p>
<p>Redis 的重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的。</p>
<pre><code>1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；
2. 子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。
</code></pre>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」。</p>
<p>当子进程完成 AOF 重写工作（扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<pre><code>1. 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；
2. 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。
</code></pre>
<h2 id="RDB-快照实现"><a href="#RDB-快照实现" class="headerlink" title="RDB 快照实现"></a>RDB 快照实现</h2><p>AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。</p>
<p>RDB 快照就是记录某一个瞬间的全量内存数据，记录的是实际数据。</p>
<p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p>
<h3 id="RDB-做快照时会阻塞线程吗？"><a href="#RDB-做快照时会阻塞线程吗？" class="headerlink" title="RDB 做快照时会阻塞线程吗？"></a>RDB 做快照时会阻塞线程吗？</h3><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p>
<pre><code>1. 行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程；
2. 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞；
</code></pre>
<p>执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
<h3 id="RDB-在执行快照的时候，数据能修改吗？"><a href="#RDB-在执行快照的时候，数据能修改吗？" class="headerlink" title="RDB 在执行快照的时候，数据能修改吗？"></a>RDB 在执行快照的时候，数据能修改吗？</h3><p>执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，也就是数据是能被修改的，关键的技术就在于写时复制技术（Copy-On-Write, COW）。</p>
<h2 id="为什么会有混合持久化？"><a href="#为什么会有混合持久化？" class="headerlink" title="为什么会有混合持久化？"></a>为什么会有混合持久化？</h2><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p>
<p>AOF 优点是丢失数据少，但是数据恢复不快。</p>
<p> Redis 4.0 提出了混合使用 AOF 日志和内存快照，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p>
<p>混合持久化工作在 AOF 日志重写过程，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>混合持久化优点：<br>    混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，又减低了大量数据丢失的风险。<br>混合持久化缺点：<br>    1. AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；<br>    2. 兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="如何实现服务高可用？"><a href="#如何实现服务高可用？" class="headerlink" title="如何实现服务高可用？"></a>如何实现服务高可用？</h2><p>一定要从 Redis 的多服务节点来考虑，比如 Redis 的主从复制、哨兵模式、切片集群。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><img src="./主从复制.webp" width = "50%" height = "50%" alt="主从复制" align=center />

<p>主从复制是 Redis 高可用服务的最基础的保证。</p>
<p>一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。</p>
<p>主从服务器之间的命令复制是异步进行的。所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</p>
<p>形成主从关系命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>

<p>主从第一次同步<br><img src="./主从第一次同步.webp" width = "50%" height = "50%" alt="主从第一次同步" align=center /></p>
<p>分摊主服务器的压力<br><img src="./分担主服务器压力.webp" width = "50%" height = "50%" alt="分担主服务器压力" align=center /></p>
<p>增量同步<br>主从服务器在完成第一次同步后，就会基于长连接进行命令传播。<br>从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用增量复制的方式继续同步。</p>
<pre><code>1. 从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1；
2. 主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；
3. 然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。
</code></pre>
<p>增量同步环形缓冲区<br><img src="./增量同步环形缓冲区.webp" width = "50%" height = "50%" alt="增量同步环形缓冲区" align=center /></p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><img src="./哨兵模式.webp" width = "50%" height = "50%" alt="哨兵模式" align=center />

<p>哨兵模式可以监控主从服务器，并且提供主从节点故障转移的功能。</p>
<h3 id="切片集群模式"><a href="#切片集群模式" class="headerlink" title="切片集群模式"></a>切片集群模式</h3><img src="./切片集群模式.webp" width = "50%" height = "50%" alt="切片集群模式" align=center />

<p>将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p>
<p>采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。</p>
<p>一个切片集群共有 16384(2^14) 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p>
<pre><code>1. 根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。
2. 再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。
</code></pre>
<p>这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p>
<pre><code>1. 平均分配： 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384/9 个。
2. 手动分配： 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。
</code></pre>
<h2 id="集群脑裂导致数据丢失怎么办？"><a href="#集群脑裂导致数据丢失怎么办？" class="headerlink" title="集群脑裂导致数据丢失怎么办？"></a>集群脑裂导致数据丢失怎么办？</h2><h3 id="什么是脑裂？"><a href="#什么是脑裂？" class="headerlink" title="什么是脑裂？"></a>什么是脑裂？</h3><p>由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p>
<p>解决方案：<br>    当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p>
<h2 id="Redis主从节点是长连接还是短连接？"><a href="#Redis主从节点是长连接还是短连接？" class="headerlink" title="Redis主从节点是长连接还是短连接？"></a>Redis主从节点是长连接还是短连接？</h2><p>长连接</p>
<h2 id="怎么判断-Redis-某个节点是否正常工作？"><a href="#怎么判断-Redis-某个节点是否正常工作？" class="headerlink" title="怎么判断 Redis 某个节点是否正常工作？"></a>怎么判断 Redis 某个节点是否正常工作？</h2><p>Redis 判断节点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。</p>
<p>Redis 主从节点发送的心态间隔是不一样的，而且作用也有一点区别：</p>
<pre><code>1. Redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数repl-ping-slave-period控制发送频率。
2. Redis 从节点每隔 1 秒发送 replconf ack&#123;offset&#125; 命令，给主节点上报自身当前的复制偏移量，目的是为了：
    1. 实时监测主从节点网络状态；
    2. 上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。
</code></pre>
<h2 id="主从复制架构中，过期key如何处理？"><a href="#主从复制架构中，过期key如何处理？" class="headerlink" title="主从复制架构中，过期key如何处理？"></a>主从复制架构中，过期key如何处理？</h2><p>主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。</p>
<h2 id="Redis-是同步复制还是异步复制？"><a href="#Redis-是同步复制还是异步复制？" class="headerlink" title="Redis 是同步复制还是异步复制？"></a>Redis 是同步复制还是异步复制？</h2><p>Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点。</p>
<h2 id="为什么会出现主从数据不一致？"><a href="#为什么会出现主从数据不一致？" class="headerlink" title="为什么会出现主从数据不一致？"></a>为什么会出现主从数据不一致？</h2><p>主从数据不一致，就是指客户端从从节点中读取到的值和主节点中的最新值并不一致。</p>
<p>是因为主从节点间的命令复制是异步进行的，所以无法实现强一致性保证（主从数据时时刻刻保持一致）。</p>
<h2 id="如何应对主从数据不一致？"><a href="#如何应对主从数据不一致？" class="headerlink" title="如何应对主从数据不一致？"></a>如何应对主从数据不一致？</h2><ol>
<li>尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房。</li>
<li>可以开发一个外部程序来监控主从节点间的复制进度。<ol>
<li>先用 INFO replication 命令查到主、从节点的进度，然后，我们用 master_repl_offset 减去 slave_repl_offset，这样就能得到从节点和主节点间的复制进度差值了。</li>
<li>如果某个从节点的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从节点连接进行数据读取，这样就可以减少读到不一致数据的情况。</li>
</ol>
</li>
</ol>
<h2 id="主从切换如何减少数据丢失？"><a href="#主从切换如何减少数据丢失？" class="headerlink" title="主从切换如何减少数据丢失？"></a>主从切换如何减少数据丢失？</h2><ol>
<li>异步复制同步丢失<ol>
<li>原因：网络异常导致同步到从节点失败</li>
<li>解决：减少同步丢失的可能，减少同步时间，控制主从数据同步时间，超时主节点拒绝写入新的请求。</li>
</ol>
</li>
<li>集群产生脑裂数据丢失<ol>
<li>原因：集群因为主节点网络异常导致哨兵启动选举出一个新的主节点，这时集群就有两个主节点。<br> 旧主节点在这期间还接受客户端写入请求，但由于选举出新的主节点就被迫降级为从节点，此时需要清空数据去同步导致写入请求丢失。</li>
<li>解决：当主节点发现从节点下线数量太多，或者网络延迟太大的时候，主动禁止写操作，返回错误给客户端。</li>
</ol>
</li>
</ol>
<h2 id="主从如何做到故障自动切换？"><a href="#主从如何做到故障自动切换？" class="headerlink" title="主从如何做到故障自动切换？"></a>主从如何做到故障自动切换？</h2><p>Redis 哨兵机制就登场了，哨兵在发现主节点出现故障时，由哨兵自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性。</p>
<p>哨兵其实是一个运行在特殊模式下的 Redis 进程，所以它也是一个节点。<br>哨兵节点主要负责三件事情：监控、选主、通知。</p>
<p>主观下线：如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「主观下线」。可能只是因为主节点的系统压力比较大或者网络发送了拥塞，所以会有误判情况。</p>
<p>客观下线：为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成哨兵集群（最少需要三台机器来部署哨兵集群），通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况。</p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。quorum 的值一般设置为哨兵个数的二分之一加1，例如 3 个哨兵就设置 2。</p>
<h2 id="主从故障转移操作包含以下四个步骤："><a href="#主从故障转移操作包含以下四个步骤：" class="headerlink" title="主从故障转移操作包含以下四个步骤："></a>主从故障转移操作包含以下四个步骤：</h2><ol>
<li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li>
<li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>第三步：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li>
<li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li>
</ol>
<h2 id="哨兵集群是如何组成的？"><a href="#哨兵集群是如何组成的？" class="headerlink" title="哨兵集群是如何组成的？"></a>哨兵集群是如何组成的？</h2><p>哨兵节点之间是通过 Redis 的发布者&#x2F;订阅者机制来相互发现的。</p>
<h1 id="过期删除和内存淘汰"><a href="#过期删除和内存淘汰" class="headerlink" title="过期删除和内存淘汰"></a>过期删除和内存淘汰</h1><h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个过期字典（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p>
<p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p>
<pre><code>1. 如果不在，则正常读取键值；
2. 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。
</code></pre>
<p>三种过期策略对比</p>
<pre><code>1. 定时删除：创建定时事件，事件处理器到期自动执行
    优点：内存最友好，能尽快释放内存
    缺点：CPU不友好，过期key较多时会占用相当一部分CPU时间
2. 惰性删除：每次访问 key 时，都检测 key 是否过期，如果过期则删除该 key
    优点：CPU最友好，每次访问才检查并删除过期key，只会使用很少的CPU资源。
    缺点：内存不友好，如果不访问，过期key则永远停留在内存不会被释放。
3. 定期删除：每隔一段时间「随机」从数据库中取出一定数量的 key 进行抽样检查，并删除其中的过期key，并根据抽样比例和删除时间确定需要继续。
    优点：通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。
    缺点：内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。
</code></pre>
<p>Redis 使用的过期删除策略是「惰性删除+定期删除」这两种策略配和使用，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。<br><img src="./过期删除策略.webp" width = "50%" height = "50%" alt="过期删除策略" align=center /></p>
<p>Redis 的定期删除的流程（默认每秒10次，每次20）：</p>
<pre><code>1. 从过期字典中随机抽取 20 个 key；
2. 检查这 20 个 key 是否过期，并删除已过期的 key；
3. 判断执行时间是否超过上限？
3. 判断过期key是否超过25%？如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。
</code></pre>
<p>定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p>
<h2 id="持久化时，对过期键会如何处理的？"><a href="#持久化时，对过期键会如何处理的？" class="headerlink" title="持久化时，对过期键会如何处理的？"></a>持久化时，对过期键会如何处理的？</h2><h3 id="RDB-文件生成阶段和加载阶段。"><a href="#RDB-文件生成阶段和加载阶段。" class="headerlink" title="RDB 文件生成阶段和加载阶段。"></a>RDB 文件生成阶段和加载阶段。</h3><ol>
<li>RDB 文件生成阶段：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，过期的键「不会」被保存到新的 RDB 文件中</li>
<li>RDB 加载阶段：<ol>
<li>主服务器：在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中。</li>
<li>从服务器：在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。</li>
</ol>
</li>
</ol>
<h3 id="AOF-文件写入阶段和-AOF-重写阶段。"><a href="#AOF-文件写入阶段和-AOF-重写阶段。" class="headerlink" title="AOF 文件写入阶段和 AOF 重写阶段。"></a>AOF 文件写入阶段和 AOF 重写阶段。</h3><ol>
<li>AOF 文件写入阶段：当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。</li>
<li>AOF 重写阶段：执行 AOF 重写时，会对 Redis 中的键值对进行检查，已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响。</li>
</ol>
<h2 id="主从模式中，对过期键会如何处理？"><a href="#主从模式中，对过期键会如何处理？" class="headerlink" title="主从模式中，对过期键会如何处理？"></a>主从模式中，对过期键会如何处理？</h2><p>当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p>
<h2 id="内存满了，会发生什么？"><a href="#内存满了，会发生什么？" class="headerlink" title="内存满了，会发生什么？"></a>内存满了，会发生什么？</h2><p>在 Redis 的运行内存达到了某个阀值，就会触发内存淘汰机制，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p>
<h2 id="内存淘汰策略有哪些？"><a href="#内存淘汰策略有哪些？" class="headerlink" title="内存淘汰策略有哪些？"></a>内存淘汰策略有哪些？</h2><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。<br><img src="./内存淘汰策略.webp" width = "50%" height = "50%" alt="内存淘汰策略" align=center /></p>
<h3 id="不进行数据淘汰的策略"><a href="#不进行数据淘汰的策略" class="headerlink" title="不进行数据淘汰的策略"></a>不进行数据淘汰的策略</h3><p>noeviction（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p>
<h3 id="进行数据淘汰的策略"><a href="#进行数据淘汰的策略" class="headerlink" title="进行数据淘汰的策略"></a>进行数据淘汰的策略</h3><ol>
<li><p>设置了过期时间的数据中进行淘汰</p>
<ol>
<li>volatile-random：随机淘汰设置了过期时间的任意键值；</li>
<li>volatile-ttl：优先淘汰更早过期的键值。</li>
<li>volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li>
<li>volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值;</li>
</ol>
</li>
<li><p>在所有数据范围内进行淘汰</p>
<ol>
<li>allkeys-random：随机淘汰任意键值;</li>
<li>allkeys-lru：淘汰整个键值中最久未使用的键值；</li>
<li>allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li>
</ol>
</li>
</ol>
<h2 id="LRU-算法和-LFU-算法有什么区别？"><a href="#LRU-算法和-LFU-算法有什么区别？" class="headerlink" title="LRU 算法和 LFU 算法有什么区别？"></a>LRU 算法和 LFU 算法有什么区别？</h2><h3 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h3><p>LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。</p>
<p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<p>需要用链表管理所有的缓存数据，这会带来额外的空间开销；<br>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</p>
<h3 id="Redis-是如何实现-LRU-算法的？"><a href="#Redis-是如何实现-LRU-算法的？" class="headerlink" title="Redis 是如何实现 LRU 算法的？"></a>Redis 是如何实现 LRU 算法的？</h3><p>Redis 实现的是一种近似 LRU 算法，目的是为了更好的节约内存，它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。</p>
<p>当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<pre><code>不用为所有的数据维护一个大链表，节省了空间占用；
不用在每次数据访问时都移动链表项，提升了缓存的性能；
</code></pre>
<p>但是 LRU 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<h3 id="LFU-算法"><a href="#LFU-算法" class="headerlink" title="LFU 算法"></a>LFU 算法</h3><p>LFU 全称是 Least Frequently Used 翻译为最近最不常用的，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p>
<h3 id="Redis-是如何实现-LFU-算法的？"><a href="#Redis-是如何实现-LFU-算法的？" class="headerlink" title="Redis 是如何实现 LFU 算法的？"></a>Redis 是如何实现 LFU 算法的？</h3><p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p>
<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p>在 LRU 算法中，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p>
<p>在 LFU 算法中，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ol>
<li>用户数据存储在数据库，数据库数据落在磁盘上，磁盘读写速度是最慢的。</li>
<li>访问数据库的请求量一上来，容易造成数据库崩溃，所以会用redis作为缓存层。</li>
<li>redis是内存数据库，缓存在redis相当于缓存在内存，内存读写速度比磁盘快好几个数量级。大大提高系统性能。</li>
</ol>
<h2 id="缓存雪崩、击穿、穿透"><a href="#缓存雪崩、击穿、穿透" class="headerlink" title="缓存雪崩、击穿、穿透"></a>缓存雪崩、击穿、穿透</h2><img src="./缓存雪崩击穿穿透.webp" width = "50%" height = "50%" alt="缓存雪崩击穿穿透" align=center />

<p>缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。</p>
<p>不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。</p>
<p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p>
<h2 id="数据库和缓存如何保证一致性？"><a href="#数据库和缓存如何保证一致性？" class="headerlink" title="数据库和缓存如何保证一致性？"></a>数据库和缓存如何保证一致性？</h2><p>当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</p>
<ol>
<li>先更新数据库，再更新缓存<br> 并发时容易出现缓存和数据库不一致的情况。</li>
<li>先更新缓存，再更新数据库<br> 同样会出现不一致的现象。</li>
<li>先删除缓存，再更新数据库<br> 同样会出现不一致的现象。 </li>
<li>先更新数据库，再删除缓存<ol>
<li>极端情况也是会出现不一致。</li>
<li>但是实际中，缓存写入速度远远快于数据库写入。</li>
<li>所以可以保证一致性。</li>
<li>会影响缓存命中率</li>
</ol>
</li>
</ol>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>所有的底层数据结构都是为了高效设计的。</li>
<li>都要考虑尽可能减少磁盘读取次数。</li>
<li>都要考虑局部性原理，利用cpu缓存。</li>
<li>局部性原理（cpu缓存利用）<ol>
<li>时间局部性<br> 如果一个内存位置被引用，则在不久的将来，它很有可能被再次引用。</li>
<li>空间局部性<br> 如果一个内存位置被引用，则在不久的将来，它附近的内存位置很可能被引用。</li>
<li>结果<br> 正式因为程序局部性原理，计算机设计者增加了高速缓存存储器这个硬件，从而提高程序对主存的访问速度。</li>
</ol>
</li>
<li>大杂居（数据增删改-链表）小聚居(局部性原理-数组)<ol>
<li>redis list 的底层数据结构-【快表】<br> 【双向链表 + 压缩列表（类数组）】</li>
<li>mysql InnoDB 索引 B+ Tree<br> 【双向链表 + 数据页（连续内存空间）】<ol>
<li>非叶子节点是逐渐抽取的索引</li>
<li>叶子节点是双向链表数据，链表节点是数据页，数据页是连续内存空间，存放多条串联的数据记录，数据记录分组链表串联，并有分组头目录。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://xiaolincoding.com/redis/">图解Redis介绍</a><br><a href="https://try.redis.io/">在线redis环境</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis</title>
    <url>/%E5%AD%98%E5%82%A8/redis/</url>
    <content><![CDATA[<p>Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。Redis 通常被称为数据结构服务器。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>介绍<br> Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。Redis 通常被称为数据结构服务器。</li>
<li>特点  <ol>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供string&#x2F;list&#x2F;set&#x2F;zset&#x2F;hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ol>
</li>
<li>优势<ol>
<li>性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s </li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li>
</ol>
</li>
<li>redis 的 key 只能是字符串</li>
<li>redis 的 value 可以是如下<ol>
<li>String: 字符串</li>
<li>List: 列表</li>
<li>Set: 集合</li>
<li>zset: 有序集合</li>
<li>Hash: 散列</li>
</ol>
</li>
</ol>
<h2 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h2><ol>
<li>源码安装 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.14.tar.gz</span><br><span class="line">tar xzf redis-5.0.14.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-5.0.14</span><br><span class="line">make</span><br><span class="line">执行完 make 命令后，redis-5.0.14 的 src 目录下会出现编译后的 redis 服务程序 </span><br><span class="line">redis-server，还有用于测试的客户端程序 redis-cli</span><br></pre></td></tr></table></figure></li>
<li>启动 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./redis-server ../redis.conf</span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>使用 * 号获取所有配置项 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET *</span><br></pre></td></tr></table></figure></li>
<li>使用 CONFIG SET 修改配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure></li>
<li>主要配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">databases  # 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</span><br><span class="line">timeout # 当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</span><br><span class="line">bind 127.0.0.1  # 绑定的主机地址</span><br><span class="line">port 6379  # 指定 Redis 监听端口，默认端口为 6379</span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;  # 当本机为 slave，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步 </span><br><span class="line">requirepass foobared  # 设置 Redis 连接密码，如果配置了连接密码</span><br><span class="line">maxclients 128  # 设置同一时间最大客户端连接数，默认无限制</span><br><span class="line">maxmemory &lt;bytes&gt;  # 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li>登陆 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/data/service/redis5/bin/redis-cli -h 127.0.0.1 -p 6378 -a 【密码】</span><br><span class="line">redis-cli -h IP地址 -p 端口 -a 密码</span><br><span class="line">--raw  # 防止中文乱码，加上</span><br></pre></td></tr></table></figure></li>
<li>验证密码是否正确&#x2F;查看服务是否运行 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AUTH 【密码】  # 返回OK        </span><br><span class="line">PING  # 返回PONG</span><br></pre></td></tr></table></figure></li>
<li>切换到指定的数据库（默认总16个数据库，当前0） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 【index】</span><br></pre></td></tr></table></figure></li>
<li>查看redis信息 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info 【server】/【memory】</span><br></pre></td></tr></table></figure></li>
<li>查看所有的key列表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys *  # *是通配符，可以是其他前后缀匹配</span><br></pre></td></tr></table></figure></li>
<li>统计当前db下key数量 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DBSIZE</span><br></pre></td></tr></table></figure></li>
<li>查看key类型 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type 【key】</span><br></pre></td></tr></table></figure></li>
<li>判断key是否存在 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exists 【key】</span><br></pre></td></tr></table></figure></li>
<li>修改key名称 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename 【key】 【newkey】</span><br></pre></td></tr></table></figure></li>
<li>查看key过期时间<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ttl 【key】  # 以秒返回</span><br><span class="line">pttl 【key】  # 以毫秒返回</span><br><span class="line">(integer) -1  # 无过期时间返回</span><br><span class="line">(integer) -2  # KEY不存在返回</span><br></pre></td></tr></table></figure></li>
<li>设置&#x2F;清除key过期时间<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expire 【key】 3  # 设置3秒过期</span><br><span class="line">pexpire 【key】 3  # 设置3毫秒过期</span><br><span class="line">persist 【key】  # 移除 key 的过期时间，key 将持久保持。</span><br></pre></td></tr></table></figure></li>
<li>设置和删除<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set 【key】 【value】</span><br><span class="line">del 【key】</span><br></pre></td></tr></table></figure></li>
<li>删除当前db&#x2F;所有db的所有key<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushdb</span><br><span class="line">flushall</span><br></pre></td></tr></table></figure></li>
<li>批量删除key<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-cli -h 127.0.0.1 -p 6379 -a【密码】keys a_* | xargs ./redis-cli -h 127.0.0.1 -p 6379 -a【密码】 del</span><br><span class="line">&lt;!-- redis是单线程，如果redis包含了大量的键，执行keys命令可能会造成redis阻塞，所以一般建议不要在生产环境下使用keys，使用scan命令渐进式的遍历所有键，可以有效防止阻塞。 --&gt;</span><br><span class="line">./redis-cli -h 127.0.0.1 -p 6379 -a【密码】--scan --pattern &#x27;a_*&#x27; | xargs ./redis-cli -h 127.0.0.1 -p 6379 -a【密码】del</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>string<br> string 是 redis 最基本的类型，一个 key 对应一个 value。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set 【key】【value】  # 设置</span><br><span class="line">get 【key】  # 获取字符串</span><br><span class="line">strlen 【key】  # 获取字符串长度</span><br><span class="line">del 【key】  # 删除</span><br><span class="line">string 类型的值最大能存储 512MB</span><br></pre></td></tr></table></figure></li>
<li>hash<br> hash 是一个 string 类型的 field 和 value 的映射表， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset【key】 A &#x27;a&#x27; B &#x27;b&#x27;  # 设置</span><br><span class="line">hget 【key】A / hget 【key】B  # 获取单个</span><br><span class="line">hgetall 【key】  # 获取所有键值对，其中奇数为filed值,偶数为对应的value值</span><br><span class="line">hlen 【key】  # 获取hash键值对数量</span><br><span class="line">hkeys 【key】  # 获取所有key</span><br><span class="line">hvals 【key】  # 获取所有val</span><br><span class="line">del 【key】  # 删除</span><br><span class="line">hdel 【key】【field】  # 删除hash中某个字段及其值</span><br><span class="line">每个 hash 可以存储 2^32 -1 键值对（40多亿）</span><br></pre></td></tr></table></figure></li>
<li>list<br> list 是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpush 【key】 a  # 右插入</span><br><span class="line">lpush 【key】 b  # 左插入</span><br><span class="line">lset 【key】 【index】 &quot;del&quot;  # 替换列表第index的原始</span><br><span class="line">lindex 【key】【index】  # 查看列表指定index的元素</span><br><span class="line">lrange 【key】 0 1  # 查看列表所有元素</span><br><span class="line">llen 【key】  # 查看列表元素个数</span><br><span class="line">del 【key】  # 删除列表</span><br><span class="line">lrem 【key】0 &quot;value&quot; //从key中删除全部等值value的元素 0为全部，负值为从尾部开始</span><br><span class="line">列表最多可存储 2^32 - 1 元素 (4294967295, 每个列表可存储40多亿)</span><br></pre></td></tr></table></figure></li>
<li>set<br> Set 是 string 类型的无序集合。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd 【key】  # 插入集合元素</span><br><span class="line">scard 【key】  # 集合元素个数</span><br><span class="line">smembers 【key】  # 查看集合元素</span><br><span class="line">del 【key】  # 删除集合</span><br><span class="line">srem 【key】【元素1】 【元素2】 # 删除集合一个或多个成员元素，不存在的成员元素会被忽略</span><br><span class="line">集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)</span><br></pre></td></tr></table></figure></li>
<li>zset<br> zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br> 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br> zset的成员是唯一的,但分数(score)却可以重复   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd 【key】【score1】 【元素1】 【score2】 【元素2】  # 插入或更新集合元素分值</span><br><span class="line">zcard 【key】  # 集合元素个数</span><br><span class="line">zcount 【key】【min】【max】  # 计算有序集合中元素个数</span><br><span class="line"></span><br><span class="line">ZRANGE key start stop  # 通过索引区间返回有序集合指定区间内的成员</span><br><span class="line">zrange 【key】 0 -1  # 查看所有原素</span><br><span class="line">ZRANGEBYLEX 【key】【min】【max】  # 通过字典区间返回有序集合的成员 </span><br><span class="line">ZRANGEBYSCORE 【key】【min】【max】  # 通过分数返回有序集合指定区间内的成员</span><br><span class="line"></span><br><span class="line">ZSCORE 【key】 【member】  # 返回有序集中，成员的分数值</span><br><span class="line">del 【key】  # 删除集合</span><br><span class="line">ZREM【key】【member】 [member ...]  # 移除有序集合中的一个或多个成员</span><br><span class="line">集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><h3 id="基本参数名"><a href="#基本参数名" class="headerlink" title="基本参数名"></a>基本参数名</h3><ol>
<li>mem_fragmentation_ratio &#x3D; used_memory_rss&#x2F; used_memory<br> 内存碎片率</li>
<li>used_memory_rss<br> 操作系统实际分配给Redis的物理内存空间</li>
<li>used_memory<br> Redis为了保存数据实际申请使用的空间</li>
<li>如何清理内存碎片<ol>
<li>重启Redis实例<ol>
<li>如果Redis中的数据没有持久化，那么，数据就会丢失；</li>
<li>即使Redis数据持久化了，我们还需要通过AOF或RDB进行恢复，恢复时长取决于AOF或RDB的大小，如果只有一个Redis实例，恢复阶段无法提供服务。</li>
</ol>
</li>
<li>从4.0-RC3版本以后，Redis自身提供了一种内存碎片自动清理的方法<ol>
<li>Redis需要启用自动内存碎片清理<br> config set activedefrag yes</li>
<li>具体什么时候清理，会受到下面这两个参数的控制<ol>
<li>active-defrag-ignore-bytes 100mb<br> 表示内存碎片的字节数达到100MB时，开始清理；</li>
<li>active-defrag-threshold-lower 10<br> 表示内存碎片空间占操作系统分配给Redis的总空间比例达到10%时，开始清理。</li>
</ol>
</li>
<li>为了尽可能减少碎片清理对Redis正常请求处理的影响，自动内存碎片清理功能在执行时，还会监控清理操作占用的CPU时间，而且还设置了两个参数，分别用于控制清理操作占用的CPU时间比例的上、下限，既保证清理工作能正常进行，又避免了降低Redis性能。这两个参数具体如下：<ol>
<li>active-defrag-cycle-min 25<br> 表示自动清理过程所用CPU时间的比例不低于25%，保证清理能正常开展；</li>
<li>active-defrag-cycle-max 75<br> 示自动清理过程所用CPU时间的比例不高于75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞Redis，导致响应延迟升高。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><ol>
<li>什么是Redis？<ol>
<li>Redis 是一种基于内存的数据库，因此读写非常快，常用作缓存、消息队列、分布式锁等场景。</li>
<li>Redis 提供多种数据类型：String(字符串)、Hash(哈希)、List(列表)、Set(集合)、Zset(有序集合)、Bitmaps(位图)、HyperLogLog(基数统计)、GEO(地理信息)、Stream(流)。并且对数据类型的操作都是原子性的，因为执行命令是单线程负责，不存在并发竞争问题。</li>
<li>Redis 还支持事务、持久化、Lua脚本、多种集群方案（主从复制、哨兵模式、切片机群模式）、发布&#x2F;订阅模式、内存淘汰机制、过期删除机制等。</li>
</ol>
</li>
<li>Redis 和 Memcached 有什么区别？<ol>
<li>相同点<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
</li>
<li>不同点<ol>
<li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li>
<li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li>
<li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li>
</ol>
</li>
</ol>
</li>
<li>为什么用 Redis 作为 MySQL 的缓存？<ol>
<li>主要是因为 Redis 具备「高性能」和「高并发」两种特性。</li>
<li>高性能：访问 MySQL 数据是从硬盘读取，比较慢。而数据缓存在redis中，就是直接读取内存，速度非常快。</li>
<li>高并发：单台设备的redis的qps是mysql的10倍，能轻松突破10w，而mysql单机很难突破1w。</li>
</ol>
</li>
<li>Redis 数据类型以及使用场景分别是什么？<ol>
<li>Redis 提供了丰富的数据类型，常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。 <img src="./redis常用5种数据结构.webp" width = "50%" height = "50%" alt="redis常用5种数据结构" align=center /></li>
<li>应用场景<ol>
<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li>
<li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
</ol>
</li>
</ol>
</li>
<li>五种常见的 Redis 数据类型是怎么实现？</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://redis.io/">官网</a><br><a href="https://try.redis.io/">Redis 在线测试</a><br><a href="http://doc.redisfans.com/">Redis 命令参考</a><br><a href="https://www.runoob.com/redis/redis-tutorial.html">Redis 教程</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>sanic</title>
    <url>/%E6%A1%86%E6%9E%B6/sanic/</url>
    <content><![CDATA[<p>下一代 Python Web 服务器&#x2F;框架</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>是什么<br> Sanic 是 Python Web 服务器和 Web 框架，旨在提高性能。<br> Sanic 不仅仅是一个 框架，它还是一个 Web 服务器，具备开箱即用的功能。<br> 它可以用于编写，部署和扩展生产级 Web 应用程序。 🚀<br> Build fast. Run fast.</li>
<li>目标<br> 提供一种简单且快速，集创建和启动于一体的方法，来实现一个易于修改和拓展的 HTTP 服务</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos7 安装 python3.9</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local</span><br><span class="line">wget https://www.python.org/ftp/python/3.9.10/Python-3.9.10.tgz</span><br><span class="line">tar xvf Python-3.9.10.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.9.10/</span><br><span class="line">./configure --enable-optimizations</span><br><span class="line">sudo make altinstall</span><br><span class="line">/usr/local/bin/python3.9 -m pip install --upgrade pip</span><br><span class="line">pip39 install virtualenv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装sanic 23.3.0</span></span><br><span class="line">pip install sanic</span><br><span class="line"><span class="comment"># 安装扩展</span></span><br><span class="line">pip install sanic-ext</span><br></pre></td></tr></table></figure>


<h2 id="实践-helloworld"><a href="#实践-helloworld" class="headerlink" title="实践-helloworld"></a>实践-helloworld</h2><ol>
<li>编辑server.py <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Sanic</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> text, json</span><br><span class="line"></span><br><span class="line">app = Sanic(<span class="string">&quot;MyHelloWorldApp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># return text(&quot;Hello, world.&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> json(&#123;<span class="string">&#x27;hello&#x27;</span>: <span class="string">&#x27;world&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(</span><br><span class="line">        host=<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">        port=<span class="number">8000</span>,</span><br><span class="line">        workers=<span class="number">1</span>,</span><br><span class="line">        debug=<span class="literal">True</span>,</span><br><span class="line">        access_log=<span class="literal">True</span>,  <span class="comment"># 访问日志开关，进针对自带日志有效，自定义的无效</span></span><br><span class="line">        auto_reload=<span class="literal">True</span>,  <span class="comment"># 自动重载代码</span></span><br><span class="line">        dev=<span class="literal">True</span>,  <span class="comment"># 等价于debug+auto_reload</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li>
<li>运行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python server.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行验证</span></span><br><span class="line">curl localhost:8000 -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器请求服务</span></span><br><span class="line">http://&lt;服务器IP&gt;:8000</span><br><span class="line"><span class="comment"># 查看OpenAPI和运行的功能</span></span><br><span class="line">http://&lt;服务器IP&gt;:8000/docs</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="实践-docker"><a href="#实践-docker" class="headerlink" title="实践-docker"></a>实践-docker</h2><ol>
<li><p>Dockerfile</p>
 <figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> sanicframework/sanic:<span class="number">3.8</span>-latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /sanic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;server.py&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
<li><p>server.py</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;docker_sanic</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Request, Sanic</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> text</span><br><span class="line"></span><br><span class="line">app = Sanic(<span class="string">&quot;MySanicApp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;OK!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>构建启动</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t my-sanic-image .</span><br><span class="line">docker run --name mysanic -p 8000:8000 -d my-sanic-image</span><br><span class="line"><span class="comment"># 浏览器输入</span></span><br><span class="line">http://&lt;服务器IP&gt;:8000/</span><br></pre></td></tr></table></figure></li>
<li><p>nginx_sanic.conf</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://mysanic:8000/;</span><br><span class="line">      proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">      proxy_set_header Connection upgrade;</span><br><span class="line">      proxy_set_header Accept-Encoding gzip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>docker-compose.yml</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysanic:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-sanic-image</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mynginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.13.6-alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysanic</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysanic.conf:/etc/nginx/conf.d/mysanic.conf</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="comment"># 浏览器输入</span></span><br><span class="line">http://&lt;服务器IP&gt;:80/</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;测试sanic框架</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&quot;jesonlin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Request, Sanic</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> text, empty, file, redirect</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> json <span class="keyword">as</span> rsp_json</span><br><span class="line"><span class="keyword">from</span> sanic.handlers <span class="keyword">import</span> ErrorHandler</span><br><span class="line"></span><br><span class="line"><span class="comment"># from sanic.log import logger</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> LOGGING_CONFIG</span><br><span class="line"></span><br><span class="line"><span class="comment"># from sanic_ext import openapi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义request.id属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRequest</span>(<span class="title class_ inherited__">Request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;重载request加入请求id&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_id</span>(<span class="params">cls, *_</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;请求id默认自带就是用uuid&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> uuid.uuid4()</span><br><span class="line">        <span class="comment"># return time.time_ns()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义错误响应函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomErrorHandler</span>(<span class="title class_ inherited__">ErrorHandler</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义错误响应函数&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">default</span>(<span class="params">self, request, exception</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;handles errors that have no error handlers assigned&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 自定义的错误处理逻辑</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这里发生错误|%s&quot;</span> % exception)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().default(request, exception)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DIR_BASE = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">DIR_LOG = <span class="string">&quot;&#123;&#125;/logs&quot;</span>.<span class="built_in">format</span>(DIR_BASE)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(DIR_LOG):</span><br><span class="line">    os.makedirs(DIR_LOG)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化app</span></span><br><span class="line">app = Sanic(<span class="string">&quot;MyHelloWorldApp&quot;</span>, request_class=MyRequest, error_handler=CustomErrorHandler(), log_config=LOGGING_CONFIG)</span><br><span class="line"><span class="comment"># 上下文对象</span></span><br><span class="line"><span class="comment"># app.ctx.db = Database()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过配置文件加载更新配置</span></span><br><span class="line">app.update_config(<span class="string">&quot;./config.py&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># @openapi.no_autodoc  # 忽略生成文档</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;第一个sanic接口</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这是sanic的第一个接口，这里是接口注释。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    openapi:</span></span><br><span class="line"><span class="string">    ---</span></span><br><span class="line"><span class="string">    operationId: fooDots</span></span><br><span class="line"><span class="string">    tags:</span></span><br><span class="line"><span class="string">      - API</span></span><br><span class="line"><span class="string">    parameters:</span></span><br><span class="line"><span class="string">        - name: name</span></span><br><span class="line"><span class="string">          in: query</span></span><br><span class="line"><span class="string">          description: 用户名</span></span><br><span class="line"><span class="string">          required: True</span></span><br><span class="line"><span class="string">          schema:</span></span><br><span class="line"><span class="string">            type: string</span></span><br><span class="line"><span class="string">            format: str</span></span><br><span class="line"><span class="string">        - name: age</span></span><br><span class="line"><span class="string">          in: query</span></span><br><span class="line"><span class="string">          description: 用户年龄</span></span><br><span class="line"><span class="string">          required: False</span></span><br><span class="line"><span class="string">          schema:</span></span><br><span class="line"><span class="string">            type: integer</span></span><br><span class="line"><span class="string">            format: int32</span></span><br><span class="line"><span class="string">    responses:</span></span><br><span class="line"><span class="string">      &#x27;200&#x27;:</span></span><br><span class="line"><span class="string">        description: Just some dots</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">&quot;Here is your logssss: hello_world&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return text(&quot;hello world.&quot;)</span></span><br><span class="line">    <span class="comment"># return rsp_json(&#123;&quot;hello&quot;: &quot;world&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">return</span> rsp_json(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;token&quot;</span>: request.token,</span><br><span class="line">            <span class="string">&quot;user&quot;</span>: request.ctx.user,</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="built_in">str</span>(request.<span class="built_in">id</span>),</span><br><span class="line">            <span class="string">&quot;AUTO_RELOAD&quot;</span>: app.config.AUTO_RELOAD,</span><br><span class="line">            <span class="string">&quot;REQUEST_TIMEOUT&quot;</span>: app.config.REQUEST_TIMEOUT,</span><br><span class="line">            <span class="string">&quot;config&quot;</span>: <span class="built_in">str</span>(app.config),</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 响应函数: https://sanic.dev/zh/guide/basics/handlers.html#%E5%85%B3%E4%BA%8E-async-a-word-about-async</span></span><br><span class="line"><span class="comment"># 响应函数(Handlers)，也就是我们通常所说的视图(views)。</span></span><br><span class="line"><span class="comment"># 它至少以一个 request 实例作为参数，并返回一个 HTTPResponse 实例或一个执行其他操作的协同程序作为响应。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/async&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_handler</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;异步响应接口，请求体&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># json -d &#x27;&#123;&quot;foo&quot;: &quot;bar&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.json)  <span class="comment"># &#123;&#x27;foo&#x27;: &#x27;bar&#x27;&#125;</span></span><br><span class="line">    <span class="comment"># raw -d &#x27;&#123;&quot;foo&quot;: &quot;bar&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.body)  <span class="comment"># b&#x27;&#123;&quot;foo&quot;: &quot;bar&quot;&#125;&#x27;</span></span><br><span class="line">    <span class="comment"># form -d &#x27;foo=bar&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.body)  <span class="comment"># b&#x27;foo=bar&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.form)  <span class="comment"># &#123;&#x27;foo&#x27;: [&#x27;bar&#x27;]&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(request.form.get(<span class="string">&quot;foo&quot;</span>))  <span class="comment"># bar</span></span><br><span class="line">    <span class="built_in">print</span>(request.form.getlist(<span class="string">&quot;foo&quot;</span>))  <span class="comment"># [&#x27;bar&#x27;]</span></span><br><span class="line">    <span class="comment"># upload -F &#x27;my_file=@/path/to/TEST&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.body)</span><br><span class="line">    <span class="built_in">print</span>(request.files)  <span class="comment"># &#123;&#x27;my_file&#x27;: [File(type=&#x27;application/octet-stream&#x27;, body=b&#x27;hello\n&#x27;, name=&#x27;TEST&#x27;)]&#125;</span></span><br><span class="line">    <span class="built_in">print</span>(request.files.get(<span class="string">&quot;my_file&quot;</span>))  <span class="comment"># File(type=&#x27;application/octet-stream&#x27;, body=b&#x27;hello\n&#x27;, name=&#x27;TEST&#x27;)</span></span><br><span class="line">    <span class="built_in">print</span>(request.files.getlist(<span class="string">&quot;my_file&quot;</span>))  <span class="comment"># [File(type=&#x27;application/octet-stream&#x27;, body=b&#x27;hello\n&#x27;, name=&#x27;TEST&#x27;)]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rsp_json(&#123;<span class="string">&quot;async_handlerf&quot;</span>: <span class="string">&quot;Done.&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 请求: https://sanic.dev/zh/guide/basics/request.html</span></span><br><span class="line"><span class="comment"># 所有的 响应函数 都必须返回一个 response 对象，中间件 可以自由选择是否返回 response 对象。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_fetch_user_by_token</span>(<span class="params">token</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;异步根据token获取用户名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;jesonlin&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.middleware(<span class="params"><span class="string">&quot;request&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run_before_handler</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;request中间件封装参数进上下文对象</span></span><br><span class="line"><span class="string">    通常被用来存储服务端通过某些验证后需要临时存储的身份认证信息以及专有变量等内容。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    request.ctx.user = <span class="keyword">await</span> _fetch_user_by_token(request.token)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/ctx&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ctx</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试上下文对象取值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这里是接口内部&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;Hi, my name is &#123;&#125;\napp.ctx is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(request.ctx.user, app.ctx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @app.route(&quot;/route_tag/&lt;tag:int&gt;&quot;)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">r&quot;/route_tag/&lt;tag:[a-z]&#123;3&#125;.txt&gt;&quot;</span>, name=<span class="string">&quot;get_route_tag&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">route_tag</span>(<span class="params">request, tag: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试提取路径部分参数</span></span><br><span class="line"><span class="string">    &lt;tag:int&gt;  路径参数强制转换为int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;tag: %s\n args: %s&quot;</span> % (tag, request.args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/args/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">args</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回请求参数&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 和上述的 request.form、request.files 对象一样，request.args 同样是少数几种字典之一，每个值都是一个列表。这是因为HTTP允许单个键名被重用以发送多个值。</span></span><br><span class="line">    <span class="built_in">print</span>(request.args)</span><br><span class="line">    <span class="comment"># curl &#x27;http://localhost:8000/print_args?key1=val1&amp;key2=val2&amp;key1=\[val3\]&#x27;</span></span><br><span class="line">    <span class="comment"># &#123;&#x27;key1&#x27;: [&#x27;val1&#x27;, &#x27;[val3]&#x27;], &#x27;key2&#x27;: [&#x27;val2&#x27;]&#125;</span></span><br><span class="line">    <span class="comment"># &#x27;val1&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(request.args.get(<span class="string">&quot;key1&quot;</span>))</span><br><span class="line">    <span class="comment"># [&#x27;val1&#x27;, &#x27;[val3]&#x27;]</span></span><br><span class="line">    <span class="built_in">print</span>(request.args.getlist(<span class="string">&quot;key1&quot;</span>))</span><br><span class="line">    <span class="comment"># [(&#x27;key1&#x27;, &#x27;val1&#x27;), (&#x27;key2&#x27;, &#x27;val2&#x27;), (&#x27;key1&#x27;, &#x27;[val3]&#x27;)]</span></span><br><span class="line">    <span class="built_in">print</span>(request.query_args)</span><br><span class="line">    <span class="comment"># key1=val1&amp;key2=val2&amp;key1=[val3]</span></span><br><span class="line">    <span class="built_in">print</span>(request.query_string)</span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;args - type:&#123;&#125; - value:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(request.args), request.args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 响应: https://sanic.dev/zh/guide/basics/response.html</span></span><br><span class="line"><span class="comment"># 所有的 响应函数 都必须返回一个 response 对象，中间件 可以自由选择是否返回 response 对象。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/response/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">response</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试响应函数返回不同类型&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># return text(&quot;Hi 😎&quot;)</span></span><br><span class="line">    <span class="comment"># return rsp_json(&#123;&quot;foo&quot;: &quot;bar&quot;&#125;)</span></span><br><span class="line">    <span class="comment"># return redirect(&quot;/hi&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> file(<span class="string">&quot;A.jpg&quot;</span>)</span><br><span class="line">    <span class="comment"># return empty()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/route&quot;</span>, methods=[<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="comment"># @app.post(&quot;/route&quot;)</span></span><br><span class="line"><span class="comment"># @app.get(&quot;/route&quot;)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">route</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;中间件添加路由&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 路由: https://sanic.dev/zh/guide/basics/routing.html#%E6%B7%BB%E5%8A%A0%E8%B7%AF%E7%94%B1-adding-a-route</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/dynamic_route&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dynamic_route</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;动态路由&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 您可以传递任意数量的关键字参数，任何非路由参数的部分都会被是做为查询字符串的一部分</span></span><br><span class="line">    <span class="comment"># 同样支持为一个键名传递多个值</span></span><br><span class="line">    <span class="comment"># url = app.url_for(&quot;route_tag&quot;, tag=&quot;abc.txt&quot;, arg_one=[&quot;one&quot;, &quot;two&quot;])</span></span><br><span class="line">    <span class="comment"># 有路由名称name则只能通过路由名称name</span></span><br><span class="line">    url = app.url_for(<span class="string">&quot;get_route_tag&quot;</span>, tag=<span class="string">&quot;abc.txt&quot;</span>, arg_one=[<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>])</span><br><span class="line">    <span class="keyword">return</span> redirect(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 监听器: https://sanic.dev/zh/guide/basics/listeners.html</span></span><br><span class="line"><span class="comment"># 允许您将功能挂载到工作进程的生命周期</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.reload_process_start</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">reload_process_start</span>(<span class="params">*_</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听重载进程，只一次&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听重载进程 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.main_process_start</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_process_start</span>(<span class="params">*_</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听启动程序进程，只一次&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听主程序启动 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_server_start</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">before_server_start</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听服务启动前&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听服务启动前 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line">    app.ctx.db = <span class="string">&quot;DB_INFO&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_server_start</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">after_server_start</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听服务启动后&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听服务启动后 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_server_stop</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">before_server_stop</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听服务结束前&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听服务结束前 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_server_stop</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">after_server_stop</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听服务结束后&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听服务结束后 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.main_process_stop</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main_process_stop</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;监听器 设置DB&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 监听主程序结束 &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 中间件: https://sanic.dev/zh/guide/basics/middleware.html</span></span><br><span class="line"><span class="comment"># 中间件允许您将功能挂载到 HTTP 流的生命周期。</span></span><br><span class="line"><span class="comment"># 可以在执行响应函数之前或者响应函数之后执行中间件</span></span><br><span class="line"><span class="comment"># 如果中间件返回了一个 HTTPResponse 对象， 那么请求将会终止，此对象将会作为最终响应进行返回。</span></span><br><span class="line"><span class="comment"># 返回 None 值来跳过某个中间件的执行</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># @app.middleware(&quot;request&quot;)</span></span><br><span class="line"><span class="meta">@app.on_request  </span><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">extract_user</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;请求中间件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.on_response</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">prevent_xss</span>(<span class="params">request, response</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;响应中间件&quot;&quot;&quot;</span></span><br><span class="line">    response.headers[<span class="string">&quot;X-Request-ID&quot;</span>] = request.<span class="built_in">id</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 标头: https://sanic.dev/zh/guide/basics/headers.html</span></span><br><span class="line"><span class="comment"># 令牌(Token)：从请求头中解析到的 Token &lt;token&gt; 或者 Bearer &lt;token&gt; 将会被赋值给 request.token</span></span><br><span class="line"><span class="comment"># 请求头、响应头</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/hosts&quot;</span>, name=<span class="string">&quot;foo&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hosts</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查看hosts 信息&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rsp_json(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;effective host&quot;</span>: request.host,  <span class="comment"># &quot;&lt;服务器IP&gt;:8000&quot;</span></span><br><span class="line">            <span class="string">&quot;host header&quot;</span>: request.headers.get(<span class="string">&quot;host&quot;</span>),  <span class="comment"># &quot;&lt;服务器IP&gt;:8000&quot;</span></span><br><span class="line">            <span class="string">&quot;forwarded host&quot;</span>: request.forwarded.get(<span class="string">&quot;host&quot;</span>),  <span class="comment"># null</span></span><br><span class="line">            <span class="string">&quot;you are here&quot;</span>: request.url_for(<span class="string">&quot;foo&quot;</span>),  <span class="comment"># &quot;http://&lt;服务器IP&gt;:8000/hosts&quot;</span></span><br><span class="line">            <span class="string">&quot;all&quot;</span>: <span class="built_in">list</span>(request.headers.items()),</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># cookies: https://sanic.dev/zh/guide/basics/cookies.html#%E8%AF%BB%E5%8F%96-reading</span></span><br><span class="line"><span class="comment"># 通过 Request 对象的 cookies 字典来访问 Cookies。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cookie&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">cookie</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取cookies&quot;&quot;&quot;</span></span><br><span class="line">    test_cookie = request.cookies.get(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    rsp = text(<span class="string">&quot;Test cookie: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(test_cookie))</span><br><span class="line">    <span class="comment"># 写入cookies</span></span><br><span class="line">    rsp.cookies[<span class="string">&quot;test&quot;</span>] = <span class="string">&quot;cookies insert test&quot;</span></span><br><span class="line">    <span class="keyword">return</span> rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 后台任务: https://sanic.dev/zh/guide/basics/tasks.html#%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1-creating-tasks</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_task</span>(<span class="params">app</span>):  <span class="comment"># pylint: disable=redefined-outer-name</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;后台任务&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;MY TASK - PID: <span class="subst">&#123;os.getpid()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/data/service/python_project/project_sanic/task.txt&quot;</span>, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;begint run...\n&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    app.add_task(my_task(app))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个子进程都有</span></span><br><span class="line"><span class="comment"># app.add_task(slow_work)</span></span><br><span class="line"><span class="comment"># 通过任务别名查看任务</span></span><br><span class="line"><span class="comment"># task = app.get_task(&quot;slow_task&quot;)</span></span><br><span class="line"><span class="comment"># print(&quot;task=%s&quot; % task)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想只为主进程添加任务，您应该考虑使用 @app.main_process_start添加任务。</span></span><br><span class="line"><span class="meta">@app.before_server_start  </span><span class="comment"># 每个子进程都有</span></span><br><span class="line"><span class="comment"># @app.main_process_start  # 没效果，暂不知道原因</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_outer_task</span>(<span class="params">app, loop</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=====&gt;&gt;&gt;&gt;开始添加任务&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">&quot;=====&gt;&gt;&gt;&gt;开始添加任务&quot;</span>)</span><br><span class="line">    app.add_task(my_task(app))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 装饰器: https://sanic.dev/zh/guide/best-practices/decorators.html</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">check_request_for_authorization_status</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;验证权限&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authorized</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;权限装饰器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">f</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">f</span>)</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">decorated_function</span>(<span class="params">request, *args, **kwargs</span>):</span><br><span class="line">            <span class="comment"># run some method that checks the request</span></span><br><span class="line">            <span class="comment"># for the client&#x27;s authorization status</span></span><br><span class="line">            is_authorized = <span class="keyword">await</span> check_request_for_authorization_status(request)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_authorized:</span><br><span class="line">                <span class="comment"># the user is authorized.</span></span><br><span class="line">                <span class="comment"># run the handler method and return the response</span></span><br><span class="line">                rsp = <span class="keyword">await</span> f(request, *args, **kwargs)</span><br><span class="line">                <span class="keyword">return</span> rsp</span><br><span class="line">            <span class="comment"># the user is not authorized.</span></span><br><span class="line">            <span class="keyword">return</span> rsp_json(&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;not_authorized&quot;</span>&#125;, <span class="number">403</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorated_function</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 日志: https://sanic.dev/zh/guide/best-practices/logging.html</span></span><br><span class="line"><span class="comment"># 默认日志， from sanic.log import logger  logger.info(&quot;&quot;&quot;)</span></span><br><span class="line"><span class="comment"># 自定义日志</span></span><br><span class="line"><span class="comment"># import logging</span></span><br><span class="line"><span class="comment"># DIR_BASE = os.path.dirname(os.path.abspath(__file__))</span></span><br><span class="line"><span class="comment"># DIR_LOG = &quot;&#123;&#125;/logs&quot;.format(DIR_BASE)</span></span><br><span class="line"><span class="comment"># if not os.path.exists(DIR_LOG):</span></span><br><span class="line"><span class="comment">#     os.makedirs(DIR_LOG)</span></span><br><span class="line"><span class="comment"># LOGGING_CONFIG = &#123;</span></span><br><span class="line"><span class="comment">#     &quot;version&quot;: 1,</span></span><br><span class="line"><span class="comment">#     &quot;disable_existing_loggers&quot;: False,</span></span><br><span class="line"><span class="comment">#     &quot;formatters&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;verbose&quot;: &#123;&quot;format&quot;: &quot;[%(levelname)s %(asctime)s %(name)s %(lineno)d %(process)d %(thread)d] %(message)s&quot;&#125;</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &quot;handlers&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;console&quot;: &#123;</span></span><br><span class="line"><span class="comment">#             &quot;level&quot;: &quot;INFO&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;class&quot;: &quot;logging.StreamHandler&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;formatter&quot;: &quot;verbose&quot;,</span></span><br><span class="line"><span class="comment">#         &#125;,</span></span><br><span class="line"><span class="comment">#         &quot;backend_file&quot;: &#123;</span></span><br><span class="line"><span class="comment">#             &quot;delay&quot;: True,</span></span><br><span class="line"><span class="comment">#             &quot;class&quot;: &quot;logging.handlers.TimedRotatingFileHandler&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;filename&quot;: &quot;./logs/main.log&quot;,  # 日志输出文件</span></span><br><span class="line"><span class="comment">#             &quot;when&quot;: &quot;D&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;backupCount&quot;: 10,  # 备份份数</span></span><br><span class="line"><span class="comment">#             &quot;formatter&quot;: &quot;verbose&quot;,  # 使用哪种formatters日志格式</span></span><br><span class="line"><span class="comment">#             &quot;level&quot;: &quot;DEBUG&quot;,</span></span><br><span class="line"><span class="comment">#         &#125;,</span></span><br><span class="line"><span class="comment">#         &quot;backend_err_file&quot;: &#123;</span></span><br><span class="line"><span class="comment">#             &quot;delay&quot;: True,</span></span><br><span class="line"><span class="comment">#             &quot;class&quot;: &quot;logging.handlers.TimedRotatingFileHandler&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;filename&quot;: &quot;./logs/main_error.log&quot;,  # 日志输出文件</span></span><br><span class="line"><span class="comment">#             &quot;when&quot;: &quot;D&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;backupCount&quot;: 10,  # 备份份数</span></span><br><span class="line"><span class="comment">#             &quot;formatter&quot;: &quot;verbose&quot;,  # 使用哪种formatters日志格式</span></span><br><span class="line"><span class="comment">#             &quot;level&quot;: &quot;ERROR&quot;,</span></span><br><span class="line"><span class="comment">#         &#125;,</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &quot;loggers&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;&quot;: &#123;</span></span><br><span class="line"><span class="comment">#             &quot;handlers&quot;: [&quot;backend_file&quot;, &quot;backend_err_file&quot;],</span></span><br><span class="line"><span class="comment">#             &quot;level&quot;: &quot;INFO&quot;,</span></span><br><span class="line"><span class="comment">#             &quot;propagate&quot;: False,</span></span><br><span class="line"><span class="comment">#         &#125;</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="comment"># logger = logging.getLogger(__name__)</span></span><br><span class="line"><span class="comment"># app = Sanic(&quot;MyHelloWorldApp&quot;, log_config=LOGGING_CONFIG)</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"><span class="comment"># 运行: https://sanic.dev/zh/guide/deployment/running.html#sanic-%E6%9C%8D%E5%8A%A1%E5%99%A8-sanic-server</span></span><br><span class="line"><span class="comment"># 获取系统CPU核心数量</span></span><br><span class="line"><span class="comment"># workers = multiprocessing.cpu_count()</span></span><br><span class="line"><span class="comment"># app.run(host=&#x27;0.0.0.0&#x27;, port=8000, workers=workers, fast=True)</span></span><br><span class="line"><span class="comment"># gunicorn: 一个基于 UNIX 操作系统的 WSGI HTTP 服务器。它是从 Ruby 的 Unicorn 项目中移植而来，采用的是 pre-fork worker 模型。</span></span><br><span class="line"><span class="comment"># gunicorn myapp:app --bind 0.0.0.0:1337 --worker-class sanic.worker.GunicornWorker</span></span><br><span class="line"><span class="comment"># 如果您的应用有内存泄漏的困扰，您可以通过配置 Gunicorn 使子进程在处理了一定数量的请求后平滑重启。这种方法可以很方便得减少内存泄漏带来的影响。</span></span><br><span class="line"><span class="comment"># 当通过 gunicorn 运行 Sanic 时，您将失去 async/await 带来的诸多性能优势。对于该种部署方式，请三思而后行。的确，Gunicorn 提供了很多配置选项，但它不是让 Sanic 全速运行的最佳坏境。</span></span><br><span class="line"><span class="comment"># ============================================ #</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(</span><br><span class="line">        host=<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">        port=<span class="number">8000</span>,</span><br><span class="line">        <span class="comment"># workers=workers,</span></span><br><span class="line">        fast=<span class="literal">True</span>,  <span class="comment"># 自动以系统最大的核心数量来创建工作线程</span></span><br><span class="line">        debug=<span class="literal">True</span>,</span><br><span class="line">        access_log=<span class="literal">True</span>,  <span class="comment"># 访问日志开关，进针对自带日志有效，自定义的无效</span></span><br><span class="line">        auto_reload=<span class="literal">True</span>,  <span class="comment"># 自动重载代码</span></span><br><span class="line">        <span class="comment"># dev=True,  # 等价于debug+auto_reload</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>


<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://sanic.dev/zh/">官网</a><br><a href="https://sanic.dev/zh/plugins/sanic-ext/openapi/autodoc.html">sanic-自助生成文档</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>sanic</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite3</title>
    <url>/%E5%AD%98%E5%82%A8/sqlite3/</url>
    <content><![CDATA[<p>SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。SQLite 源代码不受版权限制。</p>
<span id="more"></span>

<h2 id="SQL-命令分类"><a href="#SQL-命令分类" class="headerlink" title="SQL 命令分类"></a>SQL 命令分类</h2><ol>
<li>DDL - 数据定义语言 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE，ALTER，DROP</span><br></pre></td></tr></table></figure></li>
<li>DML - 数据操作语言 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT，UPDATE，DELETE</span><br></pre></td></tr></table></figure></li>
<li>DQL - 数据查询语言 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ol>
<li>创建数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 将会在当前目录下创建一个文件testDB.db --&gt;</span><br><span class="line">sqlite3 testDB.db </span><br></pre></td></tr></table></figure></li>
<li>显示数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.databases</span><br></pre></td></tr></table></figure></li>
<li>导出数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite3 testDB.db .dump &gt; testDB.sql</span><br></pre></td></tr></table></figure></li>
<li>导入到数据库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite3 testDB.db &lt; testDB.sql</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><ol>
<li>创建数据表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table if not exists tb_config_filter(id integer primary key autoincrement, instanceid varchar(255) default &#x27;&#x27;, instancename varchar(255) default &#x27;&#x27;, metricName varchar(255) default &#x27;&#x27;, metricsshowname varchar(255) default &#x27;&#x27;, metriclimit text default &#x27;&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>显示数据表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.tables</span><br></pre></td></tr></table></figure></li>
<li>删除表 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [TABLE_NAME];</span><br></pre></td></tr></table></figure></li>
<li>显示建表语句 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.schema [TABLE_NAME]</span><br></pre></td></tr></table></figure></li>
<li>插入表数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME ([COLUMN1],...,[COLUMNN]) VALUES ([VALUE1],...,[VALUEN]);</span><br><span class="line">&lt;!-- 自增id字段值可用null替代或者不写 --&gt;</span><br><span class="line">insert into tb_config_filter(id, instancename) values(null, &#x27;cdb_yunying1_dev&#x27;);</span><br><span class="line">insert into tb_config_filter(metricsshowname) values(&#x27;CPU利用率&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>删除表数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name WHERE [CONDITION];</span><br><span class="line">&lt;!-- 删除单条 --&gt;</span><br><span class="line">delete from tb_config_filter where id=2;</span><br><span class="line">&lt;!-- 删除所有数据 --&gt;</span><br><span class="line">delete from tb_config_filter </span><br></pre></td></tr></table></figure></li>
<li>更新表数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET column1 = value1, column2 = value2...., columnN = valueN WHERE [CONDITION];</span><br><span class="line">&lt;!-- 更新自增id --&gt;</span><br><span class="line">UPDATE sqlite_sequence SET seq = &lt;下一个自增ID&gt; WHERE name = &lt;TABLE_NAME&gt;; </span><br></pre></td></tr></table></figure></li>
<li>查询表数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &lt;COLUMN1&gt;, ..., &lt;COLUMNN&gt; FROM &lt;TABLE_NAME&gt; WHERE &lt;CONDITION&gt;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 显示当前设置 --&gt;</span><br><span class="line">.show</span><br><span class="line">&lt;!-- 显示字段名称 --&gt;</span><br><span class="line">.header on</span><br><span class="line">&lt;!-- 按列格式化显示，每列字段值长度有限，会被截断 --&gt;</span><br><span class="line">.mode column</span><br><span class="line">&lt;!-- 设置列宽度 --&gt;</span><br><span class="line">.width 60</span><br><span class="line">&lt;!-- 按行格式化显示 --&gt;</span><br><span class="line">.mode line</span><br><span class="line">&lt;!-- 按csv格式化显示 --&gt;</span><br><span class="line">.mode csv</span><br><span class="line">&lt;!-- 空按NULL显示 --&gt;</span><br><span class="line">.nullvalue NULL</span><br><span class="line">&lt;!-- 输出到文件/屏幕输出 --&gt;</span><br><span class="line">.output [FILENAME]/stdout    </span><br><span class="line">&lt;!-- 所有表信息查询 --&gt;</span><br><span class="line">sq</span><br><span class="line">&lt;!-- 会有一个表sqlite_sequence记录表名对应自增id --&gt;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><ol>
<li>增加索引 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 单列索引 --&gt;</span><br><span class="line">CREATE INDEX &lt;INDEX_NAME&gt; ON &lt;TABLE_NAME&gt; (&lt;COLUMN_NAME&gt;);</span><br><span class="line">&lt;!-- 唯一索引 --&gt;</span><br><span class="line">CREATE UNIQUE INDEX &lt;INDEX_NAME&gt; ON &lt;TABLE_NAME&gt; (&lt;COLUMN_NAME&gt;);</span><br><span class="line">&lt;!-- 组合索引 --&gt;</span><br><span class="line">CREATE INDEX &lt;INDEX_NAME&gt; ON &lt;TABLE_NAME&gt; (&lt;COLUMN1_NAME&gt;, &lt;COLUMN2_NAME&gt;);</span><br></pre></td></tr></table></figure></li>
<li>删除索引 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX index_name</span><br></pre></td></tr></table></figure></li>
<li>什么情况下要避免使用索引？<br> 虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则：  <ol>
<li>索引不应该使用在较小的表上。</li>
<li>索引不应该使用在有频繁的大批量的更新或插入操作的表上。</li>
<li>索引不应该使用在含有大量的 NULL 值的列上。</li>
<li>索引不应该使用在频繁操作的列上。</li>
</ol>
</li>
</ol>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line">conn = sqlite3.connect(&#x27;test.db&#x27;)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">res = cursor.execute(&quot;create table if not exists tb_config_filter(id integer primary key autoincrement, instanceid varchar(255) default &#x27;&#x27;, instancename varchar(255) default &#x27;&#x27;, metricName varchar(255) default &#x27;&#x27;, metricsshowname varchar(255) default &#x27;&#x27;, metriclimit text default &#x27;&#x27;);&quot;)</span><br><span class="line">print(res)</span><br><span class="line">res = cursor.execute(&quot;CREATE INDEX idx_instanceid ON tb_config_filter (instanceid);&quot;)</span><br><span class="line">print(res)</span><br><span class="line">conn.commit()</span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>


<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017801751919456">使用sqlite</a><br><a href="https://www.runoob.com/sqlite/sqlite-tutorial.html">SQLite 教程</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime</title>
    <url>/%E8%BD%AF%E4%BB%B6/sublime/</url>
    <content><![CDATA[<p>Sublime Text 是一款流行的代码编辑器软件，也是HTML和散文先进的文本编辑器，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。<br><a href="https://www.sublimetext.com/">sublime英文官网</a><br><a href="https://www.sublimetextcn.com/">sublime中文官网</a></p>
<span id="more"></span>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>打开&#x2F;关闭左侧目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【k】，【cmd】+【b】</span><br></pre></td></tr></table></figure></li>
<li>展开&#x2F;折叠代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【k】+【0】/【1】/【2】</span><br></pre></td></tr></table></figure></li>
<li>打开&#x2F;关闭标签页 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【w】</span><br></pre></td></tr></table></figure></li>
<li>全屏 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【ctrl】+【f】</span><br></pre></td></tr></table></figure></li>
<li>选中中到行首&#x2F;选中到行尾 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!-- 自定义快捷键 --&gt;</span><br><span class="line">【shift】+【home】/【end】</span><br></pre></td></tr></table></figure></li>
<li>打开终端terminus <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【fn】|【option】+【t】</span><br></pre></td></tr></table></figure></li>
<li>json 格式化&#x2F;反格式化 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 自定义快捷键 --&gt;</span><br><span class="line">【cmd】+【fn】|【opt】+【j】/【m】</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>根据<a href="https://www.sublimetext.com/docs/linux_repositories.html">官方地址</a>下载安装</p>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol>
<li><p>安装 Package Control 插件包管理器</p>
<ol>
<li>旧版本安装<ol>
<li>快捷键打开控制台 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl + `</span><br></pre></td></tr></table></figure></li>
<li>输入代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &#x27;6f4c264a24d933ce70df5dedcf1dcaee&#x27; + &#x27;ebe013ee18cced0ef93d5f746d80ef60&#x27;; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#x27;http://packagecontrol.io/&#x27; + pf.replace(&#x27; &#x27;, &#x27;%20&#x27;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#x27;Error validating download (got %s instead of %s), please try manual install&#x27; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#x27;wb&#x27; ).write(by) </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>新版本安装<ol>
<li>快捷键打开查找栏 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】 +【shift】+【p】</span><br></pre></td></tr></table></figure></li>
<li>输入如下回车安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Install Package Control</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>其他常规配置</p>
<ol>
<li>打开侧边栏 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【shift】+【p】-》view: toggle side bar  or (【cmd】+【k】/【b】)</span><br></pre></td></tr></table></figure></li>
<li>打开上边栏  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【cmd】+【shift】+【p】-》view: toggle tab</span><br></pre></td></tr></table></figure></li>
<li>设置主题、字体大小及tab等 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Preferences -&gt; Settings -&gt; User or 【cmd】+【,】</span><br><span class="line">&quot;font_size&quot;: 21,</span><br><span class="line">&quot;tab_size&quot;: 4,</span><br><span class="line">&quot;translate_tabs_to_spaces&quot;: true,</span><br><span class="line">&quot;theme&quot;: &quot;Monokai Classic.sublime-theme&quot;,</span><br><span class="line">&quot;color_scheme&quot;: &quot;Monokai Classic.sublime-color-scheme&quot;,</span><br><span class="line">&quot;show_full_path&quot;: true,</span><br><span class="line">&quot;save_on_focus_lost&quot;: false,</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="插件安装-步骤"><a href="#插件安装-步骤" class="headerlink" title="插件安装-步骤"></a>插件安装-步骤</h2><ol>
<li>所有插件安装都是通过插件包管理器</li>
<li>【cmd】+【shift】+【p】</li>
<li>Install Package</li>
<li>输入对应插件名称</li>
</ol>
<h2 id="monikai-主题"><a href="#monikai-主题" class="headerlink" title="monikai 主题"></a>monikai 主题</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Theme-monokai pro</span><br></pre></td></tr></table></figure></li>
<li>配置主题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」-&gt; 「Package Settings」-&gt; 「Theme-Monokai Pro」-&gt; 选择「Monikai Classic」</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="sidebar强化"><a href="#sidebar强化" class="headerlink" title="sidebar强化"></a>sidebar强化</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SideBarEnhancements</span><br></pre></td></tr></table></figure></li>
<li>配置主题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」-&gt; 「Package Settings」-&gt; 「Theme-Monokai Pro」-&gt; 选择「Side Bar」</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="terminal-终端"><a href="#terminal-终端" class="headerlink" title="terminal 终端"></a>terminal 终端</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">terminus</span><br></pre></td></tr></table></figure></li>
<li>配置快捷键 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」 -&gt; 「Key Bindings」 -&gt; 「User」</span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+fn+t&quot;], &quot;command&quot;: &quot;toggle_terminus_panel&quot;&#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="json-格式化"><a href="#json-格式化" class="headerlink" title="json 格式化"></a>json 格式化</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pretty_json</span><br></pre></td></tr></table></figure></li>
<li>配置快捷键 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」 -&gt; 「Key Bindings」 -&gt; 「User」</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;command+fn+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;,</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;command+option+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;,</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;command+fn+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;,</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;command+option+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="black-Python代码格式化"><a href="#black-Python代码格式化" class="headerlink" title="black-Python代码格式化"></a>black-Python代码格式化</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sublack</span><br></pre></td></tr></table></figure></li>
<li>配置快捷键 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」-&gt; 「Package Settings」-&gt; 「sublack」-&gt;「Settings」</span><br><span class="line">&#123;</span><br><span class="line">    &quot;black_on_save&quot;: false,</span><br><span class="line">    &quot;black_line_length&quot;: 80,</span><br><span class="line">    &quot;black_command&quot;: &quot;/Users/jesonlin/Library/Python/3.8/bin/black&quot;,</span><br><span class="line">&#125;</span><br><span class="line">「Preference」 -&gt; 「Key Bindings」 -&gt; 「User」</span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+fn+b&quot;], &quot;command&quot;: &quot;black_file&quot;&#125;, </span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+option+b&quot;], &quot;command&quot;: &quot;black_file&quot;&#125;, </span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+fn+shift+b&quot;], &quot;command&quot;: &quot;black_diff&quot;&#125;, </span><br><span class="line">&#123;&quot;keys&quot;: [&quot;command+option+shift+b&quot;], &quot;command&quot;: &quot;black_diff&quot;&#125;, </span><br></pre></td></tr></table></figure></li>
<li>依赖python环境   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 intall black</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SublimeLinter-pylint和flake8检查python代码"><a href="#SublimeLinter-pylint和flake8检查python代码" class="headerlink" title="SublimeLinter-pylint和flake8检查python代码"></a>SublimeLinter-pylint和flake8检查python代码</h1><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SublimeLinter</span><br></pre></td></tr></table></figure></li>
<li>配置快捷键 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「Preference」-&gt; 「Package Settings」-&gt; 「SublimeLinter」-&gt;「Settings」</span><br><span class="line">// SublimeLinter Settings - User</span><br><span class="line">&#123;</span><br><span class="line">    &quot;linters&quot;: &#123;</span><br><span class="line">        &quot;pylint&quot;: &#123;</span><br><span class="line">            &quot;disable&quot;: false,</span><br><span class="line">            &quot;args&quot;: [&quot;--max-line-length=120&quot;],</span><br><span class="line">            &quot;executable&quot;: &quot;/Users/jesonlin/Library/Python/3.9/bin/pylint&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">            // Exclude files that match the given pattern(s).</span><br><span class="line">            &quot;excludes&quot;: [&quot;!*.py&quot;],</span><br><span class="line">            // E.g. [&quot;warning: &quot;, &quot;W3\d\d: &quot;, &quot;missing &lt;!DOCTYPE&gt; declaration&quot;]</span><br><span class="line">            &quot;filter_errors&quot;: [&quot;R0903&quot;,&quot;E0401&quot;,&quot;C0111&quot;,&quot;I0011&quot;,&quot;I0012&quot;,&quot;W0704&quot;,&quot;W0142&quot;,&quot;W0212&quot;,&quot;W0232&quot;,&quot;W0613&quot;,&quot;W0702&quot;,&quot;R0201&quot;,&quot;W0614&quot;,&quot;R0914&quot;,&quot;R0912&quot;,&quot;R0915&quot;,&quot;R0913&quot;,&quot;R0904&quot;,&quot;R0801&quot;,&quot;C0209&quot;],</span><br><span class="line">            &quot;lint_mode&quot;: &quot;background&quot;,</span><br><span class="line">            &quot;selector&quot;: &quot;&quot;,</span><br><span class="line">            &quot;styles&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;codes&quot;: [&quot;&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            // The current working dir the lint job will run in.</span><br><span class="line">            &quot;working_dir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;python&quot;: 3,</span><br><span class="line">            &quot;disable_if_not_dependency&quot;: false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;flake8&quot;: &#123;</span><br><span class="line">            &quot;disable&quot;: false,</span><br><span class="line">            &quot;args&quot;: [&quot;--max-line-length=120&quot;],</span><br><span class="line">            &quot;executable&quot;: &quot;/Users/jesonlin/Library/Python/3.9/bin/flake8&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;&#125;,</span><br><span class="line">            // Exclude files that match the given pattern(s).</span><br><span class="line">            &quot;excludes&quot;: [&quot;!*.py&quot;],</span><br><span class="line">            &quot;filter_errors&quot;: [&quot;E203&quot;],</span><br><span class="line">            &quot;lint_mode&quot;: &quot;background&quot;,</span><br><span class="line">            &quot;selector&quot;: &quot;&quot;,</span><br><span class="line">            &quot;styles&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;codes&quot;: [&quot;&quot;]</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;working_dir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;python&quot;: 3,</span><br><span class="line">            &quot;disable_if_not_dependency&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>依赖pylint和flake8 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install pylint</span><br><span class="line">pip3 install flake8</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="auto-refresh"><a href="#auto-refresh" class="headerlink" title="auto refresh"></a>auto refresh</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto refresh</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="SFTP"><a href="#SFTP" class="headerlink" title="SFTP"></a>SFTP</h2><ol>
<li>打开包管理器输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sftp</span><br></pre></td></tr></table></figure></li>
<li>配置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「File」-&gt; 「SFT|FTP」-&gt;「Setup Server」-&gt;打开文件编辑保存即可</span><br><span class="line">&quot;host&quot;: &quot;XXX.XXX.XXX.XXX&quot;,</span><br><span class="line">&quot;user&quot;: &quot;root&quot;,</span><br><span class="line">&quot;password&quot;: &quot;XXX&quot;,</span><br><span class="line">&quot;remote_path&quot;: &quot;XXX&quot;,</span><br></pre></td></tr></table></figure></li>
<li>使用<ol>
<li>同步到本地<ol>
<li>新建一个待同步的空白文件夹</li>
<li>在文件名右键「SFTP|FTP」-&gt;「Map to Remote」-&gt; 弹出文件配置远程信息保存 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;host&quot;: &quot;XXX.XXX.XXX.XXX&quot;,</span><br><span class="line">    &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;XXX&quot;,</span><br><span class="line">&quot;remote_path&quot;: &quot;XXX&quot;,</span><br><span class="line">    &quot;keepalive&quot;: 3600,</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>鼠标文件名右键选则「Download Folder」</li>
</ol>
</li>
</ol>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><p><a href="https://zhuanlan.zhihu.com/p/91942738">Sublime Text 3 超详细插件安装</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
</search>
