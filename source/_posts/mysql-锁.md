---
title: mysql-锁
urlname: mysql-锁
top: false
categories:
    - 存储
tags:
    - mysql
author: jesonlin
date: 2022-12-08 20:07:30
update: 2022-12-08 20:07:30
---

MySQL 根据加锁的范围，可以分为全局锁、表级锁和行锁三类。

<!-- more -->

## 全局锁
1. 加解全局锁
    ```sql
    -- 加只读锁
    flush tables with read lock
    -- 解锁
    unlock tables
    -- 断开会话
    ```

2. 全局锁应用场景
    全局锁主要应用于全库逻辑备份，这样在备份期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

3. 全局锁缺点
    如果数据库大，那么备份就会很耗时，那么备份期间业务只能读取数据，而不能进行更新数据，会造成业务停滞。

4. 避免方式
    如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

    备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。

    但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。


## 表级锁
1. 分类
    1. 表锁
    2. 元数据锁
    3. 意向锁
    4. AUTO-INC 锁

2. 表锁
    ```sql
    -- 表级别共享锁，即读锁
    lock tables 表名 read

    -- 表级别独占锁，即写锁
    lock tables 表名 write

    -- 解锁
    unlock tables
    -- 断开会话
    ```

    需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。

    不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。

3. 元数据锁
    我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：
        
        1. 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
        2. 对一张表做结构变更操作的时候，加的是 MDL 写锁；

    MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。

    那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：

        1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
        2. 然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
        3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞

    那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

    所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。

4. 意向锁
    意向锁的目的是为了快速判断表里是否有记录被加锁。

    在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
    
    在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

    也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

    而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。

    如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢

5. AUTO-INC 锁
    表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。

    之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的

    AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。

    但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

    因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。

    一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。

    InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。

        1. 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
        2. 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
        3. 当 innodb_autoinc_lock_mode = 1：
            1. 普通 insert 语句，自增锁在申请之后就马上释放；
            2. 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

    当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生数据不一致的问题。

    这时可能存在主库两个事务随机插入，而从库是bin log原始语句顺序执行，相对有序。就会造成主从不一致情况。

    要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。

    所以，当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题。


## 行级锁
1. 分类
    1. Record Lock，记录锁，也就是仅仅把一条记录锁上；
    2. Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
    3. Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
    4. 插入意向锁
        一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

        如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

        插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。

        如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。


## MySQL 是怎么加锁的？
1. 什么 SQL 语句会加行级锁？
    如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为锁定读。
    ```sql
    -- 对读取的记录加共享锁(S型锁)
    select ... lock in share mode;

    -- 对读取的记录加独占锁(X型锁)
    select ... for update;
    ```

    除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。


## update 没加索引会锁全表？
1. 原因
    InnoDB 存储引擎的默认事务隔离级别是「可重复读」，但是在这个隔离级别下，在多个事务并发的时候，会出现幻读的问题，所谓的幻读是指在同一事务下，连续执行两次同样的查询语句，第二次的查询语句可能会返回之前不存在的行。

    因此 InnoDB 存储引擎自己实现了行锁，通过 next-key 锁（记录锁和间隙锁的组合）来锁住记录本身和记录之间的“间隙”，防止其他事务在这个记录之间插入新的记录，从而避免了幻读现象。

    当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。另外，这个锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。

    在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。

    比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁

    但是，在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。

2. 如何避免这种事故的发生？
    我们可以将 MySQL 里的 sql_safe_updates 参数设置为 1，开启安全更新模式。
    update 语句必须满足如下条件之一才能执行成功：

        使用 where，并且 where 条件中必须有索引列；
        使用 limit；
        同时使用 where 和 limit，此时 where 条件中可以没有索引列；

    delete 语句必须满足以下条件能执行成功：

        同时使用 where 和 limit，此时 where 条件中可以没有索引列；

    如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 force index([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。


## MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？
在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。

有一点要注意的是，在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。


## MySQL 死锁了，怎么办？
1. 死锁产生
    两个不同事务，获取包含相同区间的 next-key 锁，却又在插入或者修改或者删除该区间记录时，被对方的 next-key 锁阻塞，从而导致死锁

    案例中的事务 A 和事务 B 在执行完后 select ... for update 语句后都持有范围为(1006,+∞]的next-key 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。

    间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。

2. 如何避免死锁？
    死锁的四个必要条件：互斥、占有且等待、不可强占用、循环等待。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

    设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值时 50 秒。

    开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑，默认就开启。


## REFERENCE
[MySQL实战45讲](https://time.geekbang.org/column/intro/100020801)
[图解MySQL介绍](https://xiaolincoding.com/mysql/)